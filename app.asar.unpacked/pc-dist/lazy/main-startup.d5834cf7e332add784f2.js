(this.webpackJsonp = this.webpackJsonp || []).push([
  [20],
  {
    "3OF5": function (e, t, s) {
      "use strict";
      s.r(t);
      s("iGh7"), s("eqHM"), s("xDXR"), s("WrSY");
      var i = s("rePB"),
        a = s("jDHv"),
        n = s("oNLr"),
        r = s("igA5");
      const o = Object(a.define)("kv-cache"),
        c = Object(a.define)("kv-cache-in-mem");
      var l;
      class d {
        constructor(e) {
          Object(i.a)(this, "_prefix", void 0), (this._prefix = `${e}-kv-db`);
        }
        _buildKey(e) {
          return `${this._prefix}-${e}`;
        }
        async setItem(e, t) {
          const s = this._buildKey(e),
            i = r.a.getInstance();
          return await i.setItemAsync(s, n.stringify(t)), t;
        }
        async getItem(e) {
          const t = this._buildKey(e),
            s = r.a.getInstance(),
            i = await s.getItemAsync(t);
          return Promise.resolve(i ? n.parse(i) : void 0);
        }
        async removeItem(e) {
          const t = this._buildKey(e),
            s = r.a.getInstance();
          return await s.removeItemAsync(t), this;
        }
      }
      Object(a.singleton)(o)(
        (l = class {
          createCache(e) {
            return new d(`${e}`);
          }
        })
      );
      var h,
        u = s("ndDP");
      class g {
        constructor(e, t) {
          (this._unused_name = e),
            Object(i.a)(this, "_lru", void 0),
            (this._lru = new u.default(t));
        }
        setItem(e, t) {
          return this._lru.set(e, t), Promise.resolve(t);
        }
        getItem(e) {
          return Promise.resolve(this._lru.get(e));
        }
        removeItem(e) {
          return this._lru.delete(e), Promise.resolve(this);
        }
      }
      Object(a.singleton)(c)(
        (h = class {
          constructor() {
            Object(i.a)(this, "_registry", {});
          }
          createCache(e, t) {
            return (
              this._registry[e] || (this._registry[e] = new g(e, t)),
              this._registry[e]
            );
          }
        })
      );
      s("FX2a");
      var p = s("VTBJ");
      s("ahRi");
      var m = s("ptxg"),
        v = s("pUq9");
      let f;
      (f = class {
        getOverrideDomain(e) {}
        getDomainConfig() {
          return {};
        }
        setDomainConfig(e) {
          return this;
        }
        subscribe(e) {
          return () => {};
        }
      }),
        Object(a.injectable)()(f),
        Object(a.singleton)(m.a)(f);
      s("tPRg");
      var b = s("z0WU"),
        _ = (s("FcQj"), s("Ydol")),
        S = s("sxU/"),
        y = s("97kL"),
        C = s("eSGF"),
        I = s("NDmK"),
        O = s("Mgpg");
      let E;
      function T() {
        return (
          E ||
            (E = a.ModuleContainer.resolve(O.ZLoggerFactory).createZLogger(
              "utils",
              ["event-bus-effects"]
            )),
          E
        );
      }
      const R = {
        [y.FetchActions.DELETE_EVERYONE]: (e, t) => {
          L(e.toUid, e.msgId);
        },
        [y.FetchActions.UNDO_MULTI]: (e, t) => {
          var s;
          null == e ||
            null === (s = e.forEach) ||
            void 0 === s ||
            s.call(e, (e) => L(e.toUid || e.userId, e.msgId));
        },
        [y.FetchActions.UNDO]: (e, t) => {
          L(e.toUid || e.userId, e.msgId);
        },
        [y.FetchActions.REMOVE_MEDIA]: (e, t) => {
          for (let s of e.items)
            L(
              null == e ? void 0 : e.conversationId,
              null == s ? void 0 : s.msgId
            );
        },
        [y.ChatBoxActions.REMOVE_EXPIRED_MEDIA]: (e, t) => {
          L(
            null == e ? void 0 : e.conversationId,
            (null == e ? void 0 : e.msgIds) || (null == e ? void 0 : e.msgId)
          );
        },
        [y.ChatBoxActions.DELETE_MESSAGE]: (e, t) => {
          const s =
            e.toUid || e.userId || (e.conversation && e.conversation.userId);
          s !== I.default.sendToMeId && L(s, e.msgId);
        },
      };
      function L(e, t) {
        if (!e) return;
        if (!t) return;
        let s = Object(C.a)(t);
        S.a.instance.emit("media-removed", { convId: e, msgIds: s });
      }
      _.default.subscribe(function (e, t) {
        let s = R[e];
        if (s)
          try {
            s(t, e);
          } catch (i) {
            T().zsymb(
              18,
              11069,
              3e4,
              "Failed to run side effect for event:" + e
            ),
              T().zsymb(18, 11069, 30001, [i]);
          }
      });
      var M = s("2ua2");
      s.p;
      M.default.init(), b.default.checkSupport(), b.default.showWarningMsg();
      var F,
        w = s("1pet"),
        D = s("UiPd"),
        j = s("8/YW"),
        A = s("Kvb3"),
        N = s("QPNp");
      Object(a.singleton)(A.a)(
        (F =
          Object(j.e)()(
            (F =
              Reflect.metadata(
                "design:type",
                Function
              )(
                (F =
                  Reflect.metadata(
                    "design:paramtypes",
                    []
                  )(
                    (F = class {
                      constructor() {
                        Object(i.a)(this, "_isConnectSignalChangeInfo", void 0),
                          Object(i.a)(this, "_ipc", void 0),
                          Object(i.a)(this, "_dispatch", void 0),
                          Object(i.a)(this, "_authEvent", void 0),
                          (this._isConnectSignalChangeInfo = !1),
                          (this.signalInfoChange =
                            this.signalInfoChange.bind(this));
                      }
                      isWeb() {
                        return !1;
                      }
                      getIPC() {
                        if (!this.isWeb()) {
                          if (!this._ipc) {
                            const { ipcRenderer: e } = s("NLsH");
                            this._ipc = e;
                          }
                          return this._ipc;
                        }
                        return null;
                      }
                      bindDispatch(e) {
                        this._dispatch = e;
                      }
                      getDispatch() {
                        return this._dispatch;
                      }
                      async preFormatPayload(e) {
                        let t = Object(p.a)({}, e);
                        if (t.conversation) {
                          var s, i;
                          if (
                            null === (s = t.conversation.userId) ||
                            void 0 === s ||
                            null === (i = s.startsWith) ||
                            void 0 === i
                              ? void 0
                              : i.call(s, w.GROUPID_PREFIX)
                          ) {
                            const e = t.conversation.userId,
                              s = await N.a.GroupManager.get(e);
                            if (
                              (s &&
                                ((t.conversation.topMember = s.topMembers),
                                (t.conversation.displayName = s.displayName)),
                              t.conversation.topMember)
                            )
                              for (const i of t.conversation.topMember) {
                                const e = D.default.getMiniInfo(i.id);
                                e &&
                                  ((i.dName = e.dName), (i.avatar = e.avatar));
                              }
                          } else {
                            const e = D.default.getMiniInfo(
                              t.conversation.userId
                            );
                            e &&
                              ((t.conversation.displayName = e.dName),
                              (t.conversation.avatar = e.avatar));
                          }
                        }
                        return t;
                      }
                      signalInfoChange(e) {
                        if (!this.isWeb()) {
                          const t = this.getIPC();
                          t && t.send("update-info-photo-viewer", e);
                        }
                      }
                      connectSignalToFriendWorker() {
                        this._isConnectSignalChangeInfo ||
                          ((this._isConnectSignalChangeInfo = !0),
                          D.default.connectSignalChangeDNameAndAvatar(
                            this.signalInfoChange
                          ));
                      }
                      onAuthenticated(e) {
                        this._authEvent = e;
                      }
                      _addSession(e) {
                        var t;
                        return (
                          ((e = Object(p.a)({}, e)).session =
                            null === (t = this._authEvent) || void 0 === t
                              ? void 0
                              : t.getSession()),
                          e
                        );
                      }
                      async openPhotoViewer(e) {
                        let t = await this.preFormatPayload(e);
                        (t = this._addSession(t)),
                          this.connectSignalToFriendWorker();
                        const s = this.getDispatch();
                        s &&
                          s({
                            type: y.ChatBoxActions.SHOW_FULL_IMAGE,
                            payload: t,
                          });
                      }
                    })
                  ) || F)
              ) || F)
          ) || F)
      );
      s("TGaw");
      var P,
        k = s("EAii"),
        U = s("Fdeg"),
        B = s("rCQs"),
        G = s("oyvS"),
        z = s.n(G),
        x = s("PD1X"),
        V = s("KkZn");
      Object(B.b)(k.a)(
        (P =
          (function (e, t) {
            return a.ModuleContainer.inject(O.ZLoggerFactory)(e, void 0, 0);
          })(
            (P =
              (function (e, t) {
                return a.ModuleContainer.inject(j.a)(e, void 0, 1);
              })(
                (P =
                  Reflect.metadata(
                    "design:type",
                    Function
                  )(
                    (P =
                      Reflect.metadata("design:paramtypes", [
                        void 0 === O.ZLoggerFactory ? Object : O.ZLoggerFactory,
                        void 0 === j.a ? Object : j.a,
                      ])(
                        (P = class {
                          constructor(e, t) {
                            (this._app = t),
                              Object(i.a)(this, "_isExpired", !0),
                              Object(i.a)(
                                this,
                                "_localCacheName",
                                "res.zcache"
                              ),
                              Object(i.a)(this, "_localCacheFolders", {
                                [U.a.zaloLocal]: "",
                                [U.a.zaloDB]: "",
                                [U.a.zaloProramExe]: "",
                                [U.a.zaRF]: "",
                              }),
                              Object(i.a)(this, "_localCacheData", {
                                [U.a.zaloLocal]: new u.default({
                                  maxSize: 1e4,
                                }),
                                [U.a.zaloDB]: new u.default({ maxSize: 1e3 }),
                                [U.a.zaloProramExe]: new u.default({
                                  maxSize: 5e3,
                                }),
                                [U.a.zaRF]: new u.default({ maxSize: 1e3 }),
                              }),
                              Object(i.a)(this, "logger", void 0),
                              Object(i.a)(this, "init", () => {
                                "render" === __ZaBUNDLENAME__ &&
                                  this.getCachePaths();
                              }),
                              Object(i.a)(
                                this,
                                "getLocalCacheData",
                                async (e) => {
                                  const t = await Promise.all(
                                      U.e.map((t) =>
                                        this.readCacheFile(
                                          z.a.join(
                                            e,
                                            "ZaloDownloads" === t ? "" : t,
                                            ".rescache"
                                          )
                                        )
                                      )
                                    ),
                                    s = {};
                                  return (
                                    t.forEach((e, t) => {
                                      s[U.e[t]] = {
                                        count:
                                          (null == e ? void 0 : e.count) || 0,
                                        size:
                                          (null == e ? void 0 : e.totalSize) ||
                                          0,
                                      };
                                    }),
                                    s
                                  );
                                }
                              ),
                              Object(i.a)(this, "readCacheFile", (e) => {
                                const t = s("mw/K");
                                return new Promise((s) => {
                                  t.readFile(e, (e, t) => {
                                    if (e) return s(null);
                                    s(Object(V.r)(t.toString()) || null);
                                  });
                                });
                              }),
                              Object(i.a)(this, "_listenEvents", () => {
                                "render" === __ZaBUNDLENAME__ &&
                                  (this._app.addEventListener(
                                    j.b.Authenticated,
                                    this.init
                                  ),
                                  this._app.addEventListener(
                                    j.b.Exit,
                                    this._removeListeners
                                  ));
                              }),
                              Object(i.a)(this, "_removeListeners", () => {
                                "render" === __ZaBUNDLENAME__ &&
                                  (this._app.removeEventListener(
                                    j.b.Authenticated,
                                    this.init
                                  ),
                                  this._app.removeEventListener(
                                    j.b.Exit,
                                    this._removeListeners
                                  ));
                              }),
                              (this.logger = e.createZLogger("resmgmt", [
                                "cache-maanger",
                              ])),
                              this.logger.zsymb(
                                5,
                                11079,
                                3e4,
                                "ResCacheManager is created"
                              ),
                              this._listenEvents();
                          }
                          getCacheType(e) {
                            if (
                              e.startsWith(
                                this._localCacheFolders[U.a.zaloLocal]
                              )
                            )
                              return U.a.zaloLocal;
                            if (
                              e.startsWith(this._localCacheFolders[U.a.zaloDB])
                            )
                              return U.a.zaloDB;
                            if (
                              e.startsWith(
                                this._localCacheFolders[U.a.zaloProramExe]
                              )
                            )
                              return U.a.zaloProramExe;
                            if (
                              (this._getVerifiedZaRFPath(),
                              e.includes(this._localCacheFolders[U.a.zaRF]))
                            )
                              return U.a.zaRF;
                            throw new Error("Invalid cache type " + e);
                          }
                          hasScan(e) {
                            const t = this.getCacheType(e);
                            return this._localCacheData[t].has(e);
                          }
                          getScan(e) {
                            e = e.endsWith("/") ? e.slice(0, -1) : e;
                            const t = this.getCacheType(e);
                            if (this._localCacheData[t].has(e))
                              return this._localCacheData[t].get(e);
                            let s = () => {},
                              i = () => {};
                            const a = new Promise((e, t) => {
                              (s = e), (i = t);
                            });
                            return (
                              this._localCacheData[t].set(e, {
                                promise: a,
                                resolve: s,
                                reject: i,
                              }),
                              { promise: a, resolve: s, reject: i }
                            );
                          }
                          async revokeCache() {
                            this._isExpired = !0;
                          }
                          async signCache() {
                            (this._isExpired = !1), this._clearAllCacheData();
                          }
                          hasCacheFile(e) {
                            let t = z.a.dirname(e);
                            t = t.endsWith("/") ? t.slice(0, -1) : t;
                            const s = this.getCacheType(t);
                            if (this._isExpired)
                              return this._localCacheData[s].delete(e), !1;
                            this._localCacheFolders[s] || this.getCachePaths();
                            return this._localCacheData[s].has(t);
                          }
                          async getCacheFile(e) {
                            let t = 0,
                              s = z.a.dirname(e);
                            s = s.endsWith("/") ? s.slice(0, -1) : s;
                            const i = z.a.basename(e);
                            if (!this.hasCacheFile(e)) {
                              this.logger.zsymb(
                                15,
                                11079,
                                30001,
                                "Cache not found for {}. Request calculator for {}",
                                e,
                                s
                              );
                              try {
                                const e = new x.a(s),
                                  i = await e.run();
                                (t = i.result || 0),
                                  this.logger.zsymb(
                                    15,
                                    11079,
                                    30002,
                                    "Calculate {} responded with {}",
                                    s,
                                    i
                                  );
                              } catch (n) {}
                            }
                            const a =
                              this._localCacheData[this.getCacheType(e)].get(s);
                            return (
                              (t = (await a.promise).data[i][1]),
                              this.logger.zsymb(
                                15,
                                11079,
                                30003,
                                "Folder size: {} === {} bytes",
                                e,
                                t
                              ),
                              t
                            );
                          }
                          setCache(e, t) {
                            const s = this.getCacheType(e);
                            this._localCacheFolders[s] || this.getCachePaths(),
                              this._localCacheData[s].set(e, t);
                          }
                          verifyCache() {
                            this._isExpired = !1;
                          }
                          isValid() {
                            return !this._isExpired;
                          }
                          deleteCacheObject(e) {
                            this._localCacheData[e].clear();
                          }
                          _clearAllCacheData() {
                            this._localCacheData[U.a.zaloLocal].clear(),
                              this._localCacheData[U.a.zaloDB].clear(),
                              this._localCacheData[U.a.zaloProramExe].clear(),
                              this._localCacheData[U.a.zaRF].clear();
                          }
                          async loadLocalCache(e) {
                            {
                              const t = s("mw/K"),
                                i = s("oyvS");
                              this._localCacheFolders[e] ||
                                this.getCachePaths();
                              const a = i.join(
                                this._localCacheFolders[e],
                                this._localCacheName
                              );
                              if (t.existsSync(a)) {
                                const s = t.readFileSync(a);
                                JSON.parse(s).forEach((t) => {
                                  this._localCacheData[e].set(t[0], t[1]);
                                }),
                                  this.logger.zsymb(
                                    3,
                                    11079,
                                    30004,
                                    "Loaded rescache from {}",
                                    a
                                  );
                              }
                            }
                          }
                          getCachePaths() {
                            const e = s("Dprd").default;
                            (this._localCacheFolders[U.a.zaloLocal] =
                              null == e ? void 0 : e.getDataDirectory()),
                              (this._localCacheFolders[U.a.zaloDB] =
                                null == e ? void 0 : e.getDataBaseDir()),
                              (this._localCacheFolders[U.a.zaloProramExe] =
                                e.getExeDir());
                            for (const t in this._localCacheFolders) {
                              const e = this._localCacheFolders[t];
                              e &&
                                ((this._localCacheFolders[z.a.dirname(e)] = t),
                                (this._localCacheFolders[t] = z.a.dirname(e)));
                            }
                            this._getVerifiedZaRFPath();
                          }
                          _getVerifiedZaRFPath() {
                            const e = s("qlGb").getZaloFilesPath(),
                              t = z.a.dirname(e);
                            return (
                              (this._localCacheFolders[U.a.zaRF] = t),
                              (this._localCacheFolders[t] = U.a.zaRF),
                              t
                            );
                          }
                        })
                      ) || P)
                  ) || P)
              ) || P)
          ) || P)
      );
      const q = Object(a.define)("res-mgmt-action-log");
      var H = s("Ff2n");
      let K, $;
      !(function (e) {
        (e.DiskStatus = "DiskStatus"),
          (e.ZaloUsage = "ZaloUsage"),
          (e.DeleteConv = "DeleteConv"),
          (e.Cache = "Cache");
      })(K || (K = {})),
        (function (e) {
          (e[(e.Routine = 0)] = "Routine"),
            (e[(e.UserManual = 1)] = "UserManual");
        })($ || ($ = {}));
      const W = {
        [K.DiskStatus]: 5,
        [K.ZaloUsage]: 7,
        [K.DeleteConv]: 8,
        [K.Cache]: 9,
      };
      var Z = s("Yi2m"),
        Q = s("KmCD"),
        Y = s("bUXd"),
        J = s("u8fi"),
        X = s("Dprd"),
        ee = s("MGH9");
      const te = ["type"];
      a.ModuleContainer.registerSingleton(
        q,
        class {
          constructor() {
            Object(i.a)(this, "LogHistory", {
              [K.DiskStatus]: {
                ts: -I.default.full_disk_check.report_interval,
                pending: !1,
              },
              [K.ZaloUsage]: {
                ts: -I.default.full_disk_check.report_interval,
                pending: !1,
              },
              [K.Cache]: {
                ts: -I.default.full_disk_check.report_interval,
                pending: !1,
              },
            }),
              Object(i.a)(this, "autoReportTimer", null),
              Object(i.a)(this, "startAutoReport", () => {
                this.autoReportTimer ||
                  (this.autoReportTimer = setInterval(
                    this.report,
                    I.default.full_disk_check.report_interval
                  ));
              }),
              Object(i.a)(this, "report", async () => {
                this.diskStatusReport(),
                  this.zaloUsageReport(),
                  this.cacheReport({ scan_event: $.Routine });
              }),
              Object(i.a)(this, "getScanType", () => $),
              Object(i.a)(
                this,
                "getTimeNow",
                () => Y.a.getSystemTimeNow() || Date.now()
              ),
              Object(i.a)(
                this,
                "canReport",
                () =>
                  I.default.full_disk_check.enable_disk_cache &&
                  I.default.full_disk_check.enable_report
              ),
              Object(i.a)(this, "diskStatusReport", (e) => {
                if (!this.canReport()) return;
                const { DiskStatus: t } = this.LogHistory,
                  s = e ? $.UserManual : $.Routine;
                if ((s === $.Routine && !this._canActionLog(t.ts)) || t.pending)
                  return;
                this.LogHistory.DiskStatus.pending = !0;
                const i = e || Q.a.analyzeMainDisk();
                if (i) {
                  const { total: e, free: t } = i;
                  this.logAction999({
                    type: "DiskStatus",
                    scan_event: s,
                    free: t,
                    total: e,
                    ts: this.getTimeNow(),
                  });
                }
                this.LogHistory.DiskStatus.pending = !1;
              }),
              Object(i.a)(this, "zaloUsageReport", async (e) => {
                if (!this.canReport()) return;
                const { ZaloUsage: t } = this.LogHistory,
                  s = e ? $.UserManual : $.Routine;
                if ((s === $.Routine && !this._canActionLog(t.ts)) || t.pending)
                  return;
                this.LogHistory.ZaloUsage.pending = !0;
                const i = a.ModuleContainer.resolve(J.b),
                  n = e || { used: await i.getZaloUsage() };
                n &&
                  this.logAction999({
                    type: "ZaloUsage",
                    scan_event: s,
                    used: n.used,
                    ts: this.getTimeNow(),
                  }),
                  (this.LogHistory.ZaloUsage.pending = !1);
              }),
              Object(i.a)(this, "cacheReport", async (e) => {
                var t;
                if (!this.canReport()) return;
                const { Cache: s } = this.LogHistory,
                  i =
                    null != (t = null == e ? void 0 : e.scan_event)
                      ? t
                      : $.Routine;
                if ((i === $.Routine && !this._canActionLog(s.ts)) || s.pending)
                  return;
                this.LogHistory.Cache.pending = !0;
                const n = a.ModuleContainer.resolve(k.a),
                  r = await n.getLocalCacheData(
                    X.default.getUserCacheDirectory()
                  ),
                  o = a.ModuleContainer.resolve(ee.a),
                  c = { count: 0, size: 0 };
                o.getConvData().forEach((e) => {
                  const t = e.convId,
                    s = Q.a.getCache(t);
                  (c.count += 1),
                    s && (c.size += s.filesSize + s.imagesSize + s.videosSize);
                }),
                  r &&
                    this.logAction999({
                      type: "Cache",
                      scan_event: i,
                      cache: {
                        cache: r.Cache,
                        file_thumb: r.fileThumb,
                        file: r.file,
                        video: r.video,
                        picture: r.picture,
                        file_noise: r.file,
                        rich_thumb: r.richThumb,
                        known_by_db: c,
                        total_disk: r.ZaloDownloads,
                      },
                      ts: this.getTimeNow(),
                    }),
                  (this.LogHistory.Cache.pending = !1);
              }),
              Object(i.a)(this, "dispose", () => {
                clearInterval(this.autoReportTimer);
              }),
              Object(i.a)(this, "logAction999", (e) => {
                const { type: t } = e;
                Object(H.a)(e, te);
                let s;
                switch (t) {
                  case "DiskStatus":
                    (s = W.DiskStatus),
                      (this.LogHistory.DiskStatus.ts = performance.now());
                    break;
                  case "ZaloUsage":
                    (s = W.ZaloUsage),
                      (this.LogHistory.ZaloUsage.ts = performance.now());
                    break;
                  case "DeleteConv":
                    s = W.DeleteConv;
                    break;
                  case "Cache":
                    (s = W.Cache),
                      (this.LogHistory.Cache.ts = performance.now());
                }
                const i = Object(p.a)(
                  Object(p.a)({}, e),
                  {},
                  { device_id: Z.e.getDeviceID() }
                );
                return (
                  Z.e.logActionInfoV2(Z.b.ResourceManagementV2, s, i),
                  Promise.resolve()
                );
              }),
              Object(i.a)(
                this,
                "_canActionLog",
                (e) =>
                  performance.now() - e >
                  I.default.full_disk_check.report_interval
              ),
              this.startAutoReport();
          }
        }
      );
      const se = Object(a.define)("resmgmt-conv-filter-manager"),
        ie = Object(a.define)("resmgmt-convdata-manager");
      var ae = s("EFQ6"),
        ne = s("Gm1y"),
        re = s("AH6j");
      Event;
      class oe extends Event {
        constructor(e, t) {
          super(e), Object(i.a)(this, "payload", void 0), (this.payload = t);
        }
      }
      class ce extends Event {
        constructor(e, t) {
          super(e), Object(i.a)(this, "payload", void 0), (this.payload = t);
        }
      }
      class le extends Event {
        constructor(e, t) {
          super(e), Object(i.a)(this, "payload", void 0), (this.payload = t);
        }
      }
      class de extends Event {
        constructor(e) {
          super(e);
        }
      }
      Event;
      Event;
      let he;
      !(function (e) {
        (e.Update_Convdata_List = "Update_Convdata_List"),
          (e.ResCalc_UI_Status_Change = "ResCalc_UI_Status_Change"),
          (e.ResCalc_ZaRF_Status = "ResCalc_ZaRF_Status"),
          (e.ResCalc_AppData_Status = "ResCalc_AppData_Status"),
          (e.ResCalc_ProgramExe_Status = "ResCalc_ProgramExe_Status"),
          (e.ResCalc_ZaloLocal_Status = "ResCalc_ZaloLocal_Status"),
          (e.ResCalc_ConvData_Status = "ResCalc_ConvData_Status"),
          (e.ResConv_FilterSort_Status_Change =
            "ResConv_FilterSort_Status_Change"),
          (e.ResDisk_Status = "ResDisk_Status"),
          (e.ResNoti_Dimiss = "ResNoti_Dimiss"),
          (e.ResNoti_Open_Setttings = "ResNoti_Open_Setttings"),
          (e.ResStats_Tree_Change = "ResStats_Tree_Change"),
          (e.ResDisk_CurrentLevel = "ResDisk_CurrentLevel");
      })(he || (he = {}));
      var ue,
        ge = s("7NAg"),
        pe = s("WQAo"),
        me = s("yzMR");
      function ve() {}
      function fe(...e) {
        0;
      }
      let be =
        Object(a.injectable)()(
          (ue =
            (function (e, t) {
              return a.ModuleContainer.inject(O.ZLoggerFactory)(e, void 0, 0);
            })(
              (ue =
                Reflect.metadata(
                  "design:type",
                  Function
                )(
                  (ue =
                    Reflect.metadata("design:paramtypes", [
                      void 0 === O.ZLoggerFactory ? Object : O.ZLoggerFactory,
                    ])(
                      (ue = class extends re.b {
                        constructor(e) {
                          super(),
                            Object(i.a)(this, "resultCallback", void 0),
                            Object(i.a)(this, "onDataChange", void 0),
                            Object(i.a)(this, "stopped", void 0),
                            Object(i.a)(this, "taskIds", void 0),
                            Object(i.a)(this, "data", void 0),
                            Object(i.a)(this, "didDelete", void 0),
                            Object(i.a)(this, "_totalConvs", 0),
                            Object(i.a)(this, "_taskCalcTs", 0),
                            Object(i.a)(this, "Logger", void 0),
                            Object(i.a)(this, "_hasNewAutoDownload", 0),
                            Object(i.a)(this, "hasNewAutoDownload", () => {
                              this.updateCurrentAutoDownload(
                                this.getCurrentAutoDownload() + 1
                              );
                            }),
                            Object(i.a)(
                              this,
                              "getCurrentAutoDownload",
                              () => this._hasNewAutoDownload
                            ),
                            Object(i.a)(
                              this,
                              "updateCurrentAutoDownload",
                              (e) => {
                                this._hasNewAutoDownload = e;
                              }
                            ),
                            Object(i.a)(
                              this,
                              "startCalculating",
                              async (e = !1) => {
                                fe(), this._resetProgress();
                                try {
                                  const t =
                                      this._hasNewAutoDownload > 0 || e
                                        ? await this.getConvs()
                                        : await this._getOutdatedConvs(),
                                    s = this.getCurrentAutoDownload();
                                  if (0 === t.length && s <= 0) return !1;
                                  this._broadcastEvent(
                                    he.ResCalc_ConvData_Status,
                                    {
                                      status: ge.h.CALCULATING,
                                      type: "convDataStatus",
                                      progress: 0,
                                    }
                                  ),
                                    (this._totalConvs = t.length);
                                  for (let e = 0; e < t.length; e++) {
                                    if (this.stopped) return !0;
                                    await this.createTask(t[e]);
                                  }
                                  return (
                                    this._broadcastEvent(
                                      he.ResCalc_ConvData_Status,
                                      {
                                        status: ge.h.IDLE,
                                        type: "convDataStatus",
                                        progress: 100,
                                      }
                                    ),
                                    this.updateCurrentAutoDownload(
                                      this.getCurrentAutoDownload() - s
                                    ),
                                    (this._taskCalcTs = Date.now()),
                                    !0
                                  );
                                } catch (t) {
                                  return !1;
                                }
                              }
                            ),
                            Object(i.a)(this, "_broadcastEvent", (e, t) => {
                              if (e === he.ResCalc_ConvData_Status)
                                this.dispatchEvent(
                                  new oe(he.ResCalc_ConvData_Status, t)
                                );
                            }),
                            (this.resultCallback = ve),
                            (this.onDataChange = ve),
                            (this.stopped = !0),
                            (this.taskIds = []),
                            (this.data = []),
                            (this.didDelete = new Map()),
                            (this.Logger = e.createZLogger("resmgmt", [
                              "conv-datasource",
                            ]));
                        }
                        status() {
                          return this.stopped ? ge.h.IDLE : ge.h.CALCULATING;
                        }
                        getConvData() {
                          return this.data;
                        }
                        async start(e, t) {
                          (this.stopped = !1),
                            (this.onDataChange = t),
                            (this.resultCallback = (e) => {
                              fe(),
                                this.stopped ||
                                  ((this.data = this.data.filter(
                                    (t) => t.convId !== e.convId
                                  )),
                                  this.data.push(e),
                                  this._broadcastEvent(
                                    he.ResCalc_ConvData_Status,
                                    {
                                      status: ge.h.CALCULATING,
                                      type: "convDataStatus",
                                      progress: this._getPercentage(
                                        this.data.length
                                      ),
                                    }
                                  ),
                                  this.onDataChange(this.data));
                            });
                          let s = await this.getCache();
                          (this.data = s), this.onDataChange(this.data);
                          return await this.startCalculating(e);
                        }
                        cancel() {
                          fe(),
                            (this.resultCallback = ve),
                            (this.stopped = !0),
                            Q.a.cancel(this.taskIds),
                            this._broadcastEvent(he.ResCalc_ConvData_Status, {
                              status: ge.h.IDLE,
                              type: "convDataStatus",
                              progress: 1,
                            });
                        }
                        async onDelete(e, t) {
                          for (let s = 0; s < this.data.length; s++) {
                            const i = this.data[s];
                            let a = i.amount.filesSize,
                              n = i.amount.imagesSize,
                              r = i.amount.videosSize;
                            e.indexOf(i.convId) > -1 &&
                              (t.file && (a = 0),
                              t.photo && (n = 0),
                              t.video && (r = 0),
                              (this.data[s] = Object(p.a)(
                                Object(p.a)({}, i),
                                {},
                                {
                                  amount: {
                                    filesSize: a,
                                    imagesSize: n,
                                    videosSize: r,
                                  },
                                }
                              )),
                              0 === a &&
                                0 === n &&
                                0 === r &&
                                this.didDelete.set(i.convId, !0));
                          }
                          await Q.a.cleanConvResource(e, t),
                            this.onDataChange(this.data);
                        }
                        async preload() {
                          return (
                            fe(),
                            (this.stopped = !1),
                            await this.startCalculating()
                          );
                        }
                        _resetProgress() {
                          this._totalConvs = 0;
                        }
                        _getPercentage(e) {
                          return 0 === this._totalConvs
                            ? 0
                            : Math.round((e / this._totalConvs) * 100);
                        }
                        async getCache() {
                          let e = [],
                            t = await this.getConvs();
                          for (let s = 0; s < t.length; s++) {
                            let i = t[s];
                            if (
                              i &&
                              i.convId &&
                              !this.didDelete.get(i.convId)
                            ) {
                              let t = Q.a.getCache(i.convId);
                              t &&
                                e.push(
                                  Object(p.a)(
                                    Object(p.a)({}, i),
                                    {},
                                    { amount: t }
                                  )
                                );
                            }
                          }
                          return e;
                        }
                        async _getOutdatedConvs() {
                          let e = await this.getConvs();
                          this.Logger.zsymb(
                            3,
                            10114,
                            3e4,
                            "total convs: {}",
                            e.length
                          );
                          const t = a.ModuleContainer.resolve(pe.b);
                          return (
                            this._taskCalcTs > 0 &&
                              (e = e.filter((e) => {
                                const s = t.getLastOpenConv(e.convId);
                                return (
                                  s &&
                                  s >= this._taskCalcTs &&
                                  !this.didDelete.get(e.convId)
                                );
                              })),
                            this.Logger.zsymb(
                              3,
                              10114,
                              30001,
                              "outdated convs: {}",
                              e.length
                            ),
                            e
                          );
                        }
                        createTask(e) {
                          return (
                            fe(e.convId),
                            new Promise((t, s) => {
                              try {
                                const { convId: s } = e;
                                let i = (s) => {
                                    let i = Object(p.a)(
                                      Object(p.a)({}, e),
                                      {},
                                      { amount: s }
                                    );
                                    return this.resultCallback(i), t(i);
                                  },
                                  a = Q.a.calculateConvData(s, i);
                                this.taskIds.push(a);
                              } catch (i) {
                                return t(null);
                              }
                            })
                          );
                        }
                        validateCalculateResult(e) {
                          return !(
                            !e || e.videosSize + e.imagesSize + e.filesSize < 1
                          );
                        }
                        async getConvs() {
                          try {
                            const t =
                                await N.a.ConvInfoDataManager.getAllConv(),
                              s = a.ModuleContainer.resolve(me.h);
                            let i = [];
                            if (!t || !t.length) return i;
                            for (let a = 0; a < t.length; a++) {
                              var e;
                              let n = t[a];
                              if (
                                !n ||
                                !n.userId ||
                                ae.a.isThreadHidden(n.userId)
                              )
                                continue;
                              let r = "",
                                o = "",
                                c = n.userId;
                              const l = parseInt(
                                (null === (e = await s.getPreviewById(c)) ||
                                void 0 === e
                                  ? void 0
                                  : e.messageTime) || "0"
                              );
                              c.startsWith(w.GROUPID_PREFIX)
                                ? ((r = ne.default.getDName(c)),
                                  (o = ne.default.getAvatarGroup(c)))
                                : ((r = D.default.getDName(c)),
                                  (o = D.default.getAvatar(c))),
                                r &&
                                  i.push(
                                    Object(p.a)(
                                      Object(p.a)({}, n),
                                      {},
                                      {
                                        convId: c,
                                        displayName: r,
                                        userId: n.userId,
                                        avatar: o,
                                        lastMsgTime: l,
                                      }
                                    )
                                  );
                            }
                            return i;
                          } catch (t) {
                            return [];
                          }
                        }
                      })
                    ) || ue)
                ) || ue)
            ) || ue)
        ) || ue;
      var _e;
      let Se =
        Object(a.injectable)()(
          (_e =
            (function (e, t) {
              return a.ModuleContainer.inject(O.ZLoggerFactory)(e, void 0, 0);
            })(
              (_e =
                Reflect.metadata(
                  "design:type",
                  Function
                )(
                  (_e =
                    Reflect.metadata("design:paramtypes", [
                      void 0 === O.ZLoggerFactory ? Object : O.ZLoggerFactory,
                    ])(
                      (_e = class extends re.b {
                        constructor(e) {
                          super(),
                            Object(i.a)(this, "_logger", void 0),
                            Object(i.a)(this, "_filterBy", void 0),
                            Object(i.a)(this, "_sortBy", void 0),
                            (this._logger = e.createZLogger("resmgmt", [
                              "ResConvFilterManager",
                            ])),
                            (this._filterBy = ge.f.ALL),
                            (this._sortBy = ge.g.DECREASE_CAPACITY);
                        }
                        getCurrentFilter() {
                          return this._filterBy;
                        }
                        getCurrentSort() {
                          return this._sortBy;
                        }
                        filter(e) {
                          (this._filterBy = e),
                            this._logger.zsymb(2, 10112, 3e4, "filterBy", e),
                            this.dispatchEvent(
                              new ce(he.ResConv_FilterSort_Status_Change, {
                                type: "filterBy",
                                value: e,
                              })
                            );
                        }
                        resetDefault() {
                          (this._filterBy = ge.f.ALL),
                            (this._sortBy = ge.g.DECREASE_CAPACITY),
                            this._logger.zsymb(2, 10112, 30001, "resetDefault"),
                            this.dispatchEvent(
                              new ce(he.ResConv_FilterSort_Status_Change, {
                                type: "filterBy",
                                value: ge.f.ALL,
                                ignoreRender: !0,
                              })
                            ),
                            this.dispatchEvent(
                              new ce(he.ResConv_FilterSort_Status_Change, {
                                type: "sortBy",
                                value: ge.g.DECREASE_CAPACITY,
                                ignoreRender: !0,
                              })
                            );
                        }
                        sort(e) {
                          (this._sortBy = e),
                            this._logger.zsymb(2, 10112, 30002, "sortBy", e),
                            this.dispatchEvent(
                              new ce(he.ResConv_FilterSort_Status_Change, {
                                type: "sortBy",
                                value: e,
                              })
                            );
                        }
                      })
                    ) || _e)
                ) || _e)
            ) || _e)
        ) || _e;
      class ye extends re.b {
        constructor(e, t) {
          super(),
            Object(i.a)(this, "_calculationTracker", {
              recalcRequests: 1,
              lastTs: 0,
            }),
            Object(i.a)(this, "logger", void 0),
            (this.logger = t.createZLogger("resmgmt", [e]));
        }
        checkForceCalculate(e = !1) {
          return e || this._calculationTracker.recalcRequests > 0;
        }
        _recordCalcHistory(e) {
          this._calculationTracker = e
            ? Object(p.a)(Object(p.a)({}, this._calculationTracker), e)
            : { recalcRequests: 0, lastTs: Date.now() };
        }
      }
      var Ce;
      let Ie =
        Object(a.injectable)()(
          (Ce =
            (function (e, t) {
              return a.ModuleContainer.inject(O.ZLoggerFactory)(e, void 0, 0);
            })(
              (Ce =
                (function (e, t) {
                  return a.ModuleContainer.inject(j.a)(e, void 0, 1);
                })(
                  (Ce =
                    (function (e, t) {
                      return a.ModuleContainer.inject(ee.a)(e, void 0, 2);
                    })(
                      (Ce =
                        Reflect.metadata(
                          "design:type",
                          Function
                        )(
                          (Ce =
                            Reflect.metadata("design:paramtypes", [
                              void 0 === O.ZLoggerFactory
                                ? Object
                                : O.ZLoggerFactory,
                              void 0 === j.a ? Object : j.a,
                              void 0 === ee.a ? Object : ee.a,
                            ])(
                              (Ce = class extends ye {
                                constructor(e, t, s) {
                                  super("ResConvDataManager", e),
                                    (this.application = t),
                                    (this.convDataSource = s),
                                    Object(i.a)(
                                      this,
                                      "calculateConvDataSize",
                                      (e) =>
                                        e.reduce((e, t) => {
                                          const s = t.amount || null;
                                          let i = 0;
                                          for (let a in s) i += s[a] || 0;
                                          return e + i;
                                        }, 0)
                                    ),
                                    Object(i.a)(
                                      this,
                                      "onApplicationExit",
                                      () => {
                                        this.cancel(), this._cleanupListeners();
                                      }
                                    ),
                                    Object(i.a)(
                                      this,
                                      "_handleCalculationStatus",
                                      (e) => {
                                        this.dispatchEvent(
                                          new oe(
                                            he.ResCalc_UI_Status_Change,
                                            e.payload
                                          )
                                        );
                                      }
                                    ),
                                    this._listenEvents();
                                }
                                start(e = !1, t) {
                                  return this.checkForceCalculate(e)
                                    ? (this.logger.zsymb(
                                        5,
                                        10113,
                                        3e4,
                                        "calculating: force:{} {}",
                                        this.checkForceCalculate(e),
                                        this._calculationTracker
                                      ),
                                      new Promise((s, i) => {
                                        this.convDataSource
                                          .start(e, t)
                                          .then((e) => {
                                            s(e), this._recordCalcHistory();
                                          })
                                          .catch((e) => {
                                            i(e);
                                          });
                                      }))
                                    : (t &&
                                        t(this.convDataSource.getConvData()),
                                      Promise.resolve(!0));
                                }
                                isOA(e) {
                                  return D.default.isOA(e);
                                }
                                isMyCloud(e) {
                                  return e === I.default.sendToMeId;
                                }
                                isGroup(e) {
                                  return String(e).startsWith(w.GROUPID_PREFIX);
                                }
                                isOtherInOtherGroup(e) {
                                  return this.isMyCloud(e) || this.isOA(e);
                                }
                                getConvs() {
                                  return this.convDataSource
                                    .getConvData()
                                    .filter((e) =>
                                      this.validateCalculateResult(e.amount)
                                    );
                                }
                                async onDelete(e, t) {
                                  return this.convDataSource.onDelete(e, t);
                                }
                                status() {
                                  return this.convDataSource.status();
                                }
                                cancel() {
                                  this.convDataSource.cancel(),
                                    this._recordCalcHistory({
                                      recalcRequests: 1,
                                      lastTs: 0,
                                    });
                                }
                                validateCalculateResult(e) {
                                  return this.convDataSource.validateCalculateResult(
                                    e
                                  );
                                }
                                calculateConvDataSizeByIds(e, t) {
                                  return this.convDataSource
                                    .getConvData()
                                    .filter((t) => e.includes(t.convId))
                                    .reduce(
                                      (e, s) =>
                                        e +
                                        (null != t && t.video
                                          ? s.amount.videosSize
                                          : 0 + (null == t ? void 0 : t.file)
                                          ? s.amount.filesSize
                                          : 0 + (null == t ? void 0 : t.photo)
                                          ? s.amount.imagesSize
                                          : 0),
                                      0
                                    );
                                }
                                _listenEvents() {
                                  this.convDataSource.addEventListener(
                                    he.ResCalc_ConvData_Status,
                                    this._handleCalculationStatus
                                  ),
                                    this.application.addEventListener(
                                      j.b.Exit,
                                      this.onApplicationExit
                                    );
                                }
                                _cleanupListeners() {
                                  this.convDataSource.removeEventListener(
                                    he.ResCalc_ConvData_Status,
                                    this._handleCalculationStatus
                                  ),
                                    this.application.removeEventListener(
                                      j.b.Exit,
                                      this.onApplicationExit
                                    );
                                }
                              })
                            ) || Ce)
                        ) || Ce)
                    ) || Ce)
                ) || Ce)
            ) || Ce)
        ) || Ce;
      a.ModuleContainer.registerSingleton(ee.a, be),
        a.ModuleContainer.registerSingleton(ie, Ie),
        a.ModuleContainer.registerSingleton(se, Se);
      const Oe = Object(a.define)("resmgmt-zarf-datasource");
      var Ee;
      let Te =
        Object(a.injectable)()(
          (Ee =
            (function (e, t) {
              return a.ModuleContainer.inject(O.ZLoggerFactory)(e, void 0, 0);
            })(
              (Ee =
                (function (e, t) {
                  return a.ModuleContainer.inject(j.a)(e, void 0, 1);
                })(
                  (Ee =
                    (function (e, t) {
                      return a.ModuleContainer.inject(Oe)(e, void 0, 2);
                    })(
                      (Ee =
                        Reflect.metadata(
                          "design:type",
                          Function
                        )(
                          (Ee =
                            Reflect.metadata("design:paramtypes", [
                              void 0 === O.ZLoggerFactory
                                ? Object
                                : O.ZLoggerFactory,
                              void 0 === j.a ? Object : j.a,
                              void 0 === Oe ? Object : Oe,
                            ])(
                              (Ee = class extends ye {
                                constructor(e, t, s) {
                                  super("ResZaRFDataManager", e),
                                    (this.application = t),
                                    (this.zarfDataSource = s),
                                    Object(i.a)(
                                      this,
                                      "_handleCalcStatusChange",
                                      (e) => {
                                        this._broadcastEvent(e.type, e.payload);
                                      }
                                    ),
                                    this._listenEvents();
                                }
                                start(e, t) {
                                  return this.checkForceCalculate(e)
                                    ? (this.logger.zsymb(
                                        5,
                                        10118,
                                        3e4,
                                        "calculating: force:{} {}",
                                        this.checkForceCalculate(e),
                                        this._calculationTracker
                                      ),
                                      new Promise((e, s) => {
                                        this.zarfDataSource
                                          .start(t)
                                          .then((t) => {
                                            e(t), this._recordCalcHistory();
                                          })
                                          .catch((e) => {
                                            s(e);
                                          });
                                      }))
                                    : (t && t(this.zarfDataSource.getSize()),
                                      Promise.resolve(!0));
                                }
                                cancel() {
                                  this.zarfDataSource.cancel(),
                                    this._broadcastEvent(
                                      he.ResCalc_ConvData_Status,
                                      {
                                        status: ge.h.IDLE,
                                        type: "convDataStatus",
                                      }
                                    );
                                }
                                _cleanupEvents() {
                                  this.application.removeEventListener(
                                    j.b.Exit,
                                    this._cleanupEvents
                                  ),
                                    this.removeEventListener(
                                      he.ResCalc_ZaRF_Status,
                                      this._handleCalcStatusChange
                                    );
                                }
                                _listenEvents() {
                                  this.application.addEventListener(
                                    j.b.Exit,
                                    this._cleanupEvents
                                  ),
                                    this.zarfDataSource.addEventListener(
                                      he.ResCalc_ZaRF_Status,
                                      this._handleCalcStatusChange
                                    );
                                }
                                _broadcastEvent(e, t) {
                                  if (e === he.ResCalc_ZaRF_Status)
                                    this.dispatchEvent(
                                      new oe(he.ResCalc_UI_Status_Change, t)
                                    );
                                }
                              })
                            ) || Ee)
                        ) || Ee)
                    ) || Ee)
                ) || Ee)
            ) || Ee)
        ) || Ee;
      var Re;
      function Le() {}
      let Me =
        Object(a.injectable)()(
          (Re =
            (function (e, t) {
              return a.ModuleContainer.inject(j.a)(e, void 0, 0);
            })(
              (Re =
                Reflect.metadata(
                  "design:type",
                  Function
                )(
                  (Re =
                    Reflect.metadata("design:paramtypes", [
                      void 0 === j.a ? Object : j.a,
                    ])(
                      (Re = class extends re.b {
                        constructor(e) {
                          super(),
                            (this.application = e),
                            Object(i.a)(this, "resultCallback", void 0),
                            Object(i.a)(this, "onDataChange", void 0),
                            Object(i.a)(this, "_Tasks", []),
                            Object(i.a)(this, "_size", 0),
                            Object(i.a)(this, "_broadcastEvent", (e, t) => {
                              if (e === he.ResCalc_ZaRF_Status)
                                this.dispatchEvent(
                                  new oe(he.ResCalc_ZaRF_Status, t)
                                );
                            }),
                            (this.resultCallback = Le),
                            (this.onDataChange = Le),
                            this._listenEvents();
                        }
                        async start(e) {
                          var t;
                          return (
                            (this.onDataChange = (t) => {
                              (this._size = t), e && e(t);
                            }),
                            (this.resultCallback = (e) => {
                              (this._size = e),
                                this.onDataChange(e),
                                this._broadcastEvent(he.ResCalc_ZaRF_Status, {
                                  status: ge.h.IDLE,
                                  type: "zaRFStatus",
                                });
                            }),
                            this._broadcastEvent(he.ResCalc_ZaRF_Status, {
                              status: ge.h.CALCULATING,
                              type: "zaRFStatus",
                            }),
                            null === (t = this._Tasks) ||
                              void 0 === t ||
                              t.push(
                                Q.a.getZaloReceivedFilesAmt(
                                  this.resultCallback,
                                  this.onDataChange
                                )
                              ),
                            !0
                          );
                        }
                        cancel() {
                          this._cleanupEvents(),
                            (this.resultCallback = Le),
                            (this.onDataChange = Le),
                            this._Tasks.length &&
                              (Q.a.cancel(this._Tasks),
                              this._Tasks.splice(0, this._Tasks.length)),
                            this._broadcastEvent(he.ResCalc_ZaRF_Status, {
                              status: ge.h.IDLE,
                              type: "zaRFStatus",
                            });
                        }
                        getSize() {
                          return this._size;
                        }
                        _cleanupEvents() {
                          this.application.removeEventListener(
                            j.b.Exit,
                            this._cleanupEvents
                          );
                        }
                        _listenEvents() {
                          this.application.addEventListener(
                            j.b.Exit,
                            this._cleanupEvents
                          );
                        }
                      })
                    ) || Re)
                ) || Re)
            ) || Re)
        ) || Re;
      const Fe = Object(a.define)("resmgmt-zarf-datamanager");
      a.ModuleContainer.registerSingleton(Oe, Me),
        a.ModuleContainer.registerSingleton(Fe, Te);
      const we = Object(a.define)("resmgmt-unlisted-datasource");
      var De;
      let je =
        Object(a.injectable)()(
          (De =
            (function (e, t) {
              return a.ModuleContainer.inject(O.ZLoggerFactory)(e, void 0, 0);
            })(
              (De =
                (function (e, t) {
                  return a.ModuleContainer.inject(j.a)(e, void 0, 1);
                })(
                  (De =
                    (function (e, t) {
                      return a.ModuleContainer.inject(we)(e, void 0, 2);
                    })(
                      (De =
                        Reflect.metadata(
                          "design:type",
                          Function
                        )(
                          (De =
                            Reflect.metadata("design:paramtypes", [
                              void 0 === O.ZLoggerFactory
                                ? Object
                                : O.ZLoggerFactory,
                              void 0 === j.a ? Object : j.a,
                              void 0 === we ? Object : we,
                            ])(
                              (De = class extends ye {
                                constructor(e, t, s) {
                                  super("ResUnlistedDataManager", e),
                                    (this.application = t),
                                    (this.resUnlistedDataSource = s),
                                    Object(i.a)(
                                      this,
                                      "_handleCalcStatusChange",
                                      (e) => {
                                        this._broadcastEvent(e.type, e.payload);
                                      }
                                    ),
                                    this._listenEvents();
                                }
                                onDeleteConvs(e) {
                                  return this.resUnlistedDataSource.onDeleteConvs(
                                    e
                                  );
                                }
                                async calculateZaloAppData(e = !1, t, s) {
                                  return (
                                    this.checkForceCalculate(e) &&
                                      this.resUnlistedDataSource.calculateZaloAppData(
                                        e,
                                        t,
                                        s
                                      ),
                                    !0
                                  );
                                }
                                async calculateZaloLocal(e = !1, t, s) {
                                  return (
                                    this.checkForceCalculate(e) &&
                                      this.resUnlistedDataSource.calculateZaloLocal(
                                        e,
                                        t,
                                        s
                                      ),
                                    !0
                                  );
                                }
                                async calculateProgramExe(e = !1, t, s) {
                                  return (
                                    this.checkForceCalculate(e) &&
                                      this.resUnlistedDataSource.calculateProgramExe(
                                        e,
                                        t,
                                        s
                                      ),
                                    !0
                                  );
                                }
                                cancel() {
                                  this.resUnlistedDataSource.cancel(),
                                    this._broadcastEvent(
                                      he.ResCalc_UI_Status_Change,
                                      {
                                        status: ge.h.IDLE,
                                        type: "zaloLocalStatus",
                                      }
                                    ),
                                    this._broadcastEvent(
                                      he.ResCalc_UI_Status_Change,
                                      {
                                        status: ge.h.IDLE,
                                        type: "appDataStatus",
                                      }
                                    ),
                                    this._broadcastEvent(
                                      he.ResCalc_UI_Status_Change,
                                      {
                                        status: ge.h.IDLE,
                                        type: "programExeStatus",
                                      }
                                    );
                                }
                                _cleanupEvents() {
                                  this.application.removeEventListener(
                                    j.b.Exit,
                                    this._cleanupEvents
                                  ),
                                    this.resUnlistedDataSource.removeEventListener(
                                      he.ResCalc_ProgramExe_Status,
                                      this._handleCalcStatusChange
                                    ),
                                    this.resUnlistedDataSource.removeEventListener(
                                      he.ResCalc_ZaloLocal_Status,
                                      this._handleCalcStatusChange
                                    ),
                                    this.resUnlistedDataSource.removeEventListener(
                                      he.ResCalc_AppData_Status,
                                      this._handleCalcStatusChange
                                    );
                                }
                                _listenEvents() {
                                  this.application.addEventListener(
                                    j.b.Exit,
                                    this._cleanupEvents
                                  ),
                                    this.resUnlistedDataSource.addEventListener(
                                      he.ResCalc_ProgramExe_Status,
                                      this._handleCalcStatusChange
                                    ),
                                    this.resUnlistedDataSource.addEventListener(
                                      he.ResCalc_ZaloLocal_Status,
                                      this._handleCalcStatusChange
                                    ),
                                    this.resUnlistedDataSource.addEventListener(
                                      he.ResCalc_AppData_Status,
                                      this._handleCalcStatusChange
                                    );
                                }
                                _broadcastEvent(e, t) {
                                  switch (e) {
                                    case he.ResCalc_ZaloLocal_Status:
                                    case he.ResCalc_ProgramExe_Status:
                                    case he.ResCalc_AppData_Status:
                                      this.dispatchEvent(
                                        new oe(he.ResCalc_UI_Status_Change, t)
                                      );
                                  }
                                }
                              })
                            ) || De)
                        ) || De)
                    ) || De)
                ) || De)
            ) || De)
        ) || De;
      var Ae;
      function Ne() {}
      let Pe =
        Object(a.injectable)()(
          (Ae =
            (function (e, t) {
              return a.ModuleContainer.inject(j.a)(e, void 0, 0);
            })(
              (Ae =
                Reflect.metadata(
                  "design:type",
                  Function
                )(
                  (Ae =
                    Reflect.metadata("design:paramtypes", [
                      void 0 === j.a ? Object : j.a,
                    ])(
                      (Ae = class extends re.b {
                        constructor(e) {
                          super(),
                            (this.application = e),
                            Object(i.a)(this, "_Tasks", []),
                            Object(i.a)(this, "_size", 0),
                            Object(i.a)(this, "_groupStatus", ge.h.IDLE),
                            Object(i.a)(this, "_ProgramExe", {
                              calculated: !1,
                              size: 0,
                              resCb: Ne,
                              changeCb: Ne,
                            }),
                            Object(i.a)(this, "_ZaloAppData", {
                              calculated: !1,
                              size: 0,
                              resCb: Ne,
                              changeCb: Ne,
                            }),
                            Object(i.a)(this, "_ZaloLocal", {
                              calculated: !1,
                              size: 0,
                              resCb: Ne,
                              changeCb: Ne,
                            }),
                            Object(i.a)(this, "_broadcastEvent", (e, t) => {
                              switch (e) {
                                case he.ResCalc_ProgramExe_Status:
                                case he.ResCalc_AppData_Status:
                                case he.ResCalc_ZaloLocal_Status:
                                  this.dispatchEvent(new oe(e, t));
                              }
                            }),
                            this._listenEvents();
                        }
                        cancel() {
                          this._cleanupEvents(),
                            this._Tasks.length &&
                              (Q.a.cancel(this._Tasks),
                              this._Tasks.splice(0, this._Tasks.length)),
                            (this._ZaloAppData.changeCb = Ne),
                            (this._ZaloAppData.resCb = Ne),
                            (this._ProgramExe.changeCb = Ne),
                            (this._ProgramExe.resCb = Ne),
                            (this._ZaloLocal.changeCb = Ne),
                            (this._ZaloLocal.resCb = Ne),
                            this._broadcastEvent(he.ResCalc_ZaRF_Status, {
                              status: ge.h.IDLE,
                              type: "zaRFStatus",
                            });
                        }
                        getSize() {
                          return (
                            this._ZaloAppData.size +
                            this._ProgramExe.size +
                            this._ZaloLocal.size
                          );
                        }
                        getProgramExeSize() {
                          return this._ProgramExe.size;
                        }
                        getZaloAppDataSize() {
                          return this._ZaloAppData.size;
                        }
                        getZaloLocalSize() {
                          return this._ZaloLocal.size;
                        }
                        onDeleteConvs(e) {
                          return (
                            (this._ZaloLocal.size -= e),
                            this._ZaloLocal.changeCb &&
                              this._ZaloLocal.changeCb(this._ZaloLocal.size),
                            Promise.resolve()
                          );
                        }
                        calculateProgramExe(e, t, s) {
                          var i;
                          if (this._ProgramExe.calculated && !e)
                            return void (t
                              ? t(this._ProgramExe.size)
                              : s && s(this._ProgramExe.size));
                          const a = (e) => {
                              (this._ProgramExe.size = e), t && t(e);
                            },
                            n = (e) => {
                              (this._ProgramExe.size = e),
                                this._broadcastEvent(
                                  he.ResCalc_ProgramExe_Status,
                                  {
                                    status: ge.h.IDLE,
                                    type: "programExeStatus",
                                  }
                                ),
                                (this._ProgramExe.calculated = !0),
                                t && t(e);
                            };
                          (this._ProgramExe.resCb = n),
                            (this._ProgramExe.changeCb = a),
                            this._broadcastEvent(he.ResCalc_ProgramExe_Status, {
                              status: ge.h.CALCULATING,
                              type: "programExeStatus",
                            }),
                            null === (i = this._Tasks) ||
                              void 0 === i ||
                              i.push(Q.a.getZaloProgramAmt(n, a));
                        }
                        calculateZaloAppData(e, t, s) {
                          var i;
                          if (this._ZaloAppData.calculated && !e)
                            return void (t
                              ? t(this._ZaloAppData.size)
                              : s && s(this._ZaloAppData.size));
                          const a = (e) => {
                              (this._ZaloAppData.size = e), t && t(e);
                            },
                            n = (e) => {
                              (this._ZaloAppData.size = e),
                                this._broadcastEvent(
                                  he.ResCalc_AppData_Status,
                                  { status: ge.h.IDLE, type: "appDataStatus" }
                                ),
                                (this._ZaloAppData.calculated = !0),
                                t && t(e);
                            };
                          (this._ZaloAppData.resCb = n),
                            (this._ZaloAppData.changeCb = a),
                            this._broadcastEvent(he.ResCalc_AppData_Status, {
                              status: ge.h.CALCULATING,
                              type: "appDataStatus",
                            }),
                            null === (i = this._Tasks) ||
                              void 0 === i ||
                              i.push(Q.a.getZaloDBAmount(n, a));
                        }
                        calculateZaloLocal(e, t, s) {
                          var i;
                          if (this._ZaloLocal.calculated && !e)
                            return void (t
                              ? t(this._ZaloLocal.size)
                              : s && s(this._ZaloLocal.size));
                          const a = (e) => {
                              (this._ZaloLocal.size = e), t && t(e);
                            },
                            n = (e) => {
                              (this._ZaloLocal.size = e),
                                this._broadcastEvent(
                                  he.ResCalc_ZaloLocal_Status,
                                  { status: ge.h.IDLE, type: "zaloLocalStatus" }
                                ),
                                (this._ZaloLocal.calculated = !0),
                                t && t(e);
                            };
                          (this._ZaloLocal.resCb = n),
                            (this._ZaloLocal.changeCb = a),
                            this._broadcastEvent(he.ResCalc_ZaloLocal_Status, {
                              status: ge.h.CALCULATING,
                              type: "zaloLocalStatus",
                            }),
                            null === (i = this._Tasks) ||
                              void 0 === i ||
                              i.push(Q.a.getZaloDataAmount(n, a));
                        }
                        _cleanupEvents() {
                          this.application.removeEventListener(
                            j.b.Exit,
                            this._cleanupEvents
                          );
                        }
                        _listenEvents() {
                          this.application.addEventListener(
                            j.b.Exit,
                            this._cleanupEvents
                          );
                        }
                      })
                    ) || Ae)
                ) || Ae)
            ) || Ae)
        ) || Ae;
      const ke = Object(a.define)("resmgmt-unlisted-datamanager");
      a.ModuleContainer.registerSingleton(we, Pe),
        a.ModuleContainer.registerSingleton(ke, je);
      var Ue,
        Be = s("q1tI"),
        Ge = s.n(Be),
        ze = s("PoHQ"),
        xe = s("B8k8"),
        Ve = s("lCMA"),
        qe = s("v/qp"),
        He = s("h0sc"),
        Ke = s("DOOx"),
        $e = s("XS0u"),
        We = s("kibv"),
        Ze = s("3xbP"),
        Qe = s("7aVi");
      const {
          RICH_SPACE: Ye,
          ALMOST_FULL_1: Je,
          ALMOST_FULL_2: Xe,
          FULL: et,
        } = ge.d,
        tt = 1073741824,
        st = [Je, et],
        it = [Xe, et];
      Object(a.injectable)()(
        (Ue =
          Object(j.h)()(
            (Ue =
              Object(B.b)(Qe.a)(
                (Ue =
                  (function (e, t) {
                    return a.ModuleContainer.inject(j.a)(e, void 0, 0);
                  })(
                    (Ue =
                      Reflect.metadata(
                        "design:type",
                        Function
                      )(
                        (Ue =
                          Reflect.metadata("design:paramtypes", [
                            void 0 === j.a ? Object : j.a,
                          ])(
                            (Ue = class extends re.b {
                              constructor(e) {
                                super(),
                                  (this.application = e),
                                  Object(i.a)(
                                    this,
                                    "_displayingNotiModal",
                                    void 0
                                  ),
                                  Object(i.a)(
                                    this,
                                    "_displayingNotiBanner",
                                    void 0
                                  ),
                                  Object(i.a)(this, "didLog_2230101", void 0),
                                  Object(i.a)(this, "_Logger", void 0),
                                  Object(i.a)(this, "_total", 0),
                                  Object(i.a)(this, "openSetttings", (e) => {
                                    const t = this._getLastNoti();
                                    if (
                                      e === ge.e.POPUP_MODAL ||
                                      e === ge.e.FULL_DISK_BANNER
                                    ) {
                                      let s = Y.a.getTimeNow();
                                      e === ge.e.FULL_DISK_BANNER &&
                                        null != t &&
                                        t.ts &&
                                        (s = t.ts),
                                        $e.default.setFullDiskNoti(
                                          Object(p.a)(
                                            Object(p.a)({}, t),
                                            {},
                                            { dismiss: !0, ts: s }
                                          )
                                        );
                                    }
                                    this._closeNotiType("modal");
                                    He.ModalManagerV2.openModal({
                                      windowId: Ze.c,
                                      name: w.ModalIdentitiesDefine.SETTINGS,
                                      params: {
                                        data: { tab: "ResManagement" },
                                      },
                                      forceCloseAll: !0,
                                    });
                                  }),
                                  Object(i.a)(this, "dismissNoti", (e) => {
                                    if (!e) return this._closeNotiType("all");
                                    this._closeNotiType(
                                      e === ge.e.POPUP_MODAL
                                        ? "modal"
                                        : "banner",
                                      !0
                                    );
                                  }),
                                  Object(i.a)(this, "_osEventHandler", (e) => {
                                    if (e)
                                      switch (e.type) {
                                        case Ke.a.OUT_OF_MEM: {
                                          this._broadcastEvent(
                                            he.ResDisk_Status,
                                            { level: et }
                                          );
                                          const e = this._getLastNoti(),
                                            t = this._getLastBannerNoti();
                                          this._handleDiskStatusModal(et, e),
                                            this._handleDiskStatusBanner(et, t);
                                          break;
                                        }
                                        case Ke.a.OPEN_SUCCESS: {
                                          const e = this._getLastNoti(),
                                            t = this._getLastBannerNoti();
                                          this._handleDiskStatusModal(Ye, e),
                                            this._handleDiskStatusBanner(Ye, t);
                                          break;
                                        }
                                      }
                                  }),
                                  Object(i.a)(
                                    this,
                                    "_handleDiskStatus",
                                    (e) => {
                                      if (!I.default.full_disk_check.enable)
                                        return;
                                      const { total: t, free: s } = e,
                                        i = this._getFullStatus(t, s);
                                      i === Ye ||
                                        (I.default.full_disk_check.enable &&
                                          I.default.full_disk_check
                                            .showWarning) ||
                                        this.didLog_2230101 ||
                                        (this.Logger.zsymb(
                                          3,
                                          10100,
                                          30001,
                                          "Noti modal: noti={} | enable={} | showWarning={}",
                                          i,
                                          I.default.full_disk_check.enable,
                                          I.default.full_disk_check.showWarning
                                        ),
                                        (this.didLog_2230101 = !0),
                                        Z.e.logAction(2230101)),
                                        this._broadcastEvent(
                                          he.ResDisk_CurrentLevel,
                                          { level: i }
                                        );
                                      const a = this._getLastNoti(),
                                        n = this._getLastBannerNoti();
                                      this._handleDiskStatusModal(i, a),
                                        this._handleDiskStatusBanner(i, n),
                                        We.a.start();
                                    }
                                  ),
                                  Object(i.a)(
                                    this,
                                    "_handleDiskStatusModal",
                                    (e, t) => {
                                      var s, i, a, n;
                                      if (
                                        !I.default.full_disk_check.enable ||
                                        (e === Je &&
                                          0 ==
                                            (null ===
                                              (s = I.default.full_disk_check) ||
                                            void 0 === s ||
                                            null === (i = s.level_control) ||
                                            void 0 === i
                                              ? void 0
                                              : i.af1)) ||
                                        (e === et &&
                                          !1 ===
                                            (null ===
                                              (a = I.default.full_disk_check) ||
                                            void 0 === a ||
                                            null === (n = a.level_control) ||
                                            void 0 === n
                                              ? void 0
                                              : n.full_modal))
                                      )
                                        return;
                                      this._displayingNotiModal &&
                                        (!st.includes(e) ||
                                          (t && t.level !== e)) &&
                                        (this.Logger.zsymb(
                                          3,
                                          10100,
                                          30002,
                                          "Noti modal closed lastNoti={} prep for currentNoti={}",
                                          t,
                                          e
                                        ),
                                        this._closeNotiType("modal"));
                                      const r = Y.a.getTimeNow(),
                                        o = this._getLastNoti();
                                      if (!st.includes(e))
                                        return void (
                                          ge.c[e] < ge.c[t.level] &&
                                          ((o.level = e === Ye ? Je : e),
                                          (o.ts = r),
                                          $e.default.setFullDiskNoti(o))
                                        );
                                      const c = Y.a.getTimeNow() - t.ts;
                                      if (
                                        (this.Logger.zsymb(
                                          3,
                                          10100,
                                          30003,
                                          "fdn elapsed: {} | lastNoti={} | newNoti={}",
                                          c,
                                          t.level,
                                          e
                                        ),
                                        !1 === this._displayingNotiModal &&
                                          e === et)
                                      )
                                        return t.dismiss &&
                                          c <=
                                            I.default.full_disk_check
                                              .modal_noti_gap &&
                                          t.level === et
                                          ? void this.Logger.zsymb(
                                              3,
                                              10100,
                                              30004,
                                              "Noti modal full dismissed and less than 7d seconds"
                                            )
                                          : (this.Logger.zsymb(
                                              3,
                                              10100,
                                              30005,
                                              "Noti modal full (always show)"
                                            ),
                                            void this._triggerDiskStatus(
                                              e,
                                              "modal",
                                              !1
                                            ));
                                      if (t && t.level === e) {
                                        if (
                                          this._displayingNotiModal ||
                                          (!this._displayingNotiModal &&
                                            t.dismiss &&
                                            Math.abs(r - t.ts) <
                                              I.default.full_disk_check
                                                .modal_noti_gap)
                                        )
                                          return void (this._displayingNotiModal
                                            ? this.Logger.zsymb(
                                                3,
                                                10100,
                                                30006,
                                                "Noti modal dismissed as type unchanged. already ON"
                                              )
                                            : this.Logger.zsymb(
                                                3,
                                                10100,
                                                30007,
                                                "Noti modal dismissed as type unchanged. applying 7d-rule={}",
                                                !0
                                              ));
                                        this.Logger.zsymb(
                                          3,
                                          10100,
                                          30008,
                                          "Noti modal passed. 7d-rule reset. dismiss reset"
                                        );
                                      } else if (
                                        t &&
                                        t.level &&
                                        e &&
                                        ge.c[e] < ge.c[t.level]
                                      ) {
                                        if (
                                          o.dismiss &&
                                          Math.abs(r - t.ts) <
                                            I.default.full_disk_check
                                              .type_change_noti_gap
                                        )
                                          return (
                                            this.Logger.zsymb(
                                              3,
                                              10100,
                                              30009,
                                              "Noti modal dismissed: downgrading emergency => 1d-rule={}",
                                              !0
                                            ),
                                            (o.level = e === Ye ? Je : e),
                                            (o.ts = r),
                                            void $e.default.setFullDiskNoti(o)
                                          );
                                        this.Logger.zsymb(
                                          3,
                                          10100,
                                          30010,
                                          "Noti modal: downgrading emergency => 1d-rule expired"
                                        );
                                      }
                                      this._triggerDiskStatus(e, "modal", !0);
                                    }
                                  ),
                                  Object(i.a)(
                                    this,
                                    "_handleDiskStatusBanner",
                                    (e, t) => {
                                      var s, i;
                                      if (
                                        !I.default.full_disk_check.enable ||
                                        (e === et &&
                                          !1 ===
                                            (null ===
                                              (s = I.default.full_disk_check) ||
                                            void 0 === s ||
                                            null === (i = s.level_control) ||
                                            void 0 === i
                                              ? void 0
                                              : i.full_banner)) ||
                                        (e === Xe &&
                                          !1 ===
                                            I.default.full_disk_check
                                              .level_control.af2)
                                      )
                                        return;
                                      this._displayingNotiBanner &&
                                        (!it.includes(e) ||
                                          (t && t.level !== e)) &&
                                        (this.Logger.zsymb(
                                          3,
                                          10100,
                                          30011,
                                          "Noti banner closed lastNoti={} prep for currentNoti={}",
                                          t,
                                          e
                                        ),
                                        this._closeNotiType("banner"));
                                      const a = Y.a.getTimeNow(),
                                        n = this._getLastBannerNoti();
                                      if (it.includes(e)) {
                                        if (
                                          !1 === this._displayingNotiBanner &&
                                          e == et
                                        )
                                          return (
                                            this.Logger.zsymb(
                                              3,
                                              10100,
                                              30012,
                                              "Noti banner full (always)"
                                            ),
                                            void this._triggerDiskStatus(
                                              e,
                                              "banner"
                                            )
                                          );
                                        if (t && t.level === e) {
                                          if (
                                            this._displayingNotiBanner ||
                                            (!this._displayingNotiBanner &&
                                              t.dismiss &&
                                              Math.abs(a - t.ts) <
                                                I.default.full_disk_check
                                                  .banner_noti_gap)
                                          )
                                            return void (this
                                              ._displayingNotiBanner
                                              ? this.Logger.zsymb(
                                                  3,
                                                  10100,
                                                  30013,
                                                  "Noti banner dismissed as level unchanged. already ON"
                                                )
                                              : this.Logger.zsymb(
                                                  3,
                                                  10100,
                                                  30014,
                                                  "Noti banner dismissed as level unchanged. applying 1d-rule={}",
                                                  !0
                                                ));
                                          this.Logger.zsymb(
                                            3,
                                            10100,
                                            30015,
                                            "Noti banner passed. 1d-rule reset. dismiss reset"
                                          );
                                        }
                                        if (
                                          t &&
                                          t.level &&
                                          e &&
                                          t.dismiss &&
                                          ge.c[e] < ge.c[t.level]
                                        ) {
                                          if (
                                            n.dismiss &&
                                            Math.abs(a - t.ts) <
                                              I.default.full_disk_check
                                                .type_change_noti_gap
                                          )
                                            return (
                                              this.Logger.zsymb(
                                                3,
                                                10100,
                                                30016,
                                                "Noti banner dismissed as downgrading emergency. applying 1d-rule={}",
                                                !0
                                              ),
                                              (n.ts = a),
                                              (n.level = e),
                                              void $e.default.setFullDiskChatBannerNoti(
                                                n
                                              )
                                            );
                                          if (this._displayingNotiBanner)
                                            return void this.Logger.zsymb(
                                              3,
                                              10100,
                                              30017,
                                              "Noti banner: downgrading emergency. 1d-rule expired but already ON"
                                            );
                                          this.Logger.zsymb(
                                            3,
                                            10100,
                                            30018,
                                            "Noti banner: downgrading emergency. 1d-rule expired. showing soon"
                                          );
                                        }
                                        this._triggerDiskStatus(
                                          e,
                                          "banner",
                                          !0
                                        );
                                      } else
                                        ge.c[e] < ge.c[t.level] &&
                                          ((n.level = e),
                                          (n.ts = a),
                                          $e.default.setFullDiskChatBannerNoti(
                                            n
                                          ));
                                    }
                                  ),
                                  Object(i.a)(this, "_dismissModal", () => {
                                    this._closeNotiType("modal", !0);
                                  }),
                                  (this._displayingNotiModal = !1),
                                  (this._displayingNotiBanner = !1),
                                  (this.didLog_2230101 = !1),
                                  this.Logger.zsymb(
                                    5,
                                    10100,
                                    3e4,
                                    "DiskStatusManager init"
                                  );
                              }
                              get Logger() {
                                return (
                                  this._Logger ||
                                    (this._Logger = a.ModuleContainer.resolve(
                                      O.ZLoggerFactory
                                    ).createZLogger("disk-status", [
                                      "status-manager",
                                    ])),
                                  this._Logger
                                );
                              }
                              onStart(e) {
                                ze.p.listenEvent(ze.c, this._handleDiskStatus),
                                  ze.p.listenEvent(ze.o, this._osEventHandler),
                                  this._listenEvents(),
                                  a.ModuleContainer.resolve(
                                    q
                                  ).startAutoReport();
                              }
                              _getFullStatus(e, t) {
                                let s = Ye;
                                if (
                                  e <
                                  I.default.full_disk_check.threadhold * tt
                                ) {
                                  const i =
                                      I.default.full_disk_check.low_capacity,
                                    a = t / e,
                                    n =
                                      a > 0.001 ? Math.round(100 * a) / 100 : a;
                                  s = this._pickNormalizedStatus(
                                    n,
                                    i.dismiss_high,
                                    i.dismiss_low,
                                    i.dismiss_low_two
                                  );
                                } else {
                                  const e =
                                      I.default.full_disk_check.high_capacity,
                                    i = t / tt,
                                    a =
                                      i > 1
                                        ? (Math.round(10 * i) / 10) * tt
                                        : t;
                                  s = this._pickNormalizedStatus(
                                    a,
                                    e.dismiss_high * tt,
                                    e.dismiss_low * tt,
                                    (e.dismiss_low_two || 1) * tt
                                  );
                                }
                                return s;
                              }
                              _showNotiType(e, t, s) {
                                if ("modal" === e) {
                                  this._displayingNotiModal &&
                                    this._closeNotiType("modal"),
                                    (this._displayingNotiModal = !0);
                                  const i = this._getLastNoti();
                                  $e.default.setFullDiskNoti(
                                    Object(p.a)(
                                      Object(p.a)({}, i),
                                      {},
                                      {
                                        dismiss:
                                          !(s || !i.dismiss) && i.dismiss,
                                        level: t,
                                        ts: Y.a.getTimeNow(),
                                      }
                                    )
                                  );
                                  const a = () => {
                                      t === Je
                                        ? Z.e.logAction(2230707)
                                        : t === et && Z.e.logAction(2230712),
                                        this.openSetttings(ge.e.POPUP_MODAL);
                                    },
                                    n = () => {
                                      t === Je
                                        ? Z.e.logAction(2230704)
                                        : t === et && Z.e.logAction(2230711),
                                        this._dismissModal();
                                    };
                                  let r;
                                  switch (t) {
                                    case Ye:
                                      return void xe.b.closeByKey(
                                        "full-disk-noti-modal"
                                      );
                                    case Je:
                                      Z.e.logAction(2230102),
                                        (r = "STR_RESMGMT_MODAL_ALMOST_FULL");
                                      break;
                                    case Xe:
                                      return void xe.b.closeByKey(
                                        "full-disk-noti-modal"
                                      );
                                    case et:
                                      Z.e.logAction(2230710),
                                        (r = "STR_RESMGMT_MODAL_FULL");
                                  }
                                  this.Logger.zsymb(
                                    5,
                                    10100,
                                    30019,
                                    "Noti {} triggered",
                                    e,
                                    { level: ge.d[t], type: e },
                                    new Error()
                                  );
                                  const o = {
                                    type: w.MINI_NOTIFICATION_TYPE.SUCCESS,
                                    duration: -1,
                                    key: "full-disk-noti-modal",
                                    html: Ge.a.createElement(
                                      "div",
                                      { className: "flx flx-col" },
                                      Ge.a.createElement(
                                        "div",
                                        {
                                          className:
                                            "flx flx-1 disk-waring-content",
                                        },
                                        Ge.a.createElement("div", {
                                          className:
                                            "fa fa-warning-24 disk-waring-icon",
                                        }),
                                        Ge.a.createElement(
                                          "span",
                                          null,
                                          Ge.a.createElement(Ve.a, {
                                            textKey: r,
                                          }),
                                          " "
                                        ),
                                        Ge.a.createElement("span", null)
                                      ),
                                      Ge.a.createElement(
                                        "div",
                                        { className: "flx flx-1 flx-e" },
                                        Ge.a.createElement(
                                          qe.a,
                                          {
                                            type: "neutral",
                                            onClick: n,
                                            size: "medium",
                                            style: { marginRight: "8px" },
                                          },
                                          Ge.a.createElement(Ve.a, {
                                            textKey:
                                              "STR_FILE_INTRO_POP_BTN_SKIP",
                                          })
                                        ),
                                        Ge.a.createElement(
                                          qe.a,
                                          {
                                            type: "primary",
                                            onClick: a,
                                            size: "medium",
                                          },
                                          Ge.a.createElement(Ve.a, {
                                            textKey: "STR_MANAGE",
                                          })
                                        )
                                      )
                                    ),
                                  };
                                  xe.b.show(o);
                                } else if (
                                  "banner" === e &&
                                  (t === Xe || t === et)
                                ) {
                                  this.Logger.zsymb(
                                    5,
                                    10100,
                                    30020,
                                    "Noti {} triggered",
                                    e,
                                    { level: ge.d[t], type: e },
                                    new Error()
                                  ),
                                    this._broadcastEvent(he.ResDisk_Status, {
                                      level: t,
                                    }),
                                    (this._displayingNotiBanner = !0);
                                  const i = this._getLastBannerNoti();
                                  (i.dismiss = !(s || !i.dismiss) && i.dismiss),
                                    (i.level = t),
                                    (i.ts = Y.a.getTimeNow()),
                                    $e.default.setFullDiskChatBannerNoti(i);
                                }
                              }
                              _pickNormalizedStatus(e, t, s, i) {
                                return e > t
                                  ? Ye
                                  : e >= s
                                  ? Je
                                  : e >= i
                                  ? Xe
                                  : et;
                              }
                              _getLastNoti() {
                                return $e.default.getFullDiskNoti() || {};
                              }
                              _closeNotiType(e = "all", t = !1) {
                                if (
                                  (this.Logger.zsymb(
                                    5,
                                    10100,
                                    30021,
                                    "Noti {} closed",
                                    e
                                  ),
                                  ("all" !== e && "modal" !== e) ||
                                    !this._displayingNotiModal)
                                ) {
                                  if (
                                    ("banner" === e || "all" === e) &&
                                    this._displayingNotiBanner
                                  ) {
                                    const e = this._getLastBannerNoti();
                                    this._displayingNotiBanner &&
                                      $e.default.setFullDiskChatBannerNoti(
                                        Object(p.a)(
                                          Object(p.a)({}, e),
                                          {},
                                          {
                                            dismiss: e.dismiss || t,
                                            ts: Y.a.getTimeNow(),
                                          }
                                        )
                                      ),
                                      (this._displayingNotiBanner = !1),
                                      this._broadcastEvent(he.ResNoti_Dimiss);
                                  }
                                } else {
                                  const e = this._getLastNoti(),
                                    s = Y.a.getTimeNow();
                                  this.Logger.zsymb(
                                    5,
                                    10100,
                                    30022,
                                    "fdn close modal at: {}",
                                    new Date(s).toString()
                                  ),
                                    this._displayingNotiModal &&
                                      $e.default.setFullDiskNoti(
                                        Object(p.a)(
                                          Object(p.a)({}, e),
                                          {},
                                          { dismiss: e.dismiss || t, ts: s }
                                        )
                                      ),
                                    xe.b.closeByKey("full-disk-noti-modal"),
                                    (this._displayingNotiModal = !1);
                                }
                                We.a.pause();
                              }
                              _getLastBannerNoti() {
                                return (
                                  $e.default.getFullDiskChatBannerNoti() || {}
                                );
                              }
                              _triggerDiskStatus(e = et, t = "none", s = !1) {
                                if ("none" !== t)
                                  if ("banner" === t)
                                    this._showNotiType("banner", e, s);
                                  else if ("modal" === t)
                                    switch (e) {
                                      case Ye:
                                        this._closeNotiType("modal"),
                                          this._closeNotiType("banner");
                                        break;
                                      case et:
                                        Z.e.logActionInfo(
                                          Z.b.ResourceManagement,
                                          2,
                                          [this._total, 0]
                                        ),
                                          this._showNotiType("modal", e, s),
                                          this._showNotiType("banner", e, s);
                                        break;
                                      case Je:
                                        this._showNotiType("modal", e, s);
                                    }
                              }
                              _broadcastEvent(e, t) {
                                switch (e) {
                                  case he.ResDisk_Status:
                                    this.dispatchEvent(new le(e, t));
                                    break;
                                  case he.ResNoti_Dimiss:
                                    this.dispatchEvent(new de(e));
                                    break;
                                  case he.ResDisk_CurrentLevel:
                                    this.dispatchEvent(new le(e, t));
                                }
                              }
                              _listenEvents() {
                                this.application.addEventListener(
                                  j.b.Exit,
                                  this._cleanupEvents
                                );
                              }
                              _cleanupEvents() {
                                this.application.removeEventListener(
                                  j.b.Exit,
                                  this._cleanupEvents
                                );
                              }
                            })
                          ) || Ue)
                      ) || Ue)
                  ) || Ue)
              ) || Ue)
          ) || Ue)
      );
      var at = s("rBV8"),
        nt = s("93Hy"),
        rt = s.n(nt);
      class ot {
        constructor(e, t, s = !0) {
          (this.useDefaultList = s),
            Object(i.a)(this, "type", void 0),
            Object(i.a)(this, "name", void 0),
            Object(i.a)(this, "key", void 0),
            Object(i.a)(this, "data", void 0),
            (this.name = e),
            (this.key = t),
            (this.data = this.getInitialData());
        }
        init() {}
        getInitialData() {
          return new Map();
        }
        updateItem(e, t, s = !1) {
          const i = rt()(this.data.get(t) || {}, e);
          this.data.set(t, i),
            s ||
              (Object(at.f)(this.name, t),
              this.useDefaultList && Object(at.g)(this.name, ""));
        }
        removeItem(e, t = !1) {
          this.data.delete(e),
            t || (Object(at.c)(this.name, e), Object(at.g)(this.name, ""));
        }
        getItem(e, t) {
          const s = e.key;
          return this.data.get(s);
        }
        getList(e, t) {
          return this.getDefaultList();
        }
        onGetItemFailure(e, t) {}
        onGetListFailure(e, t) {}
        getDefaultItem() {
          return { value: null };
        }
        getDefaultList() {
          return this.useDefaultList ? Array.from(this.data.keys()) : [];
        }
      }
      var ct = s("MGLS");
      const lt = "show_res_mgmt_reddot";
      var dt;
      Object(j.e)()(
        (dt =
          Object(B.b)(ct.b)(
            (dt =
              (function (e, t) {
                return a.ModuleContainer.inject(O.ZLoggerFactory)(e, void 0, 0);
              })(
                (dt =
                  (function (e, t) {
                    return a.ModuleContainer.inject(j.a)(e, void 0, 1);
                  })(
                    (dt =
                      Reflect.metadata(
                        "design:type",
                        Function
                      )(
                        (dt =
                          Reflect.metadata("design:paramtypes", [
                            void 0 === O.ZLoggerFactory
                              ? Object
                              : O.ZLoggerFactory,
                            void 0 === j.a ? Object : j.a,
                          ])(
                            (dt = class extends ot {
                              constructor(e, t) {
                                super(ct.a, "noti"),
                                  (this.loggerFactory = e),
                                  (this.application = t),
                                  Object(i.a)(this, "logger", void 0),
                                  Object(i.a)(this, "dismissReddot", () => {
                                    const e = r.a.getInstance();
                                    this.shouldShowReddot() &&
                                      setTimeout(() => {
                                        this.updateItem((e) => {
                                          e.dismissReddot = !0;
                                        }, "dismissReddot"),
                                          e.setItemForCurrentUser(
                                            lt,
                                            JSON.stringify({ dismiss: !0 })
                                          );
                                      }, 500);
                                  }),
                                  Object(i.a)(this, "shouldShowReddot", () => {
                                    var e;
                                    const t =
                                      null ===
                                        (e = this.data.get(
                                          "showOverviewWarningIcon"
                                        )) || void 0 === e
                                        ? void 0
                                        : e.showOverviewWarningIcon;
                                    if (!(t && t !== ge.d.RICH_SPACE))
                                      return !1;
                                    const s = r.a
                                      .getInstance()
                                      .getItemForCurrentUser(lt);
                                    if (!s) return !0;
                                    try {
                                      const e = JSON.parse(s);
                                      return !e || !e.dismiss;
                                    } catch (i) {
                                      return !0;
                                    }
                                  }),
                                  Object(i.a)(this, "checkShowReddot", () => {
                                    this.Logger.zsymb(5, 10099, 30001, "init");
                                    this.shouldShowReddot()
                                      ? this.updateItem((e) => {
                                          e.dismissReddot = !1;
                                        }, "dismissReddot")
                                      : this.updateItem((e) => {
                                          e.dismissReddot = !0;
                                        }, "dismissReddot");
                                  }),
                                  Object(i.a)(
                                    this,
                                    "_onCurrentLevelChanged",
                                    (e) => {
                                      var t;
                                      (null == e ||
                                      null === (t = e.payload) ||
                                      void 0 === t
                                        ? void 0
                                        : t.level) !== ge.d.RICH_SPACE
                                        ? this.updateItem((t) => {
                                            var s;
                                            t.showOverviewWarningIcon =
                                              null == e ||
                                              null === (s = e.payload) ||
                                              void 0 === s
                                                ? void 0
                                                : s.level;
                                          }, "showOverviewWarningIcon")
                                        : this.updateItem((e) => {
                                            e.showOverviewWarningIcon =
                                              ge.d.RICH_SPACE;
                                          }, "showOverviewWarningIcon"),
                                        this.checkShowReddot();
                                    }
                                  ),
                                  Object(i.a)(this, "_onNotiDismiss", () => {
                                    this.updateItem((e) => {
                                      e.showFullDiskBanner = { show: !1 };
                                    }, "showFullDiskBanner");
                                  }),
                                  Object(i.a)(
                                    this,
                                    "_onDiskStatusChanged",
                                    (e) => {
                                      this.updateItem((t) => {
                                        const s = e.payload,
                                          i =
                                            (null == s ? void 0 : s.level) ===
                                              ge.d.ALMOST_FULL_2 ||
                                            (null == s ? void 0 : s.level) ===
                                              ge.d.FULL;
                                        t.showFullDiskBanner = {
                                          show: i,
                                          level: null == s ? void 0 : s.level,
                                        };
                                      }, "showFullDiskBanner");
                                    }
                                  ),
                                  (this.logger =
                                    this.loggerFactory.createZLogger(
                                      "resmgmt",
                                      [ct.a]
                                    ));
                              }
                              get Logger() {
                                return (
                                  this.logger ||
                                    (this.logger =
                                      this.loggerFactory.createZLogger(
                                        "resmgmt",
                                        [ct.a]
                                      )),
                                  this.logger
                                );
                              }
                              onAuthenticated(e) {
                                this._listenEvents(), this.checkShowReddot();
                              }
                              dismissNoti(e) {
                                this.logger.zsymb(
                                  5,
                                  10099,
                                  3e4,
                                  "Noti {} closed",
                                  e
                                ),
                                  N.a.DiskStatusManager.dismissNoti(e),
                                  We.a.pause();
                              }
                              openSettings(e) {
                                N.a.DiskStatusManager.openSetttings(e);
                              }
                              _cleanupEvents() {
                                "render" === __ZaBUNDLENAME__ &&
                                  (this.application.removeEventListener(
                                    j.b.Exit,
                                    this._cleanupEvents
                                  ),
                                  N.a.DiskStatusManager.removeEventListener(
                                    he.ResDisk_Status,
                                    this._onDiskStatusChanged
                                  ),
                                  N.a.DiskStatusManager.removeEventListener(
                                    he.ResNoti_Dimiss,
                                    this._onNotiDismiss
                                  ));
                              }
                              _listenEvents() {
                                "render" === __ZaBUNDLENAME__ &&
                                  (this.application.addEventListener(
                                    j.b.Exit,
                                    this._cleanupEvents
                                  ),
                                  N.a.DiskStatusManager.addEventListener(
                                    he.ResDisk_Status,
                                    this._onDiskStatusChanged
                                  ),
                                  N.a.DiskStatusManager.addEventListener(
                                    he.ResNoti_Dimiss,
                                    this._onNotiDismiss
                                  ),
                                  N.a.DiskStatusManager.addEventListener(
                                    he.ResDisk_CurrentLevel,
                                    this._onCurrentLevelChanged
                                  ));
                              }
                            })
                          ) || dt)
                      ) || dt)
                  ) || dt)
              ) || dt)
          ) || dt)
      );
      var ht,
        ut = s("FB77"),
        gt = s("OlUt");
      Object(a.injectable)()(
        (ht =
          Object(B.b)(J.b)(
            (ht =
              (function (e, t) {
                return a.ModuleContainer.inject(O.ZLoggerFactory)(e, void 0, 0);
              })(
                (ht =
                  (function (e, t) {
                    return a.ModuleContainer.inject(ie)(e, void 0, 1);
                  })(
                    (ht =
                      (function (e, t) {
                        return a.ModuleContainer.inject(Fe)(e, void 0, 2);
                      })(
                        (ht =
                          (function (e, t) {
                            return a.ModuleContainer.inject(ke)(e, void 0, 3);
                          })(
                            (ht =
                              (function (e, t) {
                                return a.ModuleContainer.inject(se)(
                                  e,
                                  void 0,
                                  4
                                );
                              })(
                                (ht =
                                  Reflect.metadata(
                                    "design:type",
                                    Function
                                  )(
                                    (ht =
                                      Reflect.metadata("design:paramtypes", [
                                        void 0 === O.ZLoggerFactory
                                          ? Object
                                          : O.ZLoggerFactory,
                                        void 0 === ie ? Object : ie,
                                        void 0 === Fe ? Object : Fe,
                                        void 0 === ke ? Object : ke,
                                        void 0 === se ? Object : se,
                                      ])(
                                        (ht = class extends ot {
                                          constructor(e, t, s, a, n) {
                                            super(J.a, "view"),
                                              (this.loggerFactory = e),
                                              (this._resConvDataManager = t),
                                              (this._resZaRFDataManager = s),
                                              (this._resUnlistedDataManager =
                                                a),
                                              (this._resConvFilterManager = n),
                                              Object(i.a)(
                                                this,
                                                "logger",
                                                void 0
                                              ),
                                              Object(i.a)(
                                                this,
                                                "_listeningEvents",
                                                !1
                                              ),
                                              Object(i.a)(
                                                this,
                                                "_isMounted",
                                                !1
                                              ),
                                              Object(i.a)(this, "_aborted", !1),
                                              Object(i.a)(
                                                this,
                                                "_intervalOn",
                                                !1
                                              ),
                                              Object(i.a)(
                                                this,
                                                "_calculating",
                                                !1
                                              ),
                                              Object(i.a)(
                                                this,
                                                "_calcHistory",
                                                []
                                              ),
                                              Object(i.a)(
                                                this,
                                                "_calculateInterval",
                                                18e5
                                              ),
                                              Object(i.a)(
                                                this,
                                                "_onCalcDone",
                                                []
                                              ),
                                              Object(i.a)(
                                                this,
                                                "updateZaRFSize",
                                                (e) => {
                                                  this.updateItem(
                                                    (t) => {
                                                      t.zaRFSize = e;
                                                    },
                                                    "zaRFSize",
                                                    !this._isMounted
                                                  );
                                                }
                                              ),
                                              Object(i.a)(
                                                this,
                                                "getZaloUsage",
                                                () =>
                                                  this.deferredPromise(() => {
                                                    var e, t, s, i;
                                                    return (
                                                      ((null ===
                                                        (e =
                                                          this.data.get(
                                                            "zaRFSize"
                                                          )) || void 0 === e
                                                        ? void 0
                                                        : e.zaRFSize) || 0) +
                                                      ((null ===
                                                        (t =
                                                          this.data.get(
                                                            "zaloLocalSize"
                                                          )) || void 0 === t
                                                        ? void 0
                                                        : t.zaloLocalSize) ||
                                                        0) +
                                                      ((null ===
                                                        (s =
                                                          this.data.get(
                                                            "appDataSize"
                                                          )) || void 0 === s
                                                        ? void 0
                                                        : s.appDataSize) || 0) +
                                                      ((null ===
                                                        (i =
                                                          this.data.get(
                                                            "programExeSize"
                                                          )) || void 0 === i
                                                        ? void 0
                                                        : i.programExeSize) ||
                                                        0)
                                                    );
                                                  })
                                              ),
                                              Object(i.a)(
                                                this,
                                                "deferredPromise",
                                                (e) => {
                                                  const t = {};
                                                  t.promise = new Promise(
                                                    (s, i) => {
                                                      (t.resolve = () => {
                                                        s(e());
                                                      }),
                                                        (t.reject = i);
                                                    }
                                                  );
                                                  const s =
                                                      this._calcHistory
                                                        .length &&
                                                      this._calcHistory[
                                                        this._calcHistory
                                                          .length - 1
                                                      ],
                                                    i = setTimeout(() => {
                                                      this._calculating ||
                                                        this.calculate(
                                                          ge.a.ROUTINE
                                                        );
                                                    }, 2e4);
                                                  return (
                                                    !s ||
                                                    (s.status !==
                                                      ge.b.COMPLETED &&
                                                      (null == s
                                                        ? void 0
                                                        : s.status) !==
                                                        ge.b.ABORTED)
                                                      ? this._onCalcDone.push(
                                                          t.resolve
                                                        )
                                                      : (t.resolve(),
                                                        clearTimeout(i)),
                                                    t.promise
                                                  );
                                                }
                                              ),
                                              Object(i.a)(
                                                this,
                                                "getConvData",
                                                () =>
                                                  this.deferredPromise(() => {
                                                    var e;
                                                    return (
                                                      (null ===
                                                        (e =
                                                          this.data.get(
                                                            "convData"
                                                          )) || void 0 === e
                                                        ? void 0
                                                        : e.convData) || 0
                                                    );
                                                  })
                                              ),
                                              Object(i.a)(
                                                this,
                                                "updateConvs",
                                                (e) => {
                                                  const t = e.filter((e) =>
                                                    this._resConvDataManager.validateCalculateResult(
                                                      null == e
                                                        ? void 0
                                                        : e.amount
                                                    )
                                                  );
                                                  this.updateItem((e) => {
                                                    e.convs = t;
                                                  }, "convs"),
                                                    this._filterRelative(
                                                      this._resConvFilterManager.getCurrentFilter()
                                                    ),
                                                    this._sortRelative(
                                                      this._resConvFilterManager.getCurrentSort()
                                                    ),
                                                    this.updateItem(
                                                      (e) => {
                                                        e.convDataSize =
                                                          this._resConvDataManager.calculateConvDataSize(
                                                            t
                                                          );
                                                      },
                                                      "convDataSize",
                                                      !this._isMounted
                                                    );
                                                }
                                              ),
                                              Object(i.a)(
                                                this,
                                                "_updateZaloLocalSize",
                                                (e) => {
                                                  this.updateItem(
                                                    (t) => {
                                                      t.zaloLocalSize = e;
                                                    },
                                                    "zaloLocalSize",
                                                    !this._isMounted
                                                  );
                                                }
                                              ),
                                              Object(i.a)(
                                                this,
                                                "_updateAppDataSize",
                                                (e) => {
                                                  this.updateItem(
                                                    (t) => {
                                                      t.appDataSize = e;
                                                    },
                                                    "appDataSize",
                                                    !this._isMounted
                                                  );
                                                }
                                              ),
                                              Object(i.a)(
                                                this,
                                                "_updateProgramExeSize",
                                                (e) => {
                                                  this.updateItem(
                                                    (t) => {
                                                      t.programExeSize = e;
                                                    },
                                                    "programExeSize",
                                                    !this._isMounted
                                                  );
                                                }
                                              ),
                                              Object(i.a)(
                                                this,
                                                "_handleSortFilterEventChange",
                                                (e) => {
                                                  switch (e.type) {
                                                    case he.ResConv_FilterSort_Status_Change: {
                                                      const t = e.payload;
                                                      this.updateItem(
                                                        (e) => {
                                                          e[t.type] = t.value;
                                                        },
                                                        t.type,
                                                        t.ignoreRender || !1
                                                      ),
                                                        "filterBy" === t.type &&
                                                          this._filterRelative(
                                                            t.value
                                                          ),
                                                        this._sortRelative(
                                                          t.value
                                                        );
                                                      break;
                                                    }
                                                  }
                                                }
                                              ),
                                              Object(i.a)(
                                                this,
                                                "_handleCalculationStatus",
                                                (e) => {
                                                  const t = e.payload;
                                                  this.updateItem(
                                                    (e) => {
                                                      var s;
                                                      e[t.type] = {
                                                        status: t.status,
                                                        progress: t.progress,
                                                        hasCache:
                                                          !0 ===
                                                            (null ===
                                                              (s = e[t.type]) ||
                                                            void 0 === s
                                                              ? void 0
                                                              : s.hasCache) ||
                                                          t.status ===
                                                            ge.h.IDLE,
                                                      };
                                                    },
                                                    t.type,
                                                    !this._isMounted
                                                  );
                                                }
                                              ),
                                              (this.logger =
                                                this.loggerFactory.createZLogger(
                                                  "resmgmt",
                                                  ["Controller"]
                                                )),
                                              this.init();
                                          }
                                          setSelectedConvs(e) {
                                            this.updateItem((t) => {
                                              t.selectedConvs = e;
                                            }, "selectedConvs");
                                          }
                                          hasCache() {
                                            return (
                                              this._calcHistory.length > 0 &&
                                              this._calcHistory[
                                                this._calcHistory.length - 1
                                              ].status !== ge.b.CALCULATING
                                            );
                                          }
                                          startCalcInterval() {
                                            this._intervalOn = !0;
                                          }
                                          resetCalcInterval() {
                                            this._intervalOn = !1;
                                          }
                                          setCalculateInterval(e) {
                                            (this._calculateInterval = e),
                                              this.updateItem((t) => {
                                                t.calculateInterval = e;
                                              }, "calculateInterval");
                                          }
                                          getLastCalcTs() {
                                            return this._calcHistory.length > 0
                                              ? this._calcHistory[
                                                  this._calcHistory.length - 1
                                                ].end
                                              : 0;
                                          }
                                          getCalcHistory() {
                                            return this._calcHistory.length > 0
                                              ? this._calcHistory
                                              : null;
                                          }
                                          getCalculateInterval() {
                                            return this._calculateInterval;
                                          }
                                          async calculate(e, t = !1) {
                                            (this._isMounted = !0),
                                              this._listeningEvents ||
                                                this._listenEvents(),
                                              (this._calculating = !0);
                                            try {
                                              await this._startAllCalculators(
                                                e,
                                                t
                                              );
                                            } catch (s) {
                                              this.logger.zsymb(
                                                21,
                                                10098,
                                                3e4,
                                                "Error estimating resources",
                                                s
                                              );
                                            }
                                            if (
                                              (this._onCalcDone.forEach((e) =>
                                                (function (e, t) {
                                                  try {
                                                    e();
                                                  } catch (s) {
                                                    "function" == typeof t &&
                                                      t(s);
                                                  }
                                                })(e)
                                              ),
                                              this._onCalcDone.splice(
                                                0,
                                                this._onCalcDone.length
                                              ),
                                              (this._calculating = !1),
                                              e === ge.a.RESMGMT_TAB_MOUNTED ||
                                                e === ge.a.ROUTINE)
                                            ) {
                                              const t =
                                                  a.ModuleContainer.resolve(q),
                                                s =
                                                  e === ge.a.RESMGMT_TAB_MOUNTED
                                                    ? t.getScanType().UserManual
                                                    : t.getScanType().Routine,
                                                i = Q.a.analyzeMainDisk();
                                              i &&
                                                t.diskStatusReport({
                                                  scan_event: s,
                                                  ts: t.getTimeNow(),
                                                  total: i.total,
                                                  free: i.free,
                                                });
                                              const n =
                                                await this.getZaloUsage();
                                              t.zaloUsageReport({
                                                scan_event: s,
                                                ts: t.getTimeNow(),
                                                used: n,
                                              }),
                                                t.cacheReport({
                                                  scan_event: s,
                                                });
                                            }
                                          }
                                          init() {
                                            this.updateItem(
                                              (e) => {
                                                (e.view = ut.a.OVERVIEW),
                                                  (e.theme = gt.a.default);
                                              },
                                              "view",
                                              !0
                                            ),
                                              this.updateItem(
                                                (e) => {
                                                  e.sortBy =
                                                    ge.g.DECREASE_CAPACITY;
                                                },
                                                "sortBy",
                                                !0
                                              ),
                                              this.updateItem(
                                                (e) => {
                                                  e.filterBy = ge.f.ALL;
                                                },
                                                "filterBy",
                                                !0
                                              ),
                                              this.updateItem(
                                                (e) => {
                                                  e.currentDisk = "C:";
                                                },
                                                "currentDisk",
                                                !0
                                              ),
                                              this.updateItem(
                                                (e) => {
                                                  e.calculateInterval =
                                                    this._calculateInterval;
                                                },
                                                "calculateInterval",
                                                !0
                                              ),
                                              this.updateItem(
                                                (e) => {
                                                  e.selectedConvs = {};
                                                },
                                                "selectedConvs",
                                                !0
                                              ),
                                              this._listenEvents();
                                          }
                                          resetStates() {
                                            this.updateItem(
                                              (e) => {
                                                e.view = ut.a.OVERVIEW;
                                              },
                                              "view",
                                              !0
                                            );
                                          }
                                          resetAll() {
                                            this.resetCalcInterval();
                                            a.ModuleContainer.resolve(
                                              se
                                            ).resetDefault(),
                                              this.updateItem((e) => {
                                                e.selectedConvs = {};
                                              }, "selectedConvs");
                                          }
                                          updateView(e) {
                                            this.updateItem((t) => {
                                              t.view = e;
                                            }, "view");
                                          }
                                          abort() {
                                            (this._isMounted = !1),
                                              this._cancelAllCalculations(),
                                              this._cleanupListeners();
                                          }
                                          sort(e) {
                                            switch (e) {
                                              case ge.g.DECREASE_CAPACITY:
                                                Z.e.logAction(2230601);
                                                break;
                                              case ge.g.INCREASE_CAPACITY:
                                                Z.e.logAction(2230603);
                                                break;
                                              case ge.g.INCREASE_LAST_UPDATE:
                                                Z.e.logAction(2230605);
                                                break;
                                              case ge.g.DECREASE_LAST_UPDATE:
                                                Z.e.logAction(2230607);
                                            }
                                            this._resConvFilterManager.getCurrentSort() !==
                                              e &&
                                              this._resConvFilterManager.sort(
                                                e
                                              );
                                          }
                                          filter(e) {
                                            switch (e) {
                                              case ge.f.ALL:
                                                Z.e.logAction(2230801);
                                                break;
                                              case ge.f.FILTER_GROUP_CONVS:
                                                Z.e.logAction(2230802);
                                                break;
                                              case ge.f
                                                .FILTER_SINGLE_CHAT_CONVS:
                                                Z.e.logAction(2230803);
                                                break;
                                              case ge.f.FILTER_OTHER_CONVS:
                                                Z.e.logAction(2230804);
                                            }
                                            this._resConvFilterManager.getCurrentFilter() !==
                                              e &&
                                              this._resConvFilterManager.filter(
                                                e
                                              );
                                          }
                                          isCurrentSort(e) {
                                            var t;
                                            return (
                                              (null ===
                                                (t = this.data.get("sortBy")) ||
                                              void 0 === t
                                                ? void 0
                                                : t.sortBy) === e
                                            );
                                          }
                                          isCurrentFiler(e) {
                                            var t;
                                            return (
                                              (null ===
                                                (t =
                                                  this.data.get("filterBy")) ||
                                              void 0 === t
                                                ? void 0
                                                : t.filterBy) === e
                                            );
                                          }
                                          changeTheme(e) {
                                            return Promise.resolve();
                                          }
                                          openZaRF() {
                                            Object(Q.d)();
                                          }
                                          async onDelete(
                                            e,
                                            t = {
                                              photo: !0,
                                              video: !0,
                                              file: !0,
                                            },
                                            s
                                          ) {
                                            switch (
                                              this._resConvFilterManager.getCurrentFilter()
                                            ) {
                                              case ge.f.FILTER_GROUP_CONVS:
                                                Z.e.logAction(2230805);
                                                break;
                                              case ge.f.FILTER_GROUP_CONVS:
                                                Z.e.logAction(2230806);
                                                break;
                                              case ge.f
                                                .FILTER_SINGLE_CHAT_CONVS:
                                                Z.e.logAction(2230807);
                                                break;
                                              case ge.f.FILTER_OTHER_CONVS:
                                                Z.e.logAction(2230808);
                                            }
                                            let i = 0;
                                            s ||
                                              (i =
                                                this._resConvDataManager.calculateConvDataSizeByIds(
                                                  e,
                                                  t
                                                ));
                                            const n =
                                              a.ModuleContainer.resolve(q);
                                            await n.logAction999({
                                              type: "DeleteConv",
                                              deleted_count: e.length,
                                              deleted_size: i,
                                              target: Object(p.a)({}, t),
                                            }),
                                              await this._resUnlistedDataManager.onDeleteConvs(
                                                i
                                              ),
                                              await this._resConvDataManager.onDelete(
                                                e,
                                                t
                                              );
                                          }
                                          abortTasks() {
                                            (this._aborted = !0),
                                              this.logger.zsymb(
                                                0,
                                                10098,
                                                30001,
                                                "abort calc tasks"
                                              ),
                                              N.a.ResCacheManager.revokeCache();
                                          }
                                          _startAllCalculators(e, t = !1) {
                                            const s =
                                              this._calcHistory.length &&
                                              this._calcHistory[
                                                this._calcHistory.length - 1
                                              ];
                                            return Object(Q.c)()
                                              ? !this._canRequestCalculateRes(
                                                  e
                                                ) ||
                                                (s &&
                                                  s.status === ge.b.CALCULATING)
                                                ? (this.logger.zsymb(
                                                    3,
                                                    10098,
                                                    30003,
                                                    "recalculateResource is called too frequently. now:{} last:{}",
                                                    Date.now(),
                                                    this.getLastCalcTs()
                                                  ),
                                                  Promise.resolve(!0))
                                                : this._systemUsageInfo()
                                                    .then((e) =>
                                                      e.cpu >=
                                                        I.default
                                                          .full_disk_check
                                                          .high_cpu ||
                                                      I.default.full_disk_check
                                                        .high_mem
                                                        ? (this.logger.zsymb(
                                                            3,
                                                            10098,
                                                            30004,
                                                            "CPU or MEM usage is too high. No calculation will be postponed"
                                                          ),
                                                          Promise.resolve())
                                                        : Promise.resolve()
                                                    )
                                                    .then(() => {
                                                      let e = !0;
                                                      this._aborted = !1;
                                                      const t = {
                                                        start: Date.now(),
                                                        end: -1,
                                                        status:
                                                          ge.b.CALCULATING,
                                                      };
                                                      this._calcHistory.push(t);
                                                      const s = [
                                                        this._resConvDataManager.start(
                                                          e,
                                                          this.updateConvs
                                                        ),
                                                        this._resZaRFDataManager.start(
                                                          e,
                                                          this.updateZaRFSize
                                                        ),
                                                        this._resUnlistedDataManager.calculateZaloAppData(
                                                          e,
                                                          this
                                                            ._updateAppDataSize
                                                        ),
                                                        this._resUnlistedDataManager.calculateProgramExe(
                                                          e,
                                                          this
                                                            ._updateProgramExeSize
                                                        ),
                                                      ];
                                                      return Promise.all(s)
                                                        .then(() =>
                                                          this._resUnlistedDataManager.calculateZaloLocal(
                                                            e,
                                                            this
                                                              ._updateZaloLocalSize
                                                          )
                                                        )
                                                        .finally(() => {
                                                          this._aborted
                                                            ? (N.a.ResCacheManager.revokeCache(),
                                                              (t.status =
                                                                ge.b.ABORTED))
                                                            : ((t.status =
                                                                ge.b.COMPLETED),
                                                              N.a.ResCacheManager.signCache()),
                                                            (t.end =
                                                              Date.now());
                                                        });
                                                    })
                                              : (this.logger.zsymb(
                                                  3,
                                                  10098,
                                                  30002,
                                                  "Full disk check is disabled. No calculation will be performed"
                                                ),
                                                Promise.resolve(!0));
                                          }
                                          async _sortRelative(e) {
                                            var t;
                                            let s =
                                              (null ===
                                                (t = this.data.get("convs")) ||
                                              void 0 === t
                                                ? void 0
                                                : t.convs) ||
                                              this._resConvDataManager.getConvs();
                                            switch (e) {
                                              case ge.g.DECREASE_CAPACITY:
                                              case ge.g.INCREASE_CAPACITY:
                                                s = s.slice().sort((t, s) => {
                                                  let i =
                                                    s.amount.videosSize +
                                                    s.amount.imagesSize +
                                                    s.amount.filesSize -
                                                    t.amount.videosSize -
                                                    t.amount.imagesSize -
                                                    t.amount.filesSize;
                                                  return e ===
                                                    ge.g.DECREASE_CAPACITY
                                                    ? i
                                                    : -i;
                                                });
                                                break;
                                              case ge.g.INCREASE_LAST_UPDATE:
                                              case ge.g.DECREASE_LAST_UPDATE:
                                                s = s.slice().sort((t, s) => {
                                                  const i =
                                                    s.lastMsgTime -
                                                    t.lastMsgTime;
                                                  return e ===
                                                    ge.g.DECREASE_LAST_UPDATE
                                                    ? i
                                                    : -i;
                                                });
                                            }
                                            this.updateItem((e) => {
                                              e.convs = s;
                                            }, "convs");
                                          }
                                          _filterRelative(e) {
                                            let t =
                                              this._resConvDataManager.getConvs() ||
                                              [];
                                            switch (e) {
                                              case ge.f.ALL:
                                                t =
                                                  this._resConvDataManager.getConvs();
                                                break;
                                              case ge.f
                                                .FILTER_SINGLE_CHAT_CONVS:
                                                t = t.filter(
                                                  (e) =>
                                                    (!this._resConvDataManager.isGroup(
                                                      e.userId
                                                    ) &&
                                                      !this._resConvDataManager.isOA(
                                                        e.userId
                                                      )) ||
                                                    this._resConvDataManager.isMyCloud(
                                                      e.userId
                                                    )
                                                );
                                                break;
                                              case ge.f.FILTER_GROUP_CONVS:
                                                t = t.filter(
                                                  (e) =>
                                                    this._resConvDataManager.isGroup(
                                                      e.userId
                                                    ) &&
                                                    !this._resConvDataManager.isOA(
                                                      e.userId
                                                    ) &&
                                                    !this._resConvDataManager.isMyCloud(
                                                      e.userId
                                                    )
                                                );
                                                break;
                                              case ge.f.FILTER_OTHER_CONVS:
                                                t = t.filter(
                                                  (e) =>
                                                    this._resConvDataManager.isOA(
                                                      e.userId
                                                    ) &&
                                                    !this._resConvDataManager.isMyCloud(
                                                      e.userId
                                                    )
                                                );
                                            }
                                            this.updateItem(
                                              (e) => {
                                                e.convs = t;
                                              },
                                              "convs",
                                              !0
                                            ),
                                              this._sortRelative(
                                                this._resConvFilterManager.getCurrentSort()
                                              );
                                          }
                                          _cancelAllCalculations() {
                                            this._resConvDataManager.cancel(),
                                              this._resZaRFDataManager.cancel(),
                                              this._resUnlistedDataManager.cancel();
                                          }
                                          _listenEvents() {
                                            (this._listeningEvents = !0),
                                              this._resConvDataManager.addEventListener(
                                                he.ResCalc_UI_Status_Change,
                                                this._handleCalculationStatus
                                              ),
                                              this._resZaRFDataManager.addEventListener(
                                                he.ResCalc_UI_Status_Change,
                                                this._handleCalculationStatus
                                              ),
                                              this._resUnlistedDataManager.addEventListener(
                                                he.ResCalc_UI_Status_Change,
                                                this._handleCalculationStatus
                                              ),
                                              this._resConvFilterManager.addEventListener(
                                                he.ResConv_FilterSort_Status_Change,
                                                this
                                                  ._handleSortFilterEventChange
                                              );
                                          }
                                          _cleanupListeners() {
                                            (this._listeningEvents = !1),
                                              this._resConvDataManager.removeEventListener(
                                                he.ResCalc_UI_Status_Change,
                                                this._handleCalculationStatus
                                              ),
                                              this._resZaRFDataManager.removeEventListener(
                                                he.ResCalc_UI_Status_Change,
                                                this._handleCalculationStatus
                                              ),
                                              this._resUnlistedDataManager.removeEventListener(
                                                he.ResCalc_UI_Status_Change,
                                                this._handleCalculationStatus
                                              ),
                                              this._resConvFilterManager.removeEventListener(
                                                he.ResConv_FilterSort_Status_Change,
                                                this
                                                  ._handleSortFilterEventChange
                                              );
                                          }
                                          _canRequestCalculateRes(e) {
                                            if ([ge.a.ACTIVE_EVENT].includes(e))
                                              return !1;
                                            if (!this._intervalOn)
                                              return (
                                                (this._intervalOn = !0),
                                                this._intervalOn
                                              );
                                            const t = Date.now(),
                                              s =
                                                t - this.getLastCalcTs() >=
                                                this._calculateInterval;
                                            return (
                                              s &&
                                                N.a.ResCacheManager.revokeCache(),
                                              this.logger.zsymb(
                                                5,
                                                10098,
                                                30005,
                                                "Checking expire: ",
                                                s,
                                                t - this.getLastCalcTs(),
                                                this._calculateInterval,
                                                this._calcHistory
                                              ),
                                              s
                                            );
                                          }
                                          _getCPU() {
                                            var e = s("jle/").cpus(),
                                              t = 0,
                                              i = 0,
                                              a = 0,
                                              n = 0,
                                              r = 0;
                                            for (var o in e)
                                              e.hasOwnProperty(o) &&
                                                ((t += e[o].times.user),
                                                (i += e[o].times.nice),
                                                (a += e[o].times.sys),
                                                (r += e[o].times.irq),
                                                (n += e[o].times.idle));
                                            return {
                                              idle: n,
                                              total: t + i + a + n + r,
                                            };
                                          }
                                          getCPUUsage(e, t = !1) {
                                            const s = this._getCPU(),
                                              i = s.idle,
                                              a = s.total;
                                            setTimeout(() => {
                                              const s = this._getCPU(),
                                                n = s.idle,
                                                r = s.total,
                                                o = (n - i) / (r - a);
                                              e(!0 === t ? o : 1 - o);
                                            }, 1e3);
                                          }
                                          async _systemUsageInfo() {
                                            return new Promise((e, t) => {
                                              const i = s("jle/"),
                                                a = i.totalmem(),
                                                n = i.freemem(),
                                                r = a - n;
                                              this.getCPUUsage((t) => {
                                                e({ cpu: t, memory: r / a });
                                              });
                                            });
                                          }
                                        })
                                      ) || ht)
                                  ) || ht)
                              ) || ht)
                          ) || ht)
                      ) || ht)
                  ) || ht)
              ) || ht)
          ) || ht)
      );
      s("KszJ"), s("Hbak"), s("RGaR");
      var pt,
        mt = s("vQ8b"),
        vt = s("ZBGy"),
        ft = s("smi1"),
        bt = s("gEkt");
      let _t =
        Object(a.injectable)()(
          (pt =
            (function (e, t) {
              return a.ModuleContainer.inject(me.i)(e, void 0, 0);
            })(
              (pt =
                (function (e, t) {
                  return a.ModuleContainer.inject(me.h)(e, void 0, 1);
                })(
                  (pt =
                    Reflect.metadata(
                      "design:type",
                      Function
                    )(
                      (pt =
                        Reflect.metadata("design:paramtypes", [
                          void 0 === me.i ? Object : me.i,
                          void 0 === me.h ? Object : me.h,
                        ])(
                          (pt = class {
                            constructor(e, t) {
                              (this.unreadDataManager = e),
                                (this.previewManager = t),
                                Object(i.a)(this, "menuRef", void 0),
                                (this.menuRef = {});
                            }
                            deleteConversation(e, t = !0) {
                              e != w.CONV_FILTER.STRANGER &&
                                (b.default.logCoreError(
                                  `[user call del conv] ${e}`
                                ),
                                ft.a
                                  .deleteConversation(e, t)
                                  .then((e) => {
                                    e &&
                                      e.delConversationId &&
                                      Object(vt.f)({
                                        type: y.ConversationListActions
                                          .TAG_CONV,
                                        payload: {
                                          data: [
                                            {
                                              userId: e.delConversationId,
                                              label: null,
                                            },
                                          ],
                                        },
                                      });
                                  })
                                  .catch((e) => {
                                    b.default.logCoreError(
                                      "Delete conversation fail - " +
                                        JSON.stringify(e)
                                    );
                                  }));
                            }
                            bindUIMenu(e, t) {
                              this.menuRef[e] = t;
                            }
                            cleanUpUIMenu(e) {
                              this.menuRef[e] = null;
                            }
                            showMenu(e, t, s) {
                              if (this.menuRef[e] && e === bt.b)
                                this.showConvActionMenu(t, s);
                            }
                            hideMenu(e) {
                              this.menuRef[e] && this.menuRef[e].close();
                            }
                            showConvActionMenu(e, t) {
                              if (t && t.friendItem) return;
                              const s = Object(p.a)({}, t),
                                i = s.userId;
                              if (s && !b.default.isFakeId(i)) {
                                const e =
                                    this.previewManager.getPreviewByIDSync(i),
                                  t =
                                    D.default.getProfileFriendByIdSync(i) || {},
                                  a =
                                    this.unreadDataManager.getUnreadByConvIdSync(
                                      i
                                    );
                                (s.lastMessage =
                                  null == e ? void 0 : e.message),
                                  (s.isFr = t.isFr),
                                  (s.type = t.type),
                                  (s.unreadMark =
                                    null == a ? void 0 : a.unreadMark),
                                  (s.smsUnreadCount =
                                    null == a ? void 0 : a.smsUnreadCount);
                              }
                              this.menuRef[bt.b].updateTargetInfo(s),
                                this.menuRef[bt.b].showAction(
                                  Object(p.a)({}, e)
                                );
                            }
                          })
                        ) || pt)
                    ) || pt)
                ) || pt)
            ) || pt)
        ) || pt;
      var St,
        yt = s("hI9i"),
        Ct = s("iZzu"),
        It = s("6Vk1"),
        Ot = s("RojW"),
        Et = s("rXIX"),
        Tt = s("l+Gc"),
        Rt = s("VTLO"),
        Lt = s("LJTV"),
        Mt = s("Enw1"),
        Ft = s("M7kw"),
        wt = s("Ws4b"),
        Dt = s("6uTC"),
        jt = s("c51z"),
        At = s("Ja3U"),
        Nt = s("SdS7"),
        Pt = s("P6UB"),
        kt = s("FEfs"),
        Ut = s("h0S/");
      const Bt = {
          typeFilter: Ct.FilterType.ALL,
          labelFilters: [],
          loaded: !1,
          isEnableArchivedChat: !!kt.a.isEnableArchivedChat(),
          hasUnreadArchivedChat: !1,
          typeFilterSrc: Ct.FilterSrcType.ALL,
        },
        Gt = "z_sendtome_bubbledot";
      Object(B.b)(Ct.ConvListController)(
        (St =
          (function (e, t) {
            return a.ModuleContainer.inject(me.b)(e, void 0, 0);
          })(
            (St =
              (function (e, t) {
                return a.ModuleContainer.inject(It.b)(e, void 0, 1);
              })(
                (St =
                  (function (e, t) {
                    return a.ModuleContainer.inject(me.i)(e, void 0, 2);
                  })(
                    (St =
                      (function (e, t) {
                        return a.ModuleContainer.inject(me.f)(e, void 0, 3);
                      })(
                        (St =
                          (function (e, t) {
                            return a.ModuleContainer.inject(me.g)(e, void 0, 4);
                          })(
                            (St =
                              (function (e, t) {
                                return a.ModuleContainer.inject(me.a)(
                                  e,
                                  void 0,
                                  5
                                );
                              })(
                                (St =
                                  Reflect.metadata(
                                    "design:type",
                                    Function
                                  )(
                                    (St =
                                      Reflect.metadata("design:paramtypes", [
                                        void 0 === me.b ? Object : me.b,
                                        void 0 === It.b ? Object : It.b,
                                        void 0 === me.i ? Object : me.i,
                                        void 0 === me.f ? Object : me.f,
                                        void 0 === me.g ? Object : me.g,
                                        void 0 === me.a ? Object : me.a,
                                      ])(
                                        (St = class extends re.b {
                                          constructor(e, t, s, a, n, r) {
                                            super(),
                                              (this.convDataManager = e),
                                              (this.labelDataManager = t),
                                              (this.unreadDataManager = s),
                                              (this.muteDataManager = a),
                                              (this.pinDataManager = n),
                                              (this.archivedChatManager = r),
                                              Object(i.a)(
                                                this,
                                                "typeFilter",
                                                void 0
                                              ),
                                              Object(i.a)(
                                                this,
                                                "labelFilters",
                                                void 0
                                              ),
                                              Object(i.a)(
                                                this,
                                                "listRawAll",
                                                void 0
                                              ),
                                              Object(i.a)(
                                                this,
                                                "listVisible",
                                                void 0
                                              ),
                                              Object(i.a)(
                                                this,
                                                "listStrangers",
                                                void 0
                                              ),
                                              Object(i.a)(
                                                this,
                                                "listHiddens",
                                                void 0
                                              ),
                                              Object(i.a)(
                                                this,
                                                "listFiltered",
                                                void 0
                                              ),
                                              Object(i.a)(
                                                this,
                                                "newestStrangerId",
                                                void 0
                                              ),
                                              Object(i.a)(
                                                this,
                                                "menuRef",
                                                void 0
                                              ),
                                              Object(i.a)(
                                                this,
                                                "convUIListContainer",
                                                void 0
                                              ),
                                              Object(i.a)(
                                                this,
                                                "showedOnboarding",
                                                void 0
                                              ),
                                              Object(i.a)(
                                                this,
                                                "loaded",
                                                void 0
                                              ),
                                              Object(i.a)(
                                                this,
                                                "isEnableArchivedChat",
                                                void 0
                                              ),
                                              Object(i.a)(
                                                this,
                                                "typeFilterSrc",
                                                void 0
                                              ),
                                              Object(i.a)(
                                                this,
                                                "hasUnreadArchivedChat",
                                                void 0
                                              ),
                                              Object(i.a)(
                                                this,
                                                "_logger",
                                                void 0
                                              ),
                                              Object(i.a)(this, "_pm", null),
                                              Object(i.a)(this, "_sbc", null),
                                              Object(i.a)(
                                                this,
                                                "handleMuteChange",
                                                (e) => {
                                                  const t = e.convId,
                                                    s = e.payload,
                                                    i =
                                                      this.listFiltered.includes(
                                                        t
                                                      );
                                                  this.logger.zsymb(
                                                    0,
                                                    11072,
                                                    30002,
                                                    "handleMuteChange",
                                                    t,
                                                    i,
                                                    this.typeFilter,
                                                    s
                                                  ),
                                                    i &&
                                                      (this.typeFilter ===
                                                        Ct.FilterType.UNREAD ||
                                                        (this
                                                          .isEnableArchivedChat &&
                                                          this.typeFilterSrc ===
                                                            Ct.FilterSrcType
                                                              .UNREAD)) &&
                                                      this.addConvToUnreadFilterV2(
                                                        t
                                                      );
                                                }
                                              ),
                                              Object(i.a)(
                                                this,
                                                "deleteConversation",
                                                (e, t = !0) => {
                                                  e != w.CONV_FILTER.STRANGER &&
                                                    (this.logger.zsymb(
                                                      18,
                                                      11072,
                                                      30006,
                                                      `[user call del conv] ${e}`
                                                    ),
                                                    ft.a
                                                      .deleteConversation(e, t)
                                                      .then((e) => {
                                                        e &&
                                                          e.delConversationId &&
                                                          Object(vt.f)({
                                                            type: y
                                                              .ConversationListActions
                                                              .TAG_CONV,
                                                            payload: {
                                                              data: [
                                                                {
                                                                  userId:
                                                                    e.delConversationId,
                                                                  label: null,
                                                                },
                                                              ],
                                                            },
                                                          });
                                                      })
                                                      .catch((e) => {
                                                        this.logger.zsymb(
                                                          18,
                                                          11072,
                                                          30007,
                                                          "Delete conversation fail - " +
                                                            JSON.stringify(e)
                                                        );
                                                      }));
                                                }
                                              ),
                                              Object(i.a)(
                                                this,
                                                "name",
                                                Ct.CONV_LIST_CONTROLLER
                                              ),
                                              Object(i.a)(
                                                this,
                                                "data",
                                                new Map()
                                              ),
                                              Object(i.a)(
                                                this,
                                                "key",
                                                "windowId"
                                              ),
                                              (this.isEnableArchivedChat = !1),
                                              (this.typeFilter =
                                                Ct.FilterType.ALL),
                                              (this.labelFilters = []),
                                              (this.typeFilterSrc =
                                                Ct.FilterSrcType.ALL),
                                              (this.listRawAll = new Set()),
                                              (this.listVisible = []),
                                              (this.listStrangers = []),
                                              (this.listHiddens = []),
                                              (this.listFiltered = []),
                                              (this.newestStrangerId = ""),
                                              (this.menuRef = {}),
                                              (this.showedOnboarding = !1),
                                              (this.loaded = !1),
                                              (this.hasUnreadArchivedChat = !1),
                                              (this.getRecentContactWithId =
                                                this.getRecentContactWithId.bind(
                                                  this
                                                )),
                                              (this.selectConversation =
                                                this.selectConversation.bind(
                                                  this
                                                )),
                                              (this.showBroadCastMsgModal =
                                                this.showBroadCastMsgModal.bind(
                                                  this
                                                )),
                                              (this.markAsRead =
                                                this.markAsRead.bind(this)),
                                              this.addListener();
                                          }
                                          get logger() {
                                            return (
                                              this._logger ||
                                                (this._logger =
                                                  a.ModuleContainer.resolve(
                                                    O.ZLoggerFactory
                                                  ).createZLogger(
                                                    Ut.b.conversation,
                                                    [Ut.b.convList]
                                                  )),
                                              this._logger
                                            );
                                          }
                                          get previewManager() {
                                            return (
                                              this._pm ||
                                                (this._pm =
                                                  a.ModuleContainer.resolve(
                                                    me.h
                                                  )),
                                              this._pm
                                            );
                                          }
                                          get sidebarController() {
                                            return (
                                              this._sbc ||
                                                (this._sbc =
                                                  a.ModuleContainer.resolve(
                                                    Ct.SidebarController
                                                  )),
                                              this._sbc
                                            );
                                          }
                                          get currUser() {
                                            return Object(wt.c)();
                                          }
                                          onTypeFilterChange(e, t) {
                                            if (e === Ct.FilterType.UNREAD) {
                                              const e =
                                                this.labelFilters.length > 0
                                                  ? 1453215
                                                  : 1453214;
                                              Z.e.logAction(e),
                                                setTimeout(() => {
                                                  this.scrollToTop(!1);
                                                });
                                            } else
                                              (e !== Ct.FilterType.ARCHIVED &&
                                                e !== Ct.FilterType.FOCUSED) ||
                                                this.typeFilter === e ||
                                                setTimeout(() => {
                                                  this.scrollToTop(!1);
                                                });
                                            e == Ct.FilterType.ARCHIVED &&
                                              this.hasUnreadArchivedChat &&
                                              (this.hasUnreadArchivedChat = !1),
                                              this.applyTypeFilter(e, t);
                                          }
                                          onLabelFilterChange(e) {
                                            this.typeFilter ===
                                              Ct.FilterType.UNREAD &&
                                              setTimeout(() => {
                                                this.scrollToTop(!1);
                                              }),
                                              this.applyLabelFilter(e);
                                          }
                                          rerenderList() {
                                            this.signalRenderList();
                                          }
                                          async onPreviewChange(e, t) {
                                            if (!e || !t) return;
                                            const s = e.convId;
                                            if (
                                              (this.listRawAll.add(s),
                                              ae.a.isThreadHidden(s))
                                            )
                                              return void this.listHiddens.push(
                                                s
                                              );
                                            let i = s,
                                              a = !1,
                                              n = !1,
                                              r = !1;
                                            if (await Ot.a.isOATypeAsync(s)) {
                                              const e =
                                                this.convDataManager.getConvByIdSync(
                                                  s
                                                );
                                              if (!e || !Ot.a.popoutOA(e))
                                                return;
                                            } else if (
                                              Ot.a.isStrangerV2(s) &&
                                              ((a = !0),
                                              this.listStrangers.includes(s) ||
                                                (this.logger.zsymb(
                                                  0,
                                                  11072,
                                                  30001,
                                                  `first new stranger msg ${s}`
                                                ),
                                                this.listStrangers.push(s)),
                                              !this.isMeBAAccount())
                                            ) {
                                              const t =
                                                  "0" == e.fromUid ||
                                                  this.convDataManager.isRespondedByMeSync(
                                                    s
                                                  ),
                                                a =
                                                  this.listVisible.includes(s);
                                              t ||
                                                (a &&
                                                  ((r = !0),
                                                  (this.listVisible =
                                                    this.listVisible.filter(
                                                      (e) => e !== s
                                                    ))),
                                                this.updateNewestStrangerId(
                                                  this.listStrangers
                                                ),
                                                (i = w.CONV_FILTER.STRANGER)),
                                                t &&
                                                  !a &&
                                                  ((n = !0),
                                                  this.listVisible.unshift(s),
                                                  this.newestStrangerId === s &&
                                                    this.updateNewestStrangerId(
                                                      this.listStrangers
                                                    ));
                                            }
                                            const [o, c] =
                                              Ot.a.insertToProperPosition(
                                                this.listVisible,
                                                i,
                                                this.getAlterId()
                                              );
                                            this.listVisible = o;
                                            const l =
                                                Tt.b.getLabelObjByConversaionId(
                                                  s
                                                ),
                                              d =
                                                l &&
                                                l.id &&
                                                this.labelFilters.includes(
                                                  "" + l.id
                                                ),
                                              h =
                                                a &&
                                                this.labelFilters.includes(
                                                  bt.h
                                                ),
                                              u = d || h,
                                              g = c || n || r;
                                            if (
                                              this.typeFilter ===
                                              Ct.FilterType.ALL
                                            )
                                              this.addTabAllFiltered(s, u, g);
                                            else if (
                                              this.typeFilter ===
                                              Ct.FilterType.UNREAD
                                            )
                                              this.addTabUnreadFiltered(
                                                s,
                                                u,
                                                a
                                              );
                                            else if (
                                              this.typeFilter ===
                                              Ct.FilterType.STRANGER
                                            ) {
                                              const e =
                                                  d ||
                                                  !this.labelFilters.length,
                                                t = a && e;
                                              this.addTabStrangerFiltered(s, t);
                                            } else
                                              this.isEnableArchivedChat &&
                                                ((this.listFiltered =
                                                  this.genListArchivedChat(
                                                    this.listVisible,
                                                    this.typeFilter ===
                                                      Ct.FilterType.ARCHIVED,
                                                    this.labelFilters
                                                  )),
                                                this.signalRenderList());
                                          }
                                          addTabAllFiltered(e, t, s) {
                                            if (t) {
                                              const [t, s] =
                                                Ot.a.insertToProperPosition(
                                                  this.listFiltered,
                                                  e,
                                                  this.getAlterId()
                                                );
                                              s &&
                                                ((this.listFiltered = t),
                                                this.signalRenderList());
                                            } else s && this.signalRenderList();
                                          }
                                          addTabUnreadFiltered(e, t, s) {
                                            if (
                                              this.listFiltered.includes(e) ||
                                              !Pt.b.isMyMessage(
                                                this.previewManager.getPreviewByIDSync(
                                                  e
                                                )
                                              )
                                            )
                                              if (t)
                                                this.addConvToUnreadFilterV2(e);
                                              else {
                                                if (this.labelFilters.length)
                                                  return;
                                                this.isMeBAAccount() || !s
                                                  ? this.addConvToUnreadFilterV2(
                                                      e
                                                    )
                                                  : this.addConvToUnreadFilterV2(
                                                      w.CONV_FILTER.STRANGER
                                                    );
                                              }
                                          }
                                          addTabStrangerFiltered(e, t) {
                                            if (!t) return;
                                            const [s, i] =
                                              Ot.a.insertToProperPosition(
                                                this.listFiltered,
                                                e,
                                                this.getAlterId()
                                              );
                                            i &&
                                              ((this.listFiltered = s),
                                              this.signalRenderList());
                                          }
                                          addConvToUnreadFilterV2(e) {
                                            if (
                                              this.muteDataManager.isMuted(e) &&
                                              !Ot.a.getPinFromConvId(e)
                                            )
                                              (this.listFiltered =
                                                this.safeSortConvList(
                                                  this.listFiltered,
                                                  !0
                                                )),
                                                this.signalRenderList();
                                            else {
                                              const [t, s] =
                                                Ot.a.insertToProperPosition(
                                                  this.listFiltered,
                                                  e,
                                                  this.getAlterId()
                                                );
                                              s &&
                                                ((this.listFiltered = t),
                                                this.signalRenderList());
                                            }
                                          }
                                          onPinChange(e) {
                                            let t = !1;
                                            for (let s = 0; s < e.length; s++) {
                                              const i = e[s].priority,
                                                a = e[s].id;
                                              i
                                                ? (this.onPreviewChange(
                                                    { convId: a },
                                                    []
                                                  ),
                                                  (t = !1))
                                                : ((t = !0),
                                                  (!this.previewManager.getPreviewByIDSync(
                                                    a
                                                  ) ||
                                                    (!this.convDataManager.isRespondedByMeSync(
                                                      a
                                                    ) &&
                                                      Ot.a.isStrangerV2(a))) &&
                                                    (this.listVisible =
                                                      this.listVisible.filter(
                                                        (e) => e !== a
                                                      )));
                                            }
                                            t &&
                                              ((this.listVisible =
                                                this.safeSortConvList(
                                                  this.listVisible,
                                                  !1
                                                )),
                                              (this.typeFilter !==
                                                Ct.FilterType.ALL ||
                                                this.labelFilters.length) &&
                                                (this.listFiltered =
                                                  Ot.a.sortConvId(
                                                    this.listFiltered,
                                                    this.typeFilter ===
                                                      Ct.FilterType.UNREAD,
                                                    !0
                                                  ))),
                                              this.signalRenderList();
                                          }
                                          onHiddenChat(e, t) {
                                            const s =
                                              this.convDataManager.getConvByIdSync(
                                                e
                                              );
                                            if (
                                              (this.logger.zsymb(
                                                0,
                                                11072,
                                                30003,
                                                "onHiddenChat ",
                                                e,
                                                t,
                                                !!s
                                              ),
                                              t)
                                            )
                                              this.listHiddens.push(e),
                                                (this.listVisible =
                                                  this.listVisible.filter(
                                                    (t) => t !== e
                                                  )),
                                                (this.listFiltered =
                                                  this.listFiltered.filter(
                                                    (t) => t !== e
                                                  )),
                                                this.signalRenderList();
                                            else {
                                              if (
                                                !s &&
                                                !N.a.PinDataManager.isPinned(e)
                                              )
                                                return;
                                              if (
                                                ((this.listHiddens =
                                                  this.listHiddens.filter(
                                                    (t) => t !== e
                                                  )),
                                                this.isMeBAAccount() ||
                                                  !Ot.a.isStrangerV2(e) ||
                                                  this.listStrangers.includes(
                                                    e
                                                  ))
                                              ) {
                                                const [t, s] =
                                                  Ot.a.insertToProperPosition(
                                                    this.listVisible,
                                                    e,
                                                    this.getAlterId()
                                                  );
                                                this.listVisible = t;
                                              } else this.listStrangers.push(e);
                                              if (this.listFiltered) {
                                                const [t, s] =
                                                  Ot.a.insertToProperPosition(
                                                    this.listFiltered,
                                                    e,
                                                    this.getAlterId()
                                                  );
                                                (this.listFiltered = t),
                                                  this.isEnableArchivedChat &&
                                                    (this.listFiltered =
                                                      this.genListArchivedChat(
                                                        this.listVisible,
                                                        this.typeFilter ===
                                                          Ct.FilterType
                                                            .ARCHIVED,
                                                        this.labelFilters
                                                      ));
                                              }
                                            }
                                            this.signalRenderList();
                                          }
                                          getCurrentFilter() {
                                            return {
                                              type: this.typeFilter,
                                              labels: this.labelFilters,
                                            };
                                          }
                                          getRecentContacts() {
                                            const e = [];
                                            return (
                                              this.listRawAll.forEach((t) => {
                                                const s =
                                                  this.convDataManager.getConvByIdSync(
                                                    t
                                                  );
                                                s && e.push(s);
                                              }),
                                              e
                                            );
                                          }
                                          getRecentContactWithId(e) {
                                            if (this.listRawAll.has(e)) {
                                              return (
                                                this.convDataManager.getConvByIdSync(
                                                  e
                                                ) || null
                                              );
                                            }
                                            return null;
                                          }
                                          addConvToLabel(e, t) {
                                            let s = Tt.b.getItem(t);
                                            He.ModalManagerV2.openModal({
                                              windowId: Ze.c,
                                              name: w.ModalIdentitiesDefine
                                                .MANAGE_LABEL,
                                              params: {
                                                view: Rt.b.ADD_CONVERSATION,
                                                info: s,
                                              },
                                            }),
                                              e &&
                                                (e.preventDefault(),
                                                e.stopPropagation()),
                                              Z.e.logAction(14521);
                                          }
                                          selectConversation(e) {
                                            if (
                                              (Lt.b.startPerf(Lt.a),
                                              e.userId === w.CONV_FILTER.MEDIA)
                                            )
                                              return void this.logger.zsymb(
                                                18,
                                                11072,
                                                30004,
                                                "No handler for mediabox. This feat disable!!!"
                                              );
                                            if (
                                              e.userId ===
                                              w.CONV_FILTER.STRANGER
                                            )
                                              return void (2 ==
                                              Number(
                                                $e.default.getConvUXVersion()
                                              )
                                                ? this.applyTypeFilter(
                                                    Ct.FilterType.STRANGER
                                                  )
                                                : this.labelDataManager.onSelectLabel(
                                                    bt.h
                                                  ));
                                            const t =
                                              this.sidebarController.getState(
                                                Ze.c
                                              ).selectedId;
                                            e.userId === t &&
                                            e.userId !==
                                              w.FAKE_CONVERSATION_ID
                                                .FRIEND_CENTER
                                              ? Object(vt.f)({
                                                  type: y
                                                    .ConversationListActions
                                                    .SELECT_CONV_MINOR,
                                                  payload: e,
                                                })
                                              : (this.convUIListContainer &&
                                                  this.convUIListContainer.focus(),
                                                e.userId ===
                                                  I.default.sendToMeId &&
                                                  (Mt.g.getFlagForCurrentUser(
                                                    this.currUser.userId,
                                                    Gt
                                                  ) ||
                                                    (ze.p.getHasShownSendToMeTip()
                                                      ? Mt.g.setFlagForCurrentUser(
                                                          this.currUser.userId,
                                                          Gt,
                                                          1
                                                        )
                                                      : setTimeout(() => {
                                                          _.default.send(
                                                            y
                                                              .ConversationListActions
                                                              .SHOW_BUBBLE_DOT
                                                          ),
                                                            ze.p.setHasShownSendToMeTip(
                                                              !0
                                                            );
                                                        }, 144e5)),
                                                  Ft.b.getCurrentStepKey() !==
                                                    Ft.a.UPLOAD_IMAGES ||
                                                    this.showedOnboarding ||
                                                    (Ft.b.show(),
                                                    (this.showedOnboarding =
                                                      !0)),
                                                  Z.e.logAction(13901)),
                                                e.userId ===
                                                w.FAKE_CONVERSATION_ID
                                                  .FRIEND_CENTER
                                                  ? Object(vt.f)({
                                                      type: y.SideBarActions
                                                        .SELECT_FRIEND_CENTER,
                                                      payload: Object(p.a)(
                                                        {},
                                                        e
                                                      ),
                                                    })
                                                  : a.ModuleContainer.resolve(
                                                      pe.b
                                                    ).openConversation(
                                                      e.userId,
                                                      pe.c.fromConvItem(e)
                                                    )),
                                              this.logActionSelectConv(
                                                e.userId
                                              );
                                          }
                                          showBroadCastMsgModal() {
                                            var e;
                                            if (
                                              !$e.default.checkBroadcastTime()
                                            )
                                              return void Dt.a.createError(
                                                jt.default.str(
                                                  "STR_BROADCAST_OVER_LIMIT_TIP"
                                                )
                                              );
                                            let t = !0;
                                            1 === this.labelFilters.length &&
                                              (t =
                                                Tt.b.getItem(
                                                  this.labelFilters[0]
                                                ) || !0),
                                              null !==
                                                (e =
                                                  I.default
                                                    .broadcast_resend_config) &&
                                              void 0 !== e &&
                                              e.enable
                                                ? He.ModalManagerV2.openModal({
                                                    windowId: Ze.c,
                                                    name: w
                                                      .ModalIdentitiesDefine
                                                      .BROADCAST_RESEND,
                                                    params: t,
                                                  })
                                                : He.ModalManagerV2.openModal({
                                                    windowId: Ze.c,
                                                    name: w
                                                      .ModalIdentitiesDefine
                                                      .BROADCAST_COMPSE,
                                                    params: { label: t },
                                                  }),
                                              Z.e.logAction(1453102);
                                          }
                                          markAsRead(e, t = null) {
                                            e &&
                                              (e.preventDefault(),
                                              e.stopPropagation()),
                                              Z.e.logAction(164),
                                              $e.default.isShowMarkAsReadAgain()
                                                ? At.a.openConfirm({
                                                    windowId: Ze.c,
                                                    name: w.MODAL_CONFIRM
                                                      .confirmIdentities,
                                                    params: {
                                                      message: jt.default.str(
                                                        "STR_MARK_READ_CONFIRM_TEXT"
                                                      ),
                                                      okText:
                                                        jt.default.str(
                                                          "STR_CONFIRM"
                                                        ),
                                                      okType: "primary",
                                                      cancelText:
                                                        jt.default.str(
                                                          "STR_LOGOUT_NO"
                                                        ),
                                                      onOk: (e) => {
                                                        $e.default.setShowMarkAsReadAgain(
                                                          !(
                                                            e &&
                                                            e.dont_show_mark_as_read
                                                          )
                                                        ),
                                                          this.markConvsAsRead(
                                                            t
                                                          );
                                                      },
                                                      options: [
                                                        {
                                                          default_val: !1,
                                                          key: "dont_show_mark_as_read",
                                                          title:
                                                            "STR_DONT_SHOW_AGAIN",
                                                        },
                                                      ],
                                                    },
                                                  })
                                                : this.markConvsAsRead(t);
                                          }
                                          scrollToTop(e) {
                                            const t = Nt.b
                                              .instance()
                                              .getConvList();
                                            t && t.scrollToTop(e);
                                          }
                                          scrollToConv(e) {
                                            const t = Nt.b
                                              .instance()
                                              .getConvList();
                                            t && t.scrollToConversation(e);
                                          }
                                          openInNewWindow(e, t) {
                                            if (!e || !e.userId) return;
                                            const s = this.menuRef[bt.b];
                                            s &&
                                              s.openInNewWindow &&
                                              (s.updateTargetInfo(e),
                                              s.openInNewWindow(t));
                                          }
                                          getStrangerInfo() {
                                            let e = "";
                                            if (this.newestStrangerId) {
                                              const t =
                                                this.previewManager.getPreviewByIDSync(
                                                  this.newestStrangerId
                                                );
                                              e = t ? t.messageTime : "";
                                            }
                                            return (
                                              this.logger.zsymb(
                                                0,
                                                11072,
                                                30005,
                                                "getStrangerInfo ",
                                                this.newestStrangerId,
                                                e
                                              ),
                                              { messageTime: e }
                                            );
                                          }
                                          getTopMostConv() {
                                            return this.typeFilter !==
                                              Ct.FilterType.ALL ||
                                              this.labelFilters.length
                                              ? this.listFiltered[0]
                                              : this.listVisible[0];
                                          }
                                          addListener() {
                                            setTimeout(() => {
                                              this.labelDataManager.addEventListener(
                                                It.d.SelectedLabelChange,
                                                (e) => {
                                                  this.onLabelFilterChange(
                                                    e.payload
                                                  );
                                                }
                                              ),
                                                this.labelDataManager.addEventListener(
                                                  It.d.LabelAddConvs,
                                                  (e) => {
                                                    this.onLabelChangeConvs(
                                                      e.payload.labelId,
                                                      e.payload.convIds,
                                                      "add"
                                                    );
                                                  }
                                                ),
                                                this.labelDataManager.addEventListener(
                                                  It.d.LabelRemoveConvs,
                                                  (e) => {
                                                    this.onLabelChangeConvs(
                                                      e.payload.labelId,
                                                      e.payload.convIds,
                                                      "remove"
                                                    );
                                                  }
                                                );
                                              const e =
                                                a.ModuleContainer.resolve(me.h);
                                              e.addEventListener(
                                                Et.b.DoneLoadPreview,
                                                (e) => {
                                                  this.onLoadPreview(e.payload);
                                                }
                                              ),
                                                e.addEventListener(
                                                  Et.b.DoneMigratePreview,
                                                  () => {
                                                    this.onMigratedPreview();
                                                  }
                                                ),
                                                e.addEventListener(
                                                  Et.b.PreviewChanged,
                                                  (e) => {
                                                    const {
                                                      changedItem: t,
                                                      all: s,
                                                    } = e.payload;
                                                    this.onPreviewChange(t, s);
                                                  }
                                                ),
                                                e.addEventListener(
                                                  Et.b.DraftChanged,
                                                  (e) => {}
                                                ),
                                                this.convDataManager.addEventListener(
                                                  Et.b.DeleteConv,
                                                  (e) => {
                                                    this.moveConvOutConvList(
                                                      e.convId
                                                    );
                                                  }
                                                ),
                                                this.convDataManager.addEventListener(
                                                  Et.b.EmptyConv,
                                                  (e) => {
                                                    this.moveConvOutConvList(
                                                      e.convId
                                                    );
                                                  }
                                                ),
                                                this.convDataManager.addEventListener(
                                                  Et.b.LeaveGroup,
                                                  (e) => {
                                                    this.moveConvOutConvList(
                                                      e.convId
                                                    );
                                                  }
                                                ),
                                                this.pinDataManager.addEventListener(
                                                  Et.b.ChangePinConv,
                                                  (e) => {
                                                    this.onPinChange(e.payload);
                                                  }
                                                ),
                                                this.archivedChatManager.addEventListener(
                                                  Et.b.UpdateListArchivedChat,
                                                  (e) => {
                                                    this.updateListArchivedChat();
                                                  }
                                                ),
                                                this.archivedChatManager.addEventListener(
                                                  Et.b.OnOffArchivedChat,
                                                  (e) => {
                                                    this.onOffArchivedChat(
                                                      e.payload.status
                                                    );
                                                  }
                                                ),
                                                this.unreadDataManager.addEventListener(
                                                  Et.b.ChangeUnreadArchiveChat,
                                                  (e) => {
                                                    this.updateUnreadArchivedChat(
                                                      e.payload
                                                        .hasUnreadArchivedChat
                                                    );
                                                  }
                                                ),
                                                this.muteDataManager.addEventListener(
                                                  Et.b.MuteChanged,
                                                  this.handleMuteChange
                                                ),
                                                D.default.subscribeEventFriend(
                                                  w.EventFriend.ADD_FRIEND,
                                                  ({ userId: e }) => {
                                                    let t = 0;
                                                    this.listStrangers.includes(
                                                      e
                                                    ) &&
                                                      (t++,
                                                      (this.listStrangers =
                                                        this.listStrangers.filter(
                                                          (t) => t !== e
                                                        )),
                                                      e ==
                                                        this.newestStrangerId &&
                                                        (t++,
                                                        this.updateNewestStrangerId(
                                                          this.listStrangers
                                                        ))),
                                                      this.logger.zsymb(
                                                        0,
                                                        11072,
                                                        30008,
                                                        `on add friend ${e} ${t}`
                                                      );
                                                  }
                                                ),
                                                D.default.subscribeEventFriend(
                                                  w.EventFriend.REMOVE_FRIEND,
                                                  ({ userId: e }) => {
                                                    let t = 0;
                                                    !this.listStrangers.includes(
                                                      e
                                                    ) &&
                                                      this.listVisible.some(
                                                        (t) => t === e
                                                      ) &&
                                                      (t++,
                                                      this.listStrangers.push(
                                                        e
                                                      )),
                                                      this.logger.zsymb(
                                                        0,
                                                        11072,
                                                        30009,
                                                        `on remove friend ${e} ${t}`
                                                      );
                                                  }
                                                ),
                                                D.default.subscribeEventFriend(
                                                  w.EventFriend
                                                    .DOWNGRADE_BIZ_PROFILE,
                                                  () => {
                                                    this.handleUserPackageChange();
                                                  }
                                                ),
                                                D.default.subscribeEventFriend(
                                                  w.EventFriend
                                                    .UPGRADE_BIZ_PROFILE,
                                                  () => {
                                                    this.handleUserPackageChange();
                                                  }
                                                );
                                            }, 0);
                                          }
                                          addToListFiltered(e, t = !1) {
                                            e.forEach((e) => {
                                              if (t) {
                                                const t =
                                                  this.unreadDataManager.getUnreadByConvIdSync(
                                                    e
                                                  );
                                                if (
                                                  !t ||
                                                  (!t.smsUnreadCount &&
                                                    !t.unreadMark)
                                                )
                                                  return;
                                              }
                                              const [s] =
                                                Ot.a.insertToProperPosition(
                                                  this.listFiltered,
                                                  e
                                                );
                                              this.listFiltered = s;
                                            });
                                          }
                                          applyTypeFilter(e, t = !1) {
                                            if (this.typeFilter === e && !t)
                                              return;
                                            this.logger.zsymb(
                                              0,
                                              11072,
                                              30010,
                                              "applyTypeFilter ",
                                              e,
                                              t
                                            );
                                            const s = this.typeFilter;
                                            switch (
                                              ((this.typeFilter = e), e)
                                            ) {
                                              case Ct.FilterType.ALL:
                                                if (
                                                  0 !== this.labelFilters.length
                                                ) {
                                                  if (
                                                    ((this.listFiltered =
                                                      Ot.a.filterByLabel(
                                                        this.listVisible,
                                                        this.labelFilters
                                                      )),
                                                    this.labelFilters.includes(
                                                      bt.h
                                                    ))
                                                  ) {
                                                    let e = this.listStrangers;
                                                    this.showStrangerNROnly() &&
                                                      (e =
                                                        Ot.a.filterByResponsed(
                                                          e,
                                                          !1
                                                        )),
                                                      this.addToListFiltered(e);
                                                  } else
                                                    this.doAddStrangerHasLabel(
                                                      this.listFiltered,
                                                      this.labelFilters
                                                    );
                                                  this.addLikeConvToFilterListV2(
                                                    this.listFiltered,
                                                    this.labelFilters
                                                  );
                                                }
                                                break;
                                              case Ct.FilterType.UNREAD:
                                                if (
                                                  0 !== this.labelFilters.length
                                                ) {
                                                  const e =
                                                    s == Ct.FilterType.ALL
                                                      ? this.listFiltered
                                                      : this.listVisible;
                                                  (this.listFiltered =
                                                    Ot.a.filterByLabel(
                                                      e,
                                                      this.labelFilters
                                                    )),
                                                    this.labelFilters.includes(
                                                      bt.h
                                                    )
                                                      ? this.addToListFiltered(
                                                          this.listStrangers
                                                        )
                                                      : this.doAddStrangerHasLabel(
                                                          this.listFiltered,
                                                          this.labelFilters
                                                        ),
                                                    (this.listFiltered =
                                                      Ot.a.filterByUnread(
                                                        this.listFiltered
                                                      )),
                                                    (this.listFiltered =
                                                      Ot.a.sortConvId(
                                                        this.listFiltered,
                                                        !0,
                                                        !0
                                                      ));
                                                } else
                                                  (this.listFiltered =
                                                    Ot.a.filterByUnread(
                                                      this.listVisible
                                                    )),
                                                    (this.listFiltered =
                                                      this.safeSortConvList(
                                                        this.listFiltered
                                                      ));
                                                break;
                                              case Ct.FilterType.STRANGER:
                                                (this.listFiltered =
                                                  Ot.a.filterByLabel(
                                                    this.listStrangers,
                                                    this.labelFilters
                                                  )),
                                                  (this.listFiltered =
                                                    Ot.a.sortConvId(
                                                      this.listFiltered,
                                                      !1,
                                                      !0
                                                    )),
                                                  this.showStrangerNROnly() &&
                                                    (this.listFiltered =
                                                      Ot.a.filterByResponsed(
                                                        this.listFiltered,
                                                        !1
                                                      ));
                                                break;
                                              case Ct.FilterType.FOCUSED:
                                                this.listFiltered =
                                                  this.genListArchivedChat(
                                                    this.listVisible,
                                                    !1,
                                                    this.labelFilters
                                                  );
                                                break;
                                              case Ct.FilterType.ARCHIVED:
                                                this.listFiltered =
                                                  this.genListArchivedChat(
                                                    this.listVisible,
                                                    !0,
                                                    this.labelFilters
                                                  );
                                            }
                                            this.signalRenderState(),
                                              this.signalRenderList();
                                          }
                                          applyLabelFilter(e) {
                                            if (this.labelFilters !== e) {
                                              switch (
                                                (this.logger.zsymb(
                                                  0,
                                                  11072,
                                                  30011,
                                                  "applyLabelFilter ",
                                                  e.join("-")
                                                ),
                                                (this.labelFilters = e.map(
                                                  (e) => "" + e
                                                )),
                                                this.typeFilter)
                                              ) {
                                                case Ct.FilterType.ALL:
                                                  if (
                                                    ((this.listFiltered =
                                                      Ot.a.filterByLabel(
                                                        this.listVisible,
                                                        this.labelFilters
                                                      )),
                                                    this.doAddStrangerHasLabel(
                                                      this.listFiltered,
                                                      this.labelFilters
                                                    ),
                                                    this.addLikeConvToFilterListV2(
                                                      this.listFiltered,
                                                      e
                                                    ),
                                                    this.labelFilters.some(
                                                      (e) => e == bt.h
                                                    ))
                                                  ) {
                                                    let e = this.listStrangers;
                                                    this.showStrangerNROnly() &&
                                                      (e =
                                                        Ot.a.filterByResponsed(
                                                          e,
                                                          !1
                                                        )),
                                                      this.addToListFiltered(e);
                                                  }
                                                  break;
                                                case Ct.FilterType.UNREAD:
                                                  if (
                                                    ((this.listFiltered =
                                                      Ot.a.filterByLabel(
                                                        this.listVisible,
                                                        e
                                                      )),
                                                    this.doAddStrangerHasLabel(
                                                      this.listFiltered,
                                                      this.labelFilters
                                                    ),
                                                    this.labelFilters.some(
                                                      (e) => e == bt.h
                                                    ))
                                                  ) {
                                                    let e = this.listStrangers;
                                                    this.showStrangerNROnly() &&
                                                      (e =
                                                        Ot.a.filterByResponsed(
                                                          e,
                                                          !1
                                                        )),
                                                      this.addToListFiltered(e);
                                                  }
                                                  (this.listFiltered =
                                                    Ot.a.filterByUnread(
                                                      this.listFiltered
                                                    )),
                                                    (this.listFiltered =
                                                      this.safeSortConvList(
                                                        this.listFiltered
                                                      ));
                                                  break;
                                                case Ct.FilterType.STRANGER:
                                                  (this.listFiltered =
                                                    Ot.a.filterByLabel(
                                                      this.listStrangers,
                                                      this.labelFilters
                                                    )),
                                                    (this.listFiltered =
                                                      Ot.a.sortConvId(
                                                        this.listFiltered,
                                                        !1,
                                                        !0
                                                      )),
                                                    this.showStrangerNROnly() &&
                                                      (this.listFiltered =
                                                        Ot.a.filterByResponsed(
                                                          this.listFiltered,
                                                          !1
                                                        ));
                                                  break;
                                                case Ct.FilterType.FOCUSED:
                                                  this.listFiltered =
                                                    this.genListArchivedChat(
                                                      this.listVisible,
                                                      !1,
                                                      e
                                                    );
                                                  break;
                                                case Ct.FilterType.ARCHIVED:
                                                  this.listFiltered =
                                                    this.genListArchivedChat(
                                                      this.listVisible,
                                                      !0,
                                                      e
                                                    );
                                              }
                                              this.signalRenderState(),
                                                this.signalRenderList();
                                            }
                                          }
                                          showStrangerNROnly() {
                                            return !this.isMeBAAccount();
                                          }
                                          isMeBAAccount() {
                                            const e = D.default.isMeBAAccount();
                                            return (
                                              this.logger.zsymb(
                                                0,
                                                11072,
                                                30012,
                                                "isMeBAAccount ",
                                                e
                                              ),
                                              e
                                            );
                                          }
                                          doAddStrangerHasLabel(e, t) {
                                            if (t.length) {
                                              const s = Ot.a.filterByLabel(
                                                this.listStrangers,
                                                t
                                              );
                                              if (s.length) {
                                                const t = new Set(s);
                                                for (
                                                  let s = 0;
                                                  s < e.length;
                                                  s++
                                                )
                                                  t.has(e[s]) && t.delete(e[s]);
                                                this.addToListFiltered(t);
                                              }
                                            }
                                            return e;
                                          }
                                          isConvExists(e) {
                                            const t =
                                              this.convDataManager.getConvByIdSync(
                                                e
                                              );
                                            return !!(
                                              (null != t &&
                                                t.firstSmsLocalId) ||
                                              (null != t && t.lastSmsLocalId)
                                            );
                                          }
                                          safeSortConvList(e, t = !0) {
                                            const s = e.indexOf(
                                              w.CONV_FILTER.STRANGER
                                            );
                                            if (-1 !== s) {
                                              e[s] = this.newestStrangerId;
                                              const i = (e = Ot.a.sortConvId(
                                                e,
                                                t,
                                                !0
                                              )).indexOf(this.newestStrangerId);
                                              e[i] = w.CONV_FILTER.STRANGER;
                                            } else
                                              e = Ot.a.sortConvId(e, t, !0);
                                            return e;
                                          }
                                          isValidFakeConv(e, t, s) {
                                            if (
                                              e.some((e) => e == s) ||
                                              ae.a.isThreadHidden(s)
                                            )
                                              return !1;
                                            const i =
                                              Tt.b.getLabelObjByConversaionId(
                                                s
                                              );
                                            return !(
                                              !i || !t.some((e) => e == i.id)
                                            );
                                          }
                                          isValidFakeConvV2(e, t) {
                                            if (
                                              !t ||
                                              e.some((e) => e == t) ||
                                              ae.a.isThreadHidden(t)
                                            )
                                              return !1;
                                            return (
                                              !(
                                                t &&
                                                t.startsWith(w.GROUPID_PREFIX)
                                              ) ||
                                              !!ne.default.getGroupByIdSync(t)
                                            );
                                          }
                                          addLikeConvToFilterListV2(e, t) {
                                            if (
                                              t.length &&
                                              this.typeFilter !==
                                                Ct.FilterType.UNREAD
                                            ) {
                                              this.logger.zsymb(
                                                0,
                                                11072,
                                                30013,
                                                "addLikeConvToFilterListV2 ",
                                                t
                                              );
                                              for (const s of t) {
                                                const t =
                                                  this.labelDataManager.getLabelById(
                                                    s
                                                  );
                                                if (t && t.conversations)
                                                  for (const s of t.conversations)
                                                    this.isValidFakeConvV2(
                                                      e,
                                                      s
                                                    ) && e.push(s);
                                              }
                                            }
                                          }
                                          markConvsAsRead(e) {
                                            const t = [],
                                              s =
                                                0 === this.labelFilters.length;
                                            this.logger.zsymb(
                                              0,
                                              11072,
                                              30014,
                                              `markConvsAsRead #1  ${
                                                null == e ? void 0 : e.join("-")
                                              }`
                                            ),
                                              this.listRawAll.forEach((i) => {
                                                const a =
                                                  this.unreadDataManager.getUnreadByConvIdSync(
                                                    i
                                                  );
                                                if (
                                                  a &&
                                                  (a.smsUnreadCount > 0 ||
                                                    a.unreadMark)
                                                ) {
                                                  if (
                                                    (this.logger.zsymb(
                                                      0,
                                                      11072,
                                                      30015,
                                                      `markConvsAsRead #2, ${i}, ${a.smsUnreadCount}`
                                                    ),
                                                    (e &&
                                                      !e.hasOwnProperty(i)) ||
                                                      i ===
                                                        w.FAKE_CONVERSATION_ID
                                                          .FRIEND_CENTER)
                                                  )
                                                    return;
                                                  const n =
                                                      Tt.b.getLabelObjByConversaionId(
                                                        i
                                                      ) || {},
                                                    r =
                                                      this.convDataManager.getConvByIdSync(
                                                        i
                                                      ) || { userId: i };
                                                  (s ||
                                                    this.labelFilters.some(
                                                      (e) => e == n.id
                                                    ) ||
                                                    (Ot.a.isInStrangerBoxV2(
                                                      i
                                                    ) &&
                                                      this.typeFilter ===
                                                        Ct.FilterType
                                                          .STRANGER)) &&
                                                    t.push(r);
                                                }
                                              }),
                                              this.logger.zsymb(
                                                0,
                                                11072,
                                                30016,
                                                `markConvsAsRead #3 ${
                                                  t.length
                                                } ${t
                                                  .map((e) => e.userId)
                                                  .join("-")}`
                                              ),
                                              t.length > 0 &&
                                                (_.default.send(
                                                  y.SideBarActions.MARK_AS_READ,
                                                  { conversations: t }
                                                ),
                                                Z.e.logAction(1453304));
                                          }
                                          onLoadPreview(e) {
                                            this.logger.zsymb(
                                              0,
                                              11072,
                                              30017,
                                              `onload Preview 1: ${this.listRawAll.size}`
                                            );
                                            let t = e.map((e) => e.convId);
                                            const s =
                                              $e.default.getConvUXVersion();
                                            (this.isEnableArchivedChat =
                                              !!kt.a.isEnableArchivedChat() &&
                                              "3" == s),
                                              (this.typeFilter = this
                                                .isEnableArchivedChat
                                                ? Ct.FilterType.FOCUSED
                                                : Ct.FilterType.ALL),
                                              this.listRawAll.size &&
                                                this.listRawAll.forEach((e) => {
                                                  t.some((t) => t === e) ||
                                                    t.push(e);
                                                }),
                                              (this.listRawAll = new Set(t));
                                            const i = I.default.sendToMeId;
                                            this.listRawAll.has(i) ||
                                              (t.push(i),
                                              this.listRawAll.add(i)),
                                              this.logger.zsymb(
                                                0,
                                                11072,
                                                30018,
                                                `onload Preview 2: ${t.length}`
                                              ),
                                              Ot.a
                                                .groupConversaion(t)
                                                .then((e) => {
                                                  if (
                                                    (this.logger.zsymb(
                                                      0,
                                                      11072,
                                                      30019,
                                                      `grouped list #1: \n\t\t\t\t${e.hidden.length}\n\t\t\t\t- ${e.stranger.length}\n\t\t\t\t- ${e.outdate.length}\n\t\t\t\t- ${e.visible.length}\n\t\t\t`
                                                    ),
                                                    I.default.stagingAccount)
                                                  )
                                                    for (const i in e)
                                                      this.logger.zsymb(
                                                        0,
                                                        11072,
                                                        30020,
                                                        `${i}: ${e[i]}`
                                                      );
                                                  (this.listStrangers =
                                                    e.stranger),
                                                    (this.listHiddens =
                                                      e.hidden);
                                                  const t =
                                                    this.addStrangersToVisible(
                                                      e.visible,
                                                      this.listStrangers
                                                    );
                                                  let s = t;
                                                  if (this.listVisible.length) {
                                                    this.logger.zsymb(
                                                      0,
                                                      11072,
                                                      30021,
                                                      `preview changed while group csc #1: ${this.listVisible}`
                                                    ),
                                                      (s = this.listVisible);
                                                    const e = new Set(
                                                      this.listVisible
                                                    );
                                                    t.forEach((t) => {
                                                      e.has(t) || s.push(t);
                                                    });
                                                  }
                                                  (this.listVisible =
                                                    this.safeSortConvList(
                                                      s,
                                                      !1
                                                    )),
                                                    this.initMyCloud(),
                                                    this.isEnableArchivedChat &&
                                                      (this.listFiltered =
                                                        this.genListArchivedChat(
                                                          this.listVisible,
                                                          this.typeFilter ===
                                                            Ct.FilterType
                                                              .ARCHIVED,
                                                          this.labelFilters
                                                        )),
                                                    this.logger.zsymb(
                                                      0,
                                                      11072,
                                                      30022,
                                                      `visible sorted #1: ${this.listVisible}`
                                                    ),
                                                    (this.loaded = !0),
                                                    this.signalRenderList(),
                                                    this.signalRenderState(),
                                                    this.dispatchEvent(
                                                      new Et.a(
                                                        Et.c.LoadPreviewDone,
                                                        "",
                                                        this.listVisible.slice()
                                                      )
                                                    );
                                                });
                                          }
                                          onMigratedPreview() {
                                            this.logger.zsymb(
                                              0,
                                              11072,
                                              30023,
                                              `onMigratedPreview #1: ${this.listVisible}`
                                            );
                                            const e =
                                              $e.default.getConvUXVersion();
                                            (this.isEnableArchivedChat =
                                              !!kt.a.isEnableArchivedChat() &&
                                              "3" == e),
                                              (this.typeFilter = this
                                                .isEnableArchivedChat
                                                ? Ct.FilterType.FOCUSED
                                                : Ct.FilterType.ALL);
                                            const t = I.default.sendToMeId;
                                            this.listRawAll.has(t) ||
                                              this.initMyCloud(),
                                              this.convDataManager.getConvByIdSync(
                                                t
                                              ) &&
                                                !this.listVisible.includes(t) &&
                                                (this.logger.zsymb(
                                                  0,
                                                  11072,
                                                  30024,
                                                  "onMigratedPreview #2"
                                                ),
                                                this.onPreviewChange(
                                                  { convId: t },
                                                  []
                                                )),
                                              (this.loaded = !0),
                                              this.signalRenderList(),
                                              this.signalRenderState();
                                          }
                                          initMyCloud() {
                                            const e =
                                                Mt.g.getFlagForCurrentUser(
                                                  null,
                                                  "z_sendtome"
                                                ),
                                              t = I.default.sendToMeId,
                                              s = !(
                                                I.default.isOffSendToMe ||
                                                (e && 1 !== e)
                                              );
                                            if (
                                              (this.logger.zsymb(
                                                0,
                                                11072,
                                                30025,
                                                "initMyCloud",
                                                e,
                                                I.default.isOffSendToMe
                                              ),
                                              this.listVisible.some(
                                                (e) => e === t
                                              ))
                                            ) {
                                              const e =
                                                this.convDataManager.getConvByIdSync(
                                                  t
                                                );
                                              e && e.pinned
                                                ? Z.e.logAction(1390703)
                                                : (Mt.g.setFlagForCurrentUser(
                                                    null,
                                                    "z_sendtome",
                                                    Date.now()
                                                  ),
                                                  Z.e.logAction(1390702));
                                            } else if (s) {
                                              const e =
                                                  N.a.PinDataManager.getTotalPinnedConversation() >=
                                                  I.default.limit_pin_messages,
                                                s =
                                                  I.default.auto_pin_send2me &&
                                                  !Mt.g.getFlagForCurrentUser(
                                                    null,
                                                    "z_sendtome_pinned"
                                                  ) &&
                                                  !e;
                                              this.convDataManager.createEmptyConvForUser(
                                                t,
                                                s ? 1 : 0,
                                                w.CONV_OT_STATE.none,
                                                {}
                                              ),
                                                s &&
                                                  (N.a.PinDataManager.pin([t]),
                                                  Mt.g.setFlagForCurrentUser(
                                                    null,
                                                    "z_sendtome_pinned",
                                                    1
                                                  )),
                                                Mt.g.setFlagForCurrentUser(
                                                  null,
                                                  "z_sendtome",
                                                  Date.now()
                                                ),
                                                this.onPreviewChange(
                                                  { convId: t },
                                                  []
                                                );
                                            }
                                          }
                                          addStrangersToVisible(e, t) {
                                            if (!t || !t.length) return e;
                                            if (this.isMeBAAccount())
                                              return e.concat(t);
                                            {
                                              const s = Ot.a.filterByResponsed(
                                                t,
                                                !1
                                              );
                                              if (s.length) {
                                                this.newestStrangerId =
                                                  Ot.a.getNewestConvFromIds(s);
                                                e.includes(
                                                  w.CONV_FILTER.STRANGER
                                                ) ||
                                                  e.push(
                                                    w.CONV_FILTER.STRANGER
                                                  );
                                              }
                                              return (
                                                t.forEach((t) => {
                                                  this.convDataManager.isRespondedByMeSync(
                                                    t
                                                  ) && e.push(t);
                                                }),
                                                e
                                              );
                                            }
                                          }
                                          onLabelChangeConvs(e, t, s) {
                                            if (
                                              (this.logger.zsymb(
                                                0,
                                                11072,
                                                30026,
                                                "onLabelChangeConvs",
                                                t.length,
                                                e
                                              ),
                                              t.length &&
                                                this.labelFilters.includes(e))
                                            )
                                              if ("add" == s) {
                                                const e = t.filter(
                                                  (e) =>
                                                    !this.listFiltered.includes(
                                                      e
                                                    ) &&
                                                    !this.listHiddens.includes(
                                                      e
                                                    )
                                                );
                                                if (!e.length) return;
                                                (this.listFiltered = [
                                                  ...this.listFiltered,
                                                  ...e,
                                                ]),
                                                  (this.listFiltered =
                                                    Ot.a.sortConvId(
                                                      this.listFiltered,
                                                      this.typeFilter ===
                                                        Ct.FilterType.UNREAD,
                                                      !1
                                                    )),
                                                  this.signalRenderList();
                                              } else {
                                                let e = !1;
                                                t.forEach((t) => {
                                                  const s =
                                                      Tt.b.getLabelObjByConversaionId(
                                                        t
                                                      ),
                                                    i = s ? s.id : null;
                                                  this.labelFilters.includes(
                                                    "" + i
                                                  ) ||
                                                    ((this.listFiltered =
                                                      this.listFiltered.filter(
                                                        (e) => e !== t
                                                      )),
                                                    (e = !0));
                                                }),
                                                  e && this.signalRenderList();
                                              }
                                          }
                                          moveConvOutConvList(e) {
                                            this.logger.zsymb(
                                              0,
                                              11072,
                                              30027,
                                              "moveConvOutConvList",
                                              e
                                            ),
                                              (this.listVisible =
                                                this.listVisible.filter(
                                                  (t) => t !== e
                                                )),
                                              (this.listFiltered =
                                                this.listFiltered.filter(
                                                  (t) => t !== e
                                                )),
                                              (this.listStrangers =
                                                this.listStrangers.filter(
                                                  (t) => t !== e
                                                )),
                                              e !== this.newestStrangerId ||
                                                this.isMeBAAccount() ||
                                                this.updateNewestStrangerId(
                                                  this.listStrangers
                                                ),
                                              this.signalRenderList();
                                          }
                                          getAlterId() {
                                            return new Map([
                                              [
                                                w.CONV_FILTER.STRANGER,
                                                this.newestStrangerId,
                                              ],
                                            ]);
                                          }
                                          updateNewestStrangerId(e) {
                                            if (this.isMeBAAccount()) return;
                                            const t = Ot.a.filterByResponsed(
                                                e,
                                                !1
                                              ),
                                              s = this.newestStrangerId;
                                            if (
                                              ((this.newestStrangerId =
                                                Ot.a.getNewestConvFromIds(t)),
                                              this.newestStrangerId ||
                                                ((this.listVisible =
                                                  this.listVisible.filter(
                                                    (e) =>
                                                      e !==
                                                      w.CONV_FILTER.STRANGER
                                                  )),
                                                this.signalRenderList()),
                                              this.previewManager.updateStrangerBox(
                                                this.newestStrangerId
                                              ),
                                              s !== this.newestStrangerId &&
                                                this.newestStrangerId)
                                            ) {
                                              const [e, t] =
                                                Ot.a.insertToProperPosition(
                                                  this.listVisible,
                                                  w.CONV_FILTER.STRANGER,
                                                  this.getAlterId()
                                                );
                                              (this.listVisible = e),
                                                this.signalRenderList();
                                            }
                                          }
                                          rebuildList() {
                                            this.logger.zsymb(
                                              0,
                                              11072,
                                              30028,
                                              `rebuildList 1: ${this.listRawAll.size} ${this.listVisible.length} ${this.listStrangers.length}`
                                            ),
                                              (this.listStrangers = []),
                                              (this.listVisible = []),
                                              (this.listHiddens = []),
                                              (this.listFiltered = []),
                                              (this.newestStrangerId = "");
                                            const e = Array.from(
                                                this.listRawAll
                                              ),
                                              t = Ot.a.groupConversaionSync(e);
                                            if (
                                              (this.logger.zsymb(
                                                0,
                                                11072,
                                                30029,
                                                `grouped list #2: \n\t\t\t${t.hidden.length}\n\t\t\t- ${t.stranger.length}\n\t\t\t- ${t.outdate.length}\n\t\t\t- ${t.visible.length}\n\t\t`
                                              ),
                                              I.default.stagingAccount)
                                            )
                                              for (const a in t)
                                                this.logger.zsymb(
                                                  0,
                                                  11072,
                                                  30030,
                                                  `${a}:, ${t[a]}`
                                                );
                                            (this.listStrangers = t.stranger),
                                              (this.listHiddens = t.hidden);
                                            const s =
                                                this.addStrangersToVisible(
                                                  t.visible,
                                                  this.listStrangers
                                                ),
                                              i = this.safeSortConvList(s, !1);
                                            (this.listVisible = i),
                                              this.logger.zsymb(
                                                0,
                                                11072,
                                                30031,
                                                `visible sorted #2: ${this.listVisible}`
                                              ),
                                              this.labelFilters.length &&
                                                this.applyLabelFilter(
                                                  this.labelFilters
                                                ),
                                              this.typeFilter !==
                                                Ct.FilterType.ALL &&
                                                this.applyTypeFilter(
                                                  this.typeFilter,
                                                  I.default
                                                    .should_force_genlist_conv
                                                ),
                                              this.signalRenderList(),
                                              this.signalRenderState();
                                          }
                                          handleUserPackageChange() {
                                            this.logger.zsymb(
                                              0,
                                              11072,
                                              30032,
                                              `handleUserPackageChange: ${D.default.isMeBAAccount()}}`
                                            ),
                                              this.rebuildList();
                                          }
                                          signalRenderList(e = "all") {
                                            Object(yt.h)(this.name, e);
                                          }
                                          signalRenderState() {
                                            Object(yt.g)(this.name, Ze.c);
                                          }
                                          logActionSelectConv(e) {
                                            const t =
                                              this.labelFilters.length > 0;
                                            if (
                                              (this.typeFilter ===
                                              Ct.FilterType.UNREAD
                                                ? (Z.e.logAction(1453103),
                                                  t || Z.e.logAction(1453107))
                                                : this.typeFilter ===
                                                  Ct.FilterType.ALL
                                                ? (Z.e.logAction(1453104),
                                                  t && Z.e.logAction(1453108))
                                                : this.typeFilter ===
                                                  Ct.FilterType.FOCUSED
                                                ? Z.e.logAction(1453501)
                                                : this.typeFilter ===
                                                    Ct.FilterType.ARCHIVED &&
                                                  Z.e.logAction(1453502),
                                              t)
                                            )
                                              Z.e.logAction(1453105);
                                            else {
                                              Z.e.logAction(1453106);
                                              for (
                                                let e = 0;
                                                e < this.labelFilters.length;
                                                e++
                                              ) {
                                                if (
                                                  parseInt(
                                                    this.labelFilters[e]
                                                  ) > 0
                                                ) {
                                                  Z.e.logAction(1453109);
                                                  break;
                                                }
                                              }
                                            }
                                            this.typeFilter ==
                                              Ct.FilterType.ARCHIVED &&
                                              kt.a.sendTrackSrc(e, 4, !1);
                                          }
                                          init() {}
                                          getItem(e) {
                                            return e.key === Ze.c
                                              ? {
                                                  labelFilters:
                                                    this.labelFilters,
                                                  typeFilter: this.typeFilter,
                                                  loaded: this.loaded,
                                                  isEnableArchivedChat:
                                                    this.isEnableArchivedChat,
                                                  hasUnreadArchivedChat:
                                                    this.hasUnreadArchivedChat,
                                                  typeFilterSrc:
                                                    this.typeFilterSrc,
                                                }
                                              : Bt;
                                          }
                                          getList(e) {
                                            return e.key === Ze.c ||
                                              (this.typeFilter ==
                                                Ct.FilterType.ALL &&
                                                0 === this.labelFilters.length)
                                              ? this.listVisible
                                              : this.listFiltered;
                                          }
                                          onGetItemFailure(e) {}
                                          onGetListFailure(e) {}
                                          bindUIMenu(e, t) {
                                            this.menuRef[e] = t;
                                          }
                                          cleanUpUIMenu(e) {
                                            this.menuRef[e] = null;
                                          }
                                          showMenu(e, t, s) {
                                            if (this.menuRef[e] && e === bt.b)
                                              this.showConvActionMenu(t, s);
                                          }
                                          hideMenu(e) {
                                            this.menuRef[e];
                                          }
                                          showConvActionMenu(e, t) {
                                            if (t && t.friendItem) return;
                                            if (
                                              t.userId ===
                                                w.CONV_FILTER.STRANGER ||
                                              t.userId === w.CONV_FILTER.MEDIA
                                            )
                                              return;
                                            const s = Object(p.a)({}, t),
                                              i = s.userId;
                                            if (s && !b.default.isFakeId(i)) {
                                              const e =
                                                  this.previewManager.getPreviewByIDSync(
                                                    i
                                                  ),
                                                t =
                                                  D.default.getProfileFriendByIdSync(
                                                    i
                                                  ) || {},
                                                a =
                                                  this.unreadDataManager.getUnreadByConvIdSync(
                                                    i
                                                  );
                                              (s.lastMessage =
                                                null == e ? void 0 : e.message),
                                                (s.isFr = t.isFr),
                                                (s.unreadMark =
                                                  null == a
                                                    ? void 0
                                                    : a.unreadMark),
                                                (s.smsUnreadCount =
                                                  null == a
                                                    ? void 0
                                                    : a.smsUnreadCount);
                                            }
                                            this.menuRef[bt.b].updateTargetInfo(
                                              s
                                            ),
                                              this.menuRef[bt.b].showAction(
                                                Object(p.a)({}, e)
                                              );
                                          }
                                          bindUIContainer(e) {
                                            this.convUIListContainer = e;
                                          }
                                          cleanUpUIContainer() {
                                            this.convUIListContainer = null;
                                          }
                                          getEnableArchivedChat() {
                                            return this.isEnableArchivedChat;
                                          }
                                          getListFilterSrc(e) {
                                            return this.typeFilterSrc ===
                                              Ct.FilterSrcType.UNREAD
                                              ? Ot.a.filterByUnread(e)
                                              : e;
                                          }
                                          setTypeFilterSrc(e) {
                                            if (
                                              this.typeFilterSrc !== e &&
                                              ((this.typeFilterSrc = e),
                                              this.applyTypeFilter(
                                                this.typeFilter,
                                                !0
                                              ),
                                              e === Ct.FilterSrcType.UNREAD)
                                            ) {
                                              const e =
                                                this.labelFilters.length > 0
                                                  ? 1453215
                                                  : 1453214;
                                              Z.e.logAction(e);
                                            }
                                          }
                                          genListArchivedChat(
                                            e,
                                            t,
                                            s,
                                            i = !0,
                                            a = !0
                                          ) {
                                            let n = [];
                                            (n = Ot.a.filterByLabel(
                                              this.getListFilterSrc(e),
                                              s
                                            )),
                                              s.length &&
                                                a &&
                                                this.typeFilterSrc !==
                                                  Ct.FilterSrcType.UNREAD &&
                                                this.addLikeConvToFilterListV2(
                                                  n,
                                                  s
                                                );
                                            let r = this.getListFilterSrc(
                                              this.listStrangers
                                            ).filter(
                                              (e) =>
                                                ((kt.a.isArchivedChat(e) &&
                                                  t) ||
                                                  (!kt.a.isArchivedChat(e) &&
                                                    !t)) &&
                                                !ae.a.isThreadHidden(e)
                                            );
                                            return (
                                              s.includes(bt.h) && 1 == s.length
                                                ? this.isMeBAAccount() ||
                                                  (r = Ot.a.filterByResponsed(
                                                    r,
                                                    !1
                                                  ))
                                                : s.includes(bt.h) ||
                                                  (r = Ot.a.filterByLabel(
                                                    r,
                                                    s
                                                  )),
                                              (n = n.filter(
                                                (e) =>
                                                  !(
                                                    this.typeFilter ===
                                                      Ct.FilterType.ARCHIVED ||
                                                    !r.length ||
                                                    e != w.CONV_FILTER.STRANGER
                                                  ) ||
                                                  (((kt.a.isArchivedChat(e) &&
                                                    t) ||
                                                    (!kt.a.isArchivedChat(e) &&
                                                      !t)) &&
                                                    e !==
                                                      w.CONV_FILTER.STRANGER &&
                                                    !Ot.a.isStrangerV2(e) &&
                                                    !ae.a.isThreadHidden(e))
                                              )),
                                              i &&
                                                (this.typeFilter ===
                                                Ct.FilterType.ARCHIVED
                                                  ? (n = n.concat(r))
                                                  : this.isMeBAAccount() ||
                                                    s.length
                                                  ? ((this.isMeBAAccount() &&
                                                      (null == s ||
                                                        !s.length)) ||
                                                      (null != s &&
                                                        s.length)) &&
                                                    (n = n.concat(r))
                                                  : (n =
                                                      this.addStrangersToVisible(
                                                        n,
                                                        r
                                                      ))),
                                              (n = n.filter(
                                                (e, t) => n.indexOf(e) == t
                                              )),
                                              this.safeSortConvList(
                                                n,
                                                this.typeFilterSrc ===
                                                  Ct.FilterSrcType.UNREAD
                                              )
                                            );
                                          }
                                          updateListArchivedChat() {
                                            this.typeFilter ==
                                            Ct.FilterType.FOCUSED
                                              ? this.onTypeFilterChange(
                                                  Ct.FilterType.FOCUSED,
                                                  !0
                                                )
                                              : this.typeFilter ==
                                                  Ct.FilterType.ARCHIVED &&
                                                this.onTypeFilterChange(
                                                  Ct.FilterType.ARCHIVED,
                                                  !0
                                                );
                                          }
                                          onOffArchivedChat(e) {
                                            if (!I.default.enable_archived_chat)
                                              return;
                                            const t =
                                              $e.default.getConvUXVersion();
                                            this.isEnableArchivedChat &&
                                              e &&
                                              "2" == t &&
                                              ((this.isEnableArchivedChat = !1),
                                              this.signalRenderState()),
                                              this.isEnableArchivedChat != e &&
                                                (e ||
                                                (this.typeFilter !==
                                                  Ct.FilterType.ARCHIVED &&
                                                  this.typeFilter !==
                                                    Ct.FilterType.FOCUSED)
                                                  ? e &&
                                                    this.onTypeFilterChange(
                                                      Ct.FilterType.FOCUSED,
                                                      !0
                                                    )
                                                  : this.onTypeFilterChange(
                                                      Ct.FilterType.ALL,
                                                      !0
                                                    ),
                                                this.labelDataManager.onClearFilter(),
                                                this.setTypeFilterSrc(
                                                  Ct.FilterSrcType.ALL
                                                ),
                                                (this.isEnableArchivedChat =
                                                  e && "3" == t),
                                                this.signalRenderState());
                                          }
                                          isShowUnreadArchivedChat() {
                                            return this.hasUnreadArchivedChat;
                                          }
                                          updateUnreadArchivedChat(e) {
                                            this.typeFilter !=
                                              Ct.FilterType.ARCHIVED &&
                                              (this.hasUnreadArchivedChat = e),
                                              this.signalRenderState();
                                          }
                                        })
                                      ) || St)
                                  ) || St)
                              ) || St)
                          ) || St)
                      ) || St)
                  ) || St)
              ) || St)
          ) || St)
      );
      var zt,
        xt = s("EYv5"),
        Vt = s("AtyM"),
        qt = s("R5gT"),
        Ht = s("Xzw3"),
        Kt = s("d+hT"),
        $t = s("uEOi"),
        Wt = s("rQsU"),
        Zt = s("4prX"),
        Qt = s("kTC5"),
        Yt = s("4wTQ"),
        Jt = s("ES/k");
      const Xt = {
          isFocusSearchBox: !1,
          isFocusOnRecentSearch: !1,
          searchText: "",
          searchResult: {},
          searching: !1,
          conversation: null,
          highlightId: "",
          filter: { timeFrom: 0, timeTo: Date.now() },
        },
        es = new b.LocalId();
      var ts;
      !(function (e) {
        (e[(e.STEP_CONTACT = 0)] = "STEP_CONTACT"),
          (e[(e.STEP_MESSAGES = 1)] = "STEP_MESSAGES"),
          (e[(e.STEP_FILES = 2)] = "STEP_FILES"),
          (e[(e.STEP_DIRECTORY = 3)] = "STEP_DIRECTORY");
      })(ts || (ts = {}));
      Object(B.b)(Ct.SearchController)(
        (zt =
          (function (e, t) {
            return a.ModuleContainer.inject(Wt.b)(e, void 0, 0);
          })(
            (zt =
              (function (e, t) {
                return a.ModuleContainer.inject(me.b)(e, void 0, 1);
              })(
                (zt =
                  (function (e, t) {
                    return a.ModuleContainer.inject(me.h)(e, void 0, 2);
                  })(
                    (zt =
                      Reflect.metadata(
                        "design:type",
                        Function
                      )(
                        (zt =
                          Reflect.metadata("design:paramtypes", [
                            void 0 === Wt.b ? Object : Wt.b,
                            void 0 === me.b ? Object : me.b,
                            void 0 === me.h ? Object : me.h,
                          ])(
                            (zt = class {
                              constructor(e, t, s) {
                                (this.convListController = e),
                                  (this.convDataManager = t),
                                  (this.previewDataManager = s),
                                  Object(i.a)(this, "state", void 0),
                                  Object(i.a)(this, "pageLoad", void 0),
                                  Object(i.a)(this, "curQuery", void 0),
                                  Object(i.a)(this, "cacheResSearch", void 0),
                                  Object(i.a)(this, "countQuery", void 0),
                                  Object(i.a)(
                                    this,
                                    "countTimeUseGlobalSearch",
                                    void 0
                                  ),
                                  Object(i.a)(
                                    this,
                                    "countSelectTopRes",
                                    void 0
                                  ),
                                  Object(i.a)(this, "cacheSearch", void 0),
                                  Object(i.a)(this, "trackSearch", void 0),
                                  Object(i.a)(
                                    this,
                                    "trackSearchVietnamese",
                                    void 0
                                  ),
                                  Object(i.a)(this, "lastTextSearch", void 0),
                                  Object(i.a)(this, "lastTextSearchTs", void 0),
                                  Object(i.a)(
                                    this,
                                    "isShowRecentSearch",
                                    void 0
                                  ),
                                  Object(i.a)(
                                    this,
                                    "isFirstLoadSuccess",
                                    void 0
                                  ),
                                  Object(i.a)(this, "searchDelay", void 0),
                                  Object(i.a)(
                                    this,
                                    "closeBySendingMsg",
                                    void 0
                                  ),
                                  Object(i.a)(this, "clearAdminMode", void 0),
                                  Object(i.a)(
                                    this,
                                    "timeouResetDataMsg",
                                    void 0
                                  ),
                                  Object(i.a)(this, "searchResultList", void 0),
                                  Object(i.a)(this, "recentSearchList", void 0),
                                  Object(i.a)(this, "searchInput", void 0),
                                  Object(i.a)(this, "loadingMore", void 0),
                                  Object(i.a)(this, "loadingMoreFiles", void 0),
                                  Object(i.a)(this, "oldestTime", void 0),
                                  Object(i.a)(
                                    this,
                                    "functionSearchByName",
                                    void 0
                                  ),
                                  Object(i.a)(this, "timeoutLog", void 0),
                                  Object(i.a)(this, "_sbc", null),
                                  Object(i.a)(
                                    this,
                                    "_removeSearchResult",
                                    (e, t) => {
                                      const s = this.getSearchState();
                                      if (
                                        s &&
                                        !s.conversation &&
                                        s.searchResult
                                      )
                                        if (t) {
                                          if (!s.searchResult.groups) return;
                                          const t = [...s.searchResult.groups];
                                          for (let i = 0; i < t.length; i++)
                                            if (t[i].userId == e) {
                                              t.splice(i, 1),
                                                this.updateState(
                                                  Object(p.a)(
                                                    Object(p.a)({}, s),
                                                    {},
                                                    {
                                                      searchResult: Object(p.a)(
                                                        Object(p.a)(
                                                          {},
                                                          s.searchResult
                                                        ),
                                                        {},
                                                        { groups: t }
                                                      ),
                                                    }
                                                  )
                                                );
                                              break;
                                            }
                                        } else {
                                          if (!s.searchResult.friends) return;
                                          const t = [...s.searchResult.friends];
                                          for (let i = 0; i < t.length; i++)
                                            if (t[i].userId == e) {
                                              t.splice(i, 1),
                                                this.updateState(
                                                  Object(p.a)(
                                                    Object(p.a)({}, s),
                                                    {},
                                                    {
                                                      searchResult: Object(p.a)(
                                                        Object(p.a)(
                                                          {},
                                                          s.searchResult
                                                        ),
                                                        {},
                                                        { friends: t }
                                                      ),
                                                    }
                                                  )
                                                );
                                              break;
                                            }
                                        }
                                    }
                                  ),
                                  Object(i.a)(
                                    this,
                                    "name",
                                    Ct.SEARCH_CONTROLLER
                                  ),
                                  Object(i.a)(this, "key", "windowId"),
                                  (this.state = Xt),
                                  (this.pageLoad = 0),
                                  (this.curQuery = ""),
                                  (this.countQuery = 0),
                                  (this.countTimeUseGlobalSearch = 0),
                                  (this.countSelectTopRes = 0),
                                  (this.cacheSearch = {
                                    items: [],
                                    keywords: null,
                                  }),
                                  (this.trackSearch = !1),
                                  (this.trackSearchVietnamese = !1),
                                  (this.lastTextSearch = ""),
                                  (this.lastTextSearchTs = 0),
                                  (this.isShowRecentSearch = !1),
                                  (this.searchDelay =
                                    this._getSearchDelaySetting()),
                                  (this.closeBySendingMsg = !1),
                                  (this.loadingMore = !1),
                                  (this.loadingMoreFiles = !1),
                                  (this.oldestTime = 0),
                                  (this.timeoutLog = null),
                                  (this.isFirstLoadSuccess = !1),
                                  (this._innerSearchFunc =
                                    this._innerSearchFunc.bind(this)),
                                  (this.functionSearchByName =
                                    b.default.throttle(
                                      this._innerSearchFunc,
                                      this.searchDelay
                                    )),
                                  (this.onKeywordChange =
                                    this.onKeywordChange.bind(this)),
                                  (this.loadMessagesV2 =
                                    this.loadMessagesV2.bind(this)),
                                  (this.loadMoreFiles =
                                    this.loadMoreFiles.bind(this)),
                                  (this.onKeyPressInput =
                                    this.onKeyPressInput.bind(this)),
                                  (this.onFocusInput =
                                    this.onFocusInput.bind(this)),
                                  (this.onBlurInput =
                                    this.onBlurInput.bind(this)),
                                  (this.onclickCloseSearchButton =
                                    this.onclickCloseSearchButton.bind(this)),
                                  (this.onClickClearSearch =
                                    this.onClickClearSearch.bind(this)),
                                  (this.onSearchKeyword =
                                    this.onSearchKeyword.bind(this)),
                                  (this.setRecentSearchFocusState =
                                    this.setRecentSearchFocusState.bind(this)),
                                  (this.focusSearchBox =
                                    this.focusSearchBox.bind(this)),
                                  (this.selectResult =
                                    this.selectResult.bind(this)),
                                  (this.onFileSelect =
                                    this.onFileSelect.bind(this)),
                                  (this.selectTopRes =
                                    this.selectTopRes.bind(this)),
                                  this.listenEvents();
                              }
                              get sidebarController() {
                                return (
                                  this._sbc ||
                                    (this._sbc = a.ModuleContainer.resolve(
                                      Ct.SidebarController
                                    )),
                                  this._sbc
                                );
                              }
                              listenEvents() {
                                _.default.subscribe((e, t) => {
                                  switch (e) {
                                    case y.SideBarActions.FOCUS_SEARCH_INPUT:
                                      this.focusSearchBox();
                                      break;
                                    case y.FetchActions.FRIENDS_REMOVED:
                                      this._removeSearchResult(t, !1);
                                      break;
                                    case y.FetchActions.GROUP_LEAVE:
                                      this._removeSearchResult(t, !0);
                                      break;
                                    case y.SideBarActions.SEARCH_FILE_DONE:
                                      this.updateState(
                                        Object(p.a)(
                                          Object(p.a)({}, this.state),
                                          {},
                                          { searching: !1 }
                                        )
                                      );
                                      break;
                                    case y.SideBarActions.CLEAR_SEARCH:
                                      this.clearSearch();
                                      break;
                                    case y.ConversationListActions
                                      .SELECT_CONVERSATION:
                                      setTimeout(() => {
                                        this.state.highlightId !== t.userId &&
                                          this.setRecentSearchFocusState(
                                            !1,
                                            !1,
                                            !0
                                          ),
                                          t.callPoint !== pe.a.JumpMessage &&
                                            this.updateStateOf(
                                              "highlightId",
                                              null == t ? void 0 : t.userId
                                            );
                                      }, 0);
                                  }
                                });
                              }
                              logSearch(e) {
                                ze.p.getDebugSearch().showLogSearchFlow;
                              }
                              updateState(e, t = !0) {
                                (this.state = e),
                                  t && Object(yt.g)(this.name, Ze.c);
                              }
                              isTextKey(e) {
                                return e.match(
                                  /^[a-zA-Z0-9!@#$%^&*)(+=._-|\\\[\]{}~`"\';:?/<>,-\s\n]$/
                                );
                              }
                              isMultipleKeyPressed(e) {
                                return e.ctrlKey || e.metaKey || e.altKey;
                              }
                              isKeywordStale(e) {
                                return (
                                  Jt.a.formatTextSearch(e) !==
                                  Jt.a.formatTextSearch(this.state.searchText)
                                );
                              }
                              bindUIList(e, t) {
                                this._updateListRef(e, t);
                              }
                              cleanUpUIList(e) {
                                this._updateListRef(e, null);
                              }
                              bindUISearchInput(e) {
                                this.searchInput = e;
                              }
                              cleanUpUISearchInput() {
                                this.searchInput = null;
                              }
                              _updateListRef(e, t) {
                                switch (e) {
                                  case Qt.c.SEARCH_RESULT:
                                    this.searchResultList = t;
                                    break;
                                  case Qt.c.RECENT_SEARCH:
                                    this.recentSearchList = t;
                                }
                              }
                              resetState() {
                                (this.searchInput.value = ""),
                                  this.updateState(Object(p.a)({}, Xt));
                              }
                              updateStateOf(e, t) {
                                this.state.hasOwnProperty(e) &&
                                  this.state[e] !== t &&
                                  ("searchText" === e &&
                                    (this.searchInput.value = t),
                                  this.updateState(
                                    Object(p.a)(
                                      Object(p.a)({}, this.state),
                                      {},
                                      { [e]: t }
                                    )
                                  ));
                              }
                              onKeyPressInput(e) {
                                if (
                                  (this._isSelectAllSearchText() &&
                                    this.searchResultList &&
                                    this.isTextKey(e.key) &&
                                    !this.isMultipleKeyPressed(e) &&
                                    (this.searchResultList.openTabAll(),
                                    this.searchResultList.resetContactList()),
                                  e.which == w.K_BACK_SPACE
                                    ? this.state &&
                                      this.state.searchText &&
                                      "" !== this.state.searchText &&
                                      Z.e.logAction(12307)
                                    : "" === this.state.searchText &&
                                      !this.timeoutLog &&
                                      this.isTextKey(e.key) &&
                                      (this.timeoutLog = setTimeout(() => {
                                        (this.timeoutLog = null),
                                          Z.e.logAction(1232002);
                                      }, 3e3)),
                                  e.which == w.K_ESC)
                                )
                                  !0 === this.isShowRecentSearch &&
                                    (this.updateState(
                                      Object(p.a)(
                                        Object(p.a)({}, this.state),
                                        {},
                                        {
                                          isFocusOnRecentSearch: !1,
                                          isFocusSearchBox: !1,
                                        }
                                      )
                                    ),
                                    this.searchInput && this.searchInput.blur(),
                                    this.onCloseSearch()),
                                    "" != this.searchInput.value
                                      ? this.clearSearch(!1)
                                      : this.clearSearch(!0);
                                else if (e.which == w.K_ENTER) {
                                  let e =
                                    this.searchResultList ||
                                    this.recentSearchList;
                                  if (e && this.state.searchText) {
                                    let t = e.selectFocusedConversation(!0);
                                    setTimeout(() => {
                                      this.state.conversation
                                        ? this.focusSearchBox()
                                        : ae.a.isThreadHidden(t) ||
                                          _.default.send(
                                            y.ChatBoxActions.FOCUS_INPUT,
                                            { userId: t, windowId: Ze.c }
                                          );
                                    }, 0);
                                  }
                                } else if (
                                  e.which == w.K_UP ||
                                  e.which == w.K_DOWN
                                ) {
                                  this.searchResultList && Z.e.logAction(12317);
                                  let t =
                                    this.searchResultList ||
                                    this.recentSearchList;
                                  t &&
                                    (e.stopPropagation(),
                                    e.preventDefault(),
                                    e.which == w.K_UP
                                      ? t.moveUp()
                                      : t.moveDown());
                                }
                              }
                              onKeywordChange(e, t) {
                                let s = "";
                                if (
                                  ((s = !e && t ? t : e.target.value),
                                  s &&
                                    (s = b.default.ZSafeFunction(
                                      () => s.normalize(),
                                      s
                                    )),
                                  this.countTimeUseGlobalSearch ||
                                    ((this.countTimeUseGlobalSearch =
                                      Vt.a.now()),
                                    (this.countSelectTopRes = 0)),
                                  s)
                                ) {
                                  const e = Jt.a.formatTextSearch(
                                      this.lastTextSearch
                                    ),
                                    t = Jt.a.formatTextSearch(s);
                                  b.default.log("searching: true"),
                                    I.default.stagingAccount &&
                                      this._checkOnAdminMode(s),
                                    this.trackSearch ||
                                      ((this.trackSearch = !0),
                                      Z.e.logAction(12318)),
                                    this.updateState(
                                      Object(p.a)(
                                        Object(p.a)({}, this.state),
                                        {},
                                        { searchText: s }
                                      )
                                    ),
                                    (this.countQuery = es.next()),
                                    this.functionSearchByName(
                                      s,
                                      this.countQuery,
                                      e !== t
                                    );
                                } else
                                  this._resetCacheResultSearch(),
                                    qt.a.abortSearch(),
                                    this.clearSearch(!1);
                              }
                              onFocusInput() {
                                this.searchInput &&
                                  "" !== this.searchInput.value &&
                                  this.searchInput.select(),
                                  this.updateState(
                                    Object(p.a)(
                                      Object(p.a)({}, this.state),
                                      {},
                                      { isFocusSearchBox: !0 }
                                    )
                                  ),
                                  Z.e.logAction(1232001);
                              }
                              onBlurInput() {
                                setTimeout(() => {
                                  this.updateState(
                                    Object(p.a)(
                                      Object(p.a)({}, this.state),
                                      {},
                                      { isFocusSearchBox: !1 }
                                    )
                                  ),
                                    this.searchInput &&
                                      "" == this.searchInput.value &&
                                      this.qosLogSearch();
                                }, 20);
                              }
                              onclickCloseSearchButton(e) {
                                this.setRecentSearchFocusState(!1),
                                  this.onCloseSearch(),
                                  this._resetCacheResultSearch(),
                                  this.clearSearch(!this.state.conversation),
                                  Z.e.logAction(1232003),
                                  e &&
                                    (e.stopPropagation(), e.preventDefault());
                              }
                              onClickClearSearch() {
                                ze.p.resetGlobalSearchMode(),
                                  this.state.conversation &&
                                    Z.e.logAction(12314),
                                  this._resetCacheResultSearch(),
                                  this.clearSearch(!this.state.conversation),
                                  this.focusSearchBox(),
                                  Z.e.logAction(1232006);
                              }
                              onSearchKeyword(e) {
                                "string" == typeof e &&
                                  this.searchInput &&
                                  ((this.searchInput.value = e),
                                  this.onKeywordChange(null, e),
                                  $t.a.addCacheKeyword(e));
                              }
                              onRemoveKeyword(e) {
                                "string" == typeof e &&
                                  $t.a.removeCacheKeyword(e);
                              }
                              onFileSelect(e) {
                                null != e &&
                                  e.msgId &&
                                  (this.updateStateOf("highlightId", e.msgId),
                                  this.state.searchText &&
                                    $t.a.addCacheKeyword(
                                      this.state.searchText
                                    ));
                              }
                              setRecentSearchFocusState(e, t = !1, s = !1) {
                                if (!s) {
                                  const t =
                                    this.sidebarController.getSelectedId();
                                  if (
                                    this.state.isFocusOnRecentSearch === e ||
                                    (t && this.state.highlightId === t && !e)
                                  )
                                    return;
                                }
                                (this.state.isFocusOnRecentSearch = e),
                                  e && (this.closeBySendingMsg = !1),
                                  Object(yt.g)(this.name, Ze.c);
                              }
                              onCloseSearch() {
                                var e, t;
                                Z.e.logAction(1232004),
                                  0 ==
                                    (null === (e = this.state.searchResult) ||
                                    void 0 === e ||
                                    null === (t = e.messages) ||
                                    void 0 === t
                                      ? void 0
                                      : t.length) && Z.e.logAction(1232202),
                                  this.qosLogSearch();
                              }
                              focusSearchBox(e = !1) {
                                this.searchInput &&
                                  (this.searchInput.focus(),
                                  e &&
                                    setTimeout(() => {
                                      this.searchInput.select();
                                    }, 0));
                              }
                              openRecentSearch() {
                                this.searchInput
                                  ? this.searchInput.focus()
                                  : this.setRecentSearchFocusState(!0);
                              }
                              loadMessagesV2(e, t = !1, s) {
                                let i = this.state.searchResult,
                                  a = "",
                                  n = e;
                                if (!this.state.searchText) return;
                                a = this.state.searchText;
                                let r = this.state,
                                  o = !1;
                                t ||
                                  ((r = Object(p.a)(
                                    Object(p.a)({}, this.state),
                                    {},
                                    {
                                      searchResult: Object(p.a)(
                                        Object(p.a)(
                                          {},
                                          this.state.searchResult
                                        ),
                                        {},
                                        { messages: null }
                                      ),
                                    }
                                  )),
                                  (o = !0));
                                const c = () =>
                                    this.state.filter.timeFrom != n.timeFrom ||
                                    this.state.filter.timeTo != n.timeTo ||
                                    !(
                                      !this.state.searchText ||
                                      !this.isKeywordStale(a)
                                    ),
                                  l =
                                    !this.loadingMore &&
                                    this.isFirstLoadSuccess &&
                                    !!i &&
                                    !!i.messages;
                                if (!t || l) {
                                  this.logSearch(
                                    `[Search flow] load more msg: ${a}, ${this.pageLoad}`
                                  ),
                                    this.updateState(
                                      Object(p.a)(
                                        Object(p.a)({}, r),
                                        {},
                                        {
                                          filter: {
                                            timeFrom: e.timeFrom,
                                            timeTo: e.timeTo,
                                          },
                                        }
                                      ),
                                      o
                                    ),
                                    (this.loadingMore = !0);
                                  const i = [],
                                    n = (e, n = !1) => {
                                      var r;
                                      let o = [];
                                      if (
                                        ((this.loadingMore = !1),
                                        this.logSearch(
                                          `[Search flow] load more msg res: ${a}, ${
                                            null === (r = e.arr) || void 0 === r
                                              ? void 0
                                              : r.length
                                          }`
                                        ),
                                        c())
                                      )
                                        return (
                                          this.pageLoad++,
                                          void (s && s(null, -1))
                                        );
                                      if (e && e.listConv && e.arr) {
                                        this.convListController
                                          .getRecentContacts()
                                          .forEach((t) => {
                                            let s = e.listConv.indexOf(
                                              t.userId
                                            );
                                            if (
                                              s >= 0 &&
                                              !ae.a.isThreadHidden(t.userId)
                                            )
                                              for (
                                                let i = s;
                                                i < e.listConv.length;
                                                ++i
                                              )
                                                e.listConv[i] == t.userId &&
                                                  (e.arr[i].conversation = t);
                                          }),
                                          e.arr.forEach((e) => {
                                            Object.keys(e.conversation).length >
                                              1 && o.push(e);
                                          }),
                                          Array.prototype.push.apply(i, o),
                                          n && t && i.length && this.pageLoad++,
                                          c() ||
                                            (!this.isFirstLoadSuccess && t) ||
                                            (this.state.searchResult.messages &&
                                              (o =
                                                this.state.searchResult.messages.concat(
                                                  o
                                                )),
                                            this.updateState(
                                              Object(p.a)(
                                                Object(p.a)({}, this.state),
                                                {},
                                                {
                                                  searchResult: Object(p.a)(
                                                    Object(p.a)(
                                                      {},
                                                      this.state.searchResult
                                                    ),
                                                    {},
                                                    { messages: o }
                                                  ),
                                                  searching: !1,
                                                }
                                              )
                                            ),
                                            s && n && s(i, this.pageLoad));
                                      }
                                    };
                                  qt.a
                                    .searchGlobalMessagesV3(
                                      a,
                                      c,
                                      void 0,
                                      n,
                                      I.default.limit_result_msg_search + 1,
                                      e
                                    )
                                    .then((e) => n(e, !0))
                                    .catch((e) => {
                                      (this.loadingMore = !1),
                                        this.logSearch(
                                          `[Search flow] load more msg err: ${a}, ${e}`
                                        ),
                                        s && s(null, -1),
                                        b.default.logCoreError(
                                          "searchGlobalMsg v2 " + e
                                        );
                                    });
                                } else s && s(null, -1);
                              }
                              loadMoreMessages() {
                                let e = this.state.searchResult;
                                if (
                                  e &&
                                  e.rawSearchResult &&
                                  e.messageList &&
                                  e.rawSearchResult.length > e.lastOffset &&
                                  !this.loadingMore
                                ) {
                                  this.loadingMore = !0;
                                  const t = this.state.conversation.userId;
                                  qt.a
                                    .getMessageOfConversation(
                                      e.rawSearchResult,
                                      this.state.conversation.userId,
                                      20,
                                      e.lastOffset
                                    )
                                    .then((s) => {
                                      let i = s.list;
                                      if (
                                        this.state.conversation &&
                                        t == this.state.conversation.userId
                                      ) {
                                        let t = b.default.ZSafeFunction(
                                          () =>
                                            Math.max(
                                              0,
                                              e.rawSearchResult.length -
                                                e.lastOffset -
                                                20
                                            ) +
                                            e.messageList.length +
                                            i.length,
                                          s.len
                                        );
                                        i.length > 0
                                          ? this.updateState(
                                              Object(p.a)(
                                                Object(p.a)({}, this.state),
                                                {},
                                                {
                                                  searchResult: Object(p.a)(
                                                    Object(p.a)(
                                                      {},
                                                      this.state.searchResult
                                                    ),
                                                    {},
                                                    {
                                                      messageList:
                                                        this.state.searchResult.messageList.concat(
                                                          i.map((e) => ({
                                                            message: e,
                                                            conversation:
                                                              this.state
                                                                .conversation,
                                                          }))
                                                        ),
                                                      realLen: t,
                                                      lastOffset:
                                                        this.state.searchResult
                                                          .lastOffset + 20,
                                                    }
                                                  ),
                                                }
                                              )
                                            )
                                          : this.state &&
                                            this.state.searchResult &&
                                            (this.state.searchResult.realLen !==
                                            t
                                              ? this.updateState(
                                                  Object(p.a)(
                                                    Object(p.a)({}, this.state),
                                                    {},
                                                    {
                                                      searchResult: Object(p.a)(
                                                        Object(p.a)(
                                                          {},
                                                          this.state
                                                            .searchResult
                                                        ),
                                                        {},
                                                        {
                                                          realLen: t,
                                                          lastOffset:
                                                            e.lastOffset + 20,
                                                        }
                                                      ),
                                                    }
                                                  )
                                                )
                                              : (this.state.searchResult.lastOffset += 20));
                                      }
                                      this.loadingMore = !1;
                                    });
                                }
                              }
                              loadMoreFiles() {
                                let e = this.state.searchResult,
                                  t = this.state.searchText;
                                var s;
                                e &&
                                  e.rawFileResult &&
                                  e.files &&
                                  e.rawFileResult.length > e.lastFileOffset &&
                                  !this.loadingMoreFiles &&
                                  ((this.loadingMoreFiles = !0),
                                  null ===
                                    (s = a.ModuleContainer.resolve(xt.a)) ||
                                    void 0 === s ||
                                    s
                                      .getMultiMedias(
                                        "file",
                                        e.rawFileResult.slice(
                                          e.lastFileOffset,
                                          e.lastFileOffset + 20
                                        )
                                      )
                                      .then((s) => {
                                        if (
                                          ((this.loadingMoreFiles = !1),
                                          this.isKeywordStale(t))
                                        )
                                          return;
                                        e = this.state.searchResult;
                                        const i = s.filter(Boolean);
                                        let a = b.default.ZSafeFunction(
                                            () =>
                                              Math.max(
                                                0,
                                                e.rawFileResult.length -
                                                  e.lastFileOffset -
                                                  20
                                              ) +
                                              e.files.length +
                                              i.length,
                                            e.realFileLen
                                          ),
                                          n =
                                            this.state.searchResult.files.concat(
                                              i
                                            );
                                        n.sort(
                                          (e, t) =>
                                            parseInt(t.sendDttm) -
                                            parseInt(e.sendDttm)
                                        ),
                                          this.updateState(
                                            Object(p.a)(
                                              Object(p.a)({}, this.state),
                                              {},
                                              {
                                                searchResult: Object(p.a)(
                                                  Object(p.a)(
                                                    {},
                                                    this.state.searchResult
                                                  ),
                                                  {},
                                                  {
                                                    files: n,
                                                    realFileLen: a,
                                                    lastFileOffset:
                                                      e.lastFileOffset + 20,
                                                  }
                                                ),
                                              }
                                            )
                                          );
                                      })
                                      .catch((e) => {
                                        (this.loadingMoreFiles = !1),
                                          b.default.logCoreError(
                                            "_loadMoreFiles ",
                                            e
                                          );
                                      }));
                              }
                              qosLogSearch() {
                                this.countTimeUseGlobalSearch &&
                                  (Zt.default.increaseSuccess(
                                    97111,
                                    0,
                                    Vt.a.now() - this.countTimeUseGlobalSearch
                                  ),
                                  (this.countTimeUseGlobalSearch = 0)),
                                  this.countSelectTopRes >= 0 &&
                                    (Zt.default.increaseSuccess(
                                      97112,
                                      0,
                                      this.countSelectTopRes
                                    ),
                                    (this.countSelectTopRes = -1));
                              }
                              selectTopRes() {
                                this.countSelectTopRes >= 0 &&
                                  this.countSelectTopRes++;
                              }
                              selectResult(e, t = !1, s = !1, i = !1) {
                                var a;
                                const n = this.state.searchText;
                                let r = !!this.state.conversation;
                                Yt.a
                                  .jumpToMessage(
                                    e.message,
                                    null === (a = e.conversation) ||
                                      void 0 === a
                                      ? void 0
                                      : a.userId,
                                    vt.f
                                  )
                                  .then((t) => {
                                    const { groupMsgs: s = [] } = t;
                                    let i = null;
                                    b.default.ZSafeFunction(() => {
                                      if (s)
                                        for (let t = 0; t < s.length; t++)
                                          if (s[t].msgId == e.message.msgId)
                                            return (
                                              (i = Object(p.a)({}, s[t])),
                                              void (i.searchKeyWord = n)
                                            );
                                    }, null),
                                      this.state.searchText &&
                                        $t.a.addCacheKeyword(
                                          this.state.searchText
                                        ),
                                      _.default.send(
                                        y.ChatBoxActions
                                          .OPEN_CONV_JUMP_TO_MESSAGE_SEARCH,
                                        {
                                          messages: s,
                                          focusId: ["" + e.message.msgId],
                                          conversation: e.conversation,
                                        }
                                      ),
                                      i &&
                                        Object(vt.f)({
                                          type: y.ChatBoxActions
                                            .UPDATE_MESSAGE_ATTRIBUTES,
                                          payload: i,
                                        });
                                  })
                                  .catch((t) => {
                                    b.default.logCoreError(t),
                                      Dt.a.createWarning(
                                        jt.default.str("STR_MESSAGE_NOT_FOUND")
                                      ),
                                      i ||
                                        _.default.send(
                                          y.ChatBoxActions
                                            .OPEN_CONV_JUMP_TO_MESSAGE_SEARCH,
                                          {
                                            messages: [],
                                            focusId: [],
                                            conversation: e.conversation,
                                          }
                                        );
                                  }),
                                  r
                                    ? (s && this.focusSearchBox(),
                                      this.updateState(
                                        Object(p.a)(
                                          Object(p.a)({}, this.state),
                                          {},
                                          { highlightId: e.message.msgId }
                                        )
                                      ))
                                    : t ||
                                      this.updateState(
                                        Object(p.a)(
                                          Object(p.a)({}, this.state),
                                          {},
                                          { highlightId: e.message.msgId }
                                        )
                                      );
                              }
                              getRecentSearchItems() {
                                if (0 === I.default.recent_search.is_enable)
                                  return [];
                                let e = $t.a.getLocalRecentSearchList();
                                if (!e) return [];
                                let t = ne.default.getGroupsListSync(),
                                  s = t || [];
                                return (
                                  (e = e.filter((e) => {
                                    if (
                                      e &&
                                      e.userId &&
                                      !ae.a.isThreadHidden(e.userId)
                                    ) {
                                      if (
                                        e.userId.startsWith(w.GROUPID_PREFIX) ||
                                        1 === e.type
                                      ) {
                                        let t = !1;
                                        1 !== e.type ||
                                          e.userId.startsWith(
                                            w.GROUPID_PREFIX
                                          ) ||
                                          (e.userId =
                                            w.GROUPID_PREFIX + e.userId);
                                        for (let i of s)
                                          if (
                                            i.userId &&
                                            e.userId == i.userId
                                          ) {
                                            t = !0;
                                            break;
                                          }
                                        return (
                                          !!t ||
                                          ($t.a.removeLocalRecentSearchList(
                                            e.userId
                                          ),
                                          !1)
                                        );
                                      }
                                      return !0;
                                    }
                                    return !1;
                                  })),
                                  e
                                );
                              }
                              getCacheRecentSearch() {
                                return (
                                  (this.cacheSearch.items =
                                    this.getRecentSearchItems()),
                                  I.default.sync_recent_search.enable_kw &&
                                    (this.cacheSearch.keywords =
                                      $t.a.getLocalKeywordList()),
                                  this.cacheSearch
                                );
                              }
                              getPageLoad() {
                                return this.pageLoad;
                              }
                              getSearchInputRef() {
                                return this.searchInput;
                              }
                              getSearchState() {
                                return this.state;
                              }
                              clearSearch(e = !0) {
                                if (
                                  (this._resetCacheResultSearch(),
                                  (this.searchInput.value = ""),
                                  (this.lastTextSearch = ""),
                                  e)
                                ) {
                                  if (
                                    (Ht.b.setMode(Ht.a.NORMAL),
                                    this.updateState(Object(p.a)({}, Xt)),
                                    this.sidebarController.getState(Ze.c)
                                      .currentTab == Ct.SidebarTab.FILE_TAB)
                                  )
                                    return void this.functionSearchByName(
                                      null,
                                      this.countQuery,
                                      !0
                                    );
                                } else
                                  this.updateState(
                                    Object(p.a)(
                                      Object(p.a)({}, this.state),
                                      {},
                                      {
                                        searchText: "",
                                        searching: !0,
                                        highlightId: "",
                                      }
                                    )
                                  ),
                                    this.functionSearchByName(
                                      "",
                                      this.countQuery,
                                      !0
                                    );
                              }
                              _resetCacheResultSearch() {
                                (this.curQuery = ""),
                                  (this.cacheResSearch = null),
                                  (this.trackSearch = !1),
                                  (this.trackSearchVietnamese = !1);
                              }
                              _checkOnAdminMode(e) {
                                let t = this.__checkOnAdminMode(e);
                                t &&
                                  (1 === t
                                    ? (this.clearAdminMode &&
                                        clearTimeout(this.clearAdminMode),
                                      (I.default.adminMode = !0),
                                      this.sidebarController.togglePerfTab(!0),
                                      (this.clearAdminMode = setTimeout(() => {
                                        (this.clearAdminMode = void 0),
                                          (I.default.adminMode = void 0),
                                          this.sidebarController.togglePerfTab();
                                      }, 216e5)))
                                    : 2 === t &&
                                      (this.clearAdminMode &&
                                        (clearTimeout(this.clearAdminMode),
                                        (this.clearAdminMode = void 0)),
                                      (I.default.adminMode = !1),
                                      this.sidebarController.togglePerfTab(
                                        !1
                                      )));
                              }
                              __checkOnAdminMode(e) {
                                if (
                                  e &&
                                  "string" == typeof e &&
                                  e.startsWith("$##")
                                ) {
                                  return e.substring(3) === I.default.zAminKey
                                    ? 1
                                    : 2;
                                }
                                return 0;
                              }
                              _innerSearchFunc(e, t, s = !0) {
                                if (!es.valid(t)) return;
                                if (
                                  this.sidebarController.getState(Ze.c)
                                    .currentTab === Ct.SidebarTab.FILE_TAB
                                )
                                  _.default.send(y.SideBarActions.SEARCH_FILE, {
                                    term: e,
                                  });
                                else if (this.state.conversation)
                                  this.filterByConversation(
                                    e,
                                    this.state.conversation
                                  );
                                else {
                                  const t =
                                      s &&
                                      this.isKeywordStale(this.lastTextSearch),
                                    a = Jt.a.formatTextSearch(e);
                                  var i;
                                  if (
                                    (this.logSearch(
                                      `[Search flow] start search-------: ${t}, ${a}`
                                    ),
                                    !a)
                                  )
                                    null === (i = this.searchResultList) ||
                                      void 0 === i ||
                                      i.forceStopSearch(),
                                      this.updateState(
                                        Object(p.a)(
                                          Object(p.a)({}, this.state),
                                          {},
                                          {
                                            searchResult: Object(p.a)(
                                              Object(p.a)(
                                                {},
                                                this.state.searchResult
                                              ),
                                              {},
                                              {
                                                messages: null,
                                                files: [],
                                                rawFileResult: [],
                                              }
                                            ),
                                          }
                                        )
                                      );
                                  this._searchGlobal(e, t);
                                }
                              }
                              _searchGlobal(e, t = !0) {
                                var s, i, n, r, o, c;
                                (this.lastTextSearchTs = Date.now()),
                                  (this.lastTextSearch = e);
                                let l = 2,
                                  d = 0,
                                  h = {},
                                  u = this.convDataManager.getAllConvSync(),
                                  g =
                                    this.previewDataManager.getAllPreviewsSync(),
                                  m = b.default.simpleStripVietnamese(e, !1);
                                const v = (s, i) => {
                                    s !== ts.STEP_DIRECTORY &&
                                      s !== ts.STEP_FILES &&
                                      l--;
                                    let a,
                                      n =
                                        1 == l &&
                                        s === ts.STEP_CONTACT &&
                                        0 == d;
                                    if (
                                      ((a = !!(l > 1 || n)),
                                      this.updateState(
                                        Object(p.a)(
                                          Object(p.a)({}, this.state),
                                          {},
                                          { searchResult: i, searching: a }
                                        )
                                      ),
                                      s === ts.STEP_CONTACT &&
                                        t &&
                                        (S(),
                                        I.default.tabbedGlobalSearchResult &&
                                          Ht.b.setMode(Ht.a.SEARCHING),
                                        I.default.enableFileGlobalSearch &&
                                          _()),
                                      0 == l && !this.isKeywordStale(e))
                                    ) {
                                      let e =
                                        Date.now() - this.lastTextSearchTs;
                                      e > 2e3
                                        ? this._upSearchDelay()
                                        : e < 600 && this._downSearchDelay();
                                    }
                                  },
                                  f = () => !!this.isKeywordStale(e),
                                  _ = () => {
                                    if (
                                      I.default.adminConfig &&
                                      I.default.adminConfig
                                        .offglobalSearchMessage
                                    )
                                      return setTimeout(() => {
                                        this.state &&
                                          !this.isKeywordStale(e) &&
                                          v(
                                            ts.STEP_FILES,
                                            this.state.searchResult
                                          );
                                      }, 100);
                                    const t = (t) => {
                                      var s, i, n;
                                      if (this.isKeywordStale(e)) return;
                                      let r = new Set(),
                                        o = [];
                                      var c, l;
                                      if (
                                        (t.forEach((e) => {
                                          e.msgId &&
                                            !r.has(e.msgId) &&
                                            (r.add(e.msgId), o.push(e.msgId));
                                        }),
                                        (null ===
                                          (s = this.state.searchResult) ||
                                        void 0 === s ||
                                        null === (i = s.rawFileResult) ||
                                        void 0 === i
                                          ? void 0
                                          : i.length) >= 20 &&
                                          (null == o ? void 0 : o.length) >=
                                            20) &&
                                        (null ===
                                          (c = this.state.searchResult) ||
                                        void 0 === c
                                          ? void 0
                                          : c.rawFileResult[0]) == o[0] &&
                                        (null ===
                                          (l = this.state.searchResult) ||
                                        void 0 === l
                                          ? void 0
                                          : l.rawFileResult[19]) == o[19]
                                      )
                                        return void this.updateState(
                                          Object(p.a)(
                                            Object(p.a)({}, this.state),
                                            {},
                                            {
                                              searchResult: Object(p.a)(
                                                Object(p.a)(
                                                  {},
                                                  this.state.searchResult
                                                ),
                                                {},
                                                {
                                                  rawFileResult: o,
                                                  realFileLen: o.length,
                                                }
                                              ),
                                            }
                                          ),
                                          !1
                                        );
                                      const h = o.slice(0, 20);
                                      null ===
                                        (n = a.ModuleContainer.resolve(xt.a)) ||
                                        void 0 === n ||
                                        n
                                          .getMultiMedias("file", h)
                                          .then((t) => {
                                            if (this.isKeywordStale(e)) return;
                                            let s = [],
                                              i = 0,
                                              a = 0;
                                            for (const e of t)
                                              e ? (s.push(e), i++) : a++;
                                            s.sort(
                                              (e, t) =>
                                                parseInt(t.sendDttm) -
                                                parseInt(e.sendDttm)
                                            );
                                            let n = this.state.searchResult;
                                            b.default.log(
                                              "search files: cur = " +
                                                n.searchKey +
                                                " this query = " +
                                                e,
                                              s.length
                                            ),
                                              (n = n ? Object(p.a)({}, n) : {}),
                                              (n.files = s),
                                              (n.realFileLen = o.length - a),
                                              (n.rawFileResult = o),
                                              (n.lastFileOffset = h.length),
                                              (n.searchKey = e),
                                              (d += i),
                                              v(ts.STEP_FILES, n);
                                          })
                                          .catch((t) => {
                                            b.default.logCoreError(
                                              "doSearchFiles " + t
                                            ),
                                              this.state &&
                                                !this.isKeywordStale(e) &&
                                                v(
                                                  ts.STEP_FILES,
                                                  this.state.searchResult
                                                );
                                          });
                                    };
                                    qt.a
                                      .search(
                                        e,
                                        null,
                                        { msgType: w.MSG_FILE },
                                        t,
                                        { enableReject: !0 }
                                      )
                                      .then(t)
                                      .catch((e) => {
                                        (this.state.searchResult.files &&
                                          this.state.searchResult.files
                                            .length) ||
                                          this.updateState(
                                            Object(p.a)(
                                              Object(p.a)({}, this.state),
                                              {},
                                              {
                                                searchResult: Object(p.a)(
                                                  Object(p.a)(
                                                    {},
                                                    this.state.searchResult
                                                  ),
                                                  {},
                                                  { files: [] }
                                                ),
                                              }
                                            ),
                                            !0
                                          );
                                      });
                                  },
                                  S = () => {
                                    if (
                                      I.default.adminConfig &&
                                      I.default.adminConfig
                                        .offglobalSearchMessage
                                    )
                                      return setTimeout(() => {
                                        this.state &&
                                          !this.isKeywordStale(e) &&
                                          v(
                                            ts.STEP_MESSAGES,
                                            this.state.searchResult
                                          );
                                      }, 100);
                                    this.logSearch(
                                      `[Search flow] search msg: ${e}`
                                    );
                                    Date.now();
                                    const t = (t, s = !1) => {
                                      var a;
                                      if (
                                        (this.logSearch(
                                          `[Search flow] search msg res first load: ${e}, ${
                                            null === (a = t.arr) || void 0 === a
                                              ? void 0
                                              : a.length
                                          }`
                                        ),
                                        (this.pageLoad = 0),
                                        this.timeouResetDataMsg &&
                                          (clearTimeout(
                                            this.timeouResetDataMsg
                                          ),
                                          (this.timeouResetDataMsg = !1),
                                          this.updateState(
                                            Object(p.a)(
                                              Object(p.a)({}, this.state),
                                              {},
                                              {
                                                searchResult: Object(p.a)(
                                                  Object(p.a)(
                                                    {},
                                                    this.state.searchResult
                                                  ),
                                                  {},
                                                  { messages: null }
                                                ),
                                              }
                                            ),
                                            !1
                                          )),
                                        !this.isKeywordStale(e) && t)
                                      ) {
                                        let a = [],
                                          r = 0;
                                        t &&
                                          t.listConv &&
                                          t.arr &&
                                          u.forEach((e) => {
                                            let s = t.listConv.indexOf(
                                              e.userId
                                            );
                                            if (
                                              s >= 0 &&
                                              !ae.a.isThreadHidden(e.userId)
                                            )
                                              for (
                                                let i = s;
                                                i < t.listConv.length;
                                                ++i
                                              )
                                                t.listConv[i] == e.userId &&
                                                  ((t.arr[i].conversation = e),
                                                  (r += 1),
                                                  a.push(t.arr[i]));
                                          });
                                        let o = this.state.searchResult,
                                          c = a;
                                        var n;
                                        if (
                                          (o.messages &&
                                            ((c = o.messages.slice()),
                                            Array.prototype.push.apply(c, a)),
                                          c.sort(
                                            (e, t) =>
                                              parseInt(t.message.sendDttm) -
                                              parseInt(e.message.sendDttm)
                                          ),
                                          (o = o ? Object(p.a)({}, o) : {}),
                                          (o.messages = c),
                                          (o.searchKey = e),
                                          (d += r),
                                          s)
                                        )
                                          (this.isFirstLoadSuccess = !0),
                                            this.searchResultList &&
                                              i &&
                                              this.searchResultList.updateFirstLoadPos(
                                                i.timeFrom
                                              ),
                                            b.default.logCoreError(
                                              "[Global search] check First data",
                                              e,
                                              null ===
                                                (n =
                                                  this.state.searchResult
                                                    .messages) || void 0 === n
                                                ? void 0
                                                : n.length
                                            );
                                        else if (!a.length) return;
                                        v(ts.STEP_MESSAGES, o);
                                      }
                                    };
                                    let s = null;
                                    this.searchResultList &&
                                      (!this.timeouResetDataMsg &&
                                        this.state.searchResult.messages &&
                                        (this.timeouResetDataMsg = setTimeout(
                                          () => {
                                            (this.timeouResetDataMsg = !1),
                                              this.updateState(
                                                Object(p.a)(
                                                  Object(p.a)({}, this.state),
                                                  {},
                                                  {
                                                    searchResult: Object(p.a)(
                                                      Object(p.a)(
                                                        {},
                                                        this.state.searchResult
                                                      ),
                                                      {},
                                                      { messages: null }
                                                    ),
                                                  }
                                                )
                                              ),
                                              this.searchResultList &&
                                                this.searchResultList.resetDataSearch();
                                          },
                                          1e3
                                        )),
                                      this.searchResultList.resetDataSearch(),
                                      (s =
                                        this.searchResultList.quickLoadData()),
                                      this.updateState(
                                        Object(p.a)(
                                          Object(p.a)({}, this.state),
                                          {},
                                          {
                                            filter: {
                                              timeFrom: s.timeFrom,
                                              timeTo: s.timeTo,
                                            },
                                          }
                                        ),
                                        !1
                                      ));
                                    const i = Object(p.a)({}, s);
                                    this.updateState(
                                      Object(p.a)(
                                        Object(p.a)({}, this.state),
                                        {},
                                        {
                                          searching: !0,
                                          highlightId: "",
                                          searchResult: Object(p.a)(
                                            Object(p.a)(
                                              {},
                                              this.state.searchResult
                                            ),
                                            {},
                                            {
                                              messages:
                                                !this.lastTextSearch ||
                                                e.length <
                                                  this.lastTextSearch.length
                                                  ? null
                                                  : this.state.searchResult
                                                      .messages,
                                            }
                                          ),
                                        }
                                      )
                                    ),
                                      (this.loadingMore = !1),
                                      (this.isFirstLoadSuccess = !1),
                                      qt.a
                                        .searchGlobalMessagesV3(
                                          e,
                                          () =>
                                            this.state.filter.timeFrom !=
                                              i.timeFrom ||
                                            this.state.filter.timeTo !=
                                              i.timeTo ||
                                            f(),
                                          void 0,
                                          t,
                                          I.default.limit_result_msg_search + 1,
                                          s
                                        )
                                        .then((e) => t(e, !0))
                                        .catch((t) => {
                                          if (
                                            (this.logSearch(
                                              `[Search flow] search msg fail: ${t}`
                                            ),
                                            b.default.logCoreError(
                                              "searchGlobalMsg " + t
                                            ),
                                            this.state &&
                                              !this.isKeywordStale(e))
                                          ) {
                                            this.searchResultList &&
                                              this.searchResultList.forceStopSearch(),
                                              this.timeouResetDataMsg &&
                                                (clearTimeout(
                                                  this.timeouResetDataMsg
                                                ),
                                                (this.timeouResetDataMsg = !1));
                                            let e = this.state.searchResult;
                                            (e.messages = []),
                                              v(ts.STEP_MESSAGES, e);
                                          }
                                        });
                                  };
                                if (
                                  (this.curQuery &&
                                    0 !== e.indexOf(this.curQuery) &&
                                    this._resetCacheResultSearch(),
                                  !this.cacheResSearch)
                                ) {
                                  const e = (e) => {
                                    for (const t of e) {
                                      const e = t.userId || t.convId;
                                      t &&
                                        !h[e] &&
                                        (t.userId || (t.userId = e),
                                        t.infoSearch && delete t.infoSearch,
                                        t.isDirectory && delete t.isDirectory,
                                        (h[e] = t));
                                    }
                                  };
                                  g.length && e(g),
                                    e(D.default.getFriendsSync()),
                                    e(ne.default.getGroupsListSync());
                                }
                                Kt.a
                                  .search(
                                    e,
                                    this.cacheResSearch
                                      ? this.cacheResSearch
                                      : h,
                                    {
                                      hasSection: !0,
                                      suggestGroupWithMember: !0,
                                      searchFriendInGroup: !0,
                                      isCalc: !0,
                                      updateLastChat: !this.cacheResSearch,
                                      searchPb: !0,
                                      searchZName: !0,
                                      searchNumPhone: !0,
                                      filterHidden: ae.a.isKeyPIN(e),
                                    }
                                  )
                                  .then((t) => {
                                    let s = this.state.searchResult;
                                    if (!this.isKeywordStale(e)) {
                                      {
                                        var i;
                                        let a = [];
                                        if (ae.a.isKeyPIN(e)) {
                                          Z.e.logAction(1970601);
                                          const e = ae.a.getUidsHiddenChat();
                                          if (e.length)
                                            for (let t of e) {
                                              let e = !1;
                                              for (let s of u)
                                                if (s && s.userId == t) {
                                                  a.push(
                                                    Object(p.a)(
                                                      Object(p.a)({}, s),
                                                      {},
                                                      { infoSearch: {} }
                                                    )
                                                  ),
                                                    (e = !0);
                                                  break;
                                                }
                                              if (!e) {
                                                let e = null;
                                                (e = t.startsWith(
                                                  w.GROUPID_PREFIX
                                                )
                                                  ? ne.default.getGroupByIdSync(
                                                      t
                                                    )
                                                  : D.default.getProfileFriendSync(
                                                      t
                                                    )),
                                                  e &&
                                                    (e.lastMessageTime ||
                                                      (e.lastMessageTime = 0),
                                                    a.push(
                                                      Object(p.a)(
                                                        Object(p.a)({}, e),
                                                        {},
                                                        { infoSearch: {} }
                                                      )
                                                    ));
                                              }
                                            }
                                        }
                                        this.curQuery || (this.curQuery = e),
                                          !this.cacheResSearch &&
                                            t.orderAll &&
                                            t.orderAll.constructor == Array &&
                                            t.orderAll.length > 0 &&
                                            (this.cacheResSearch = h),
                                          null !== (i = t.phone) &&
                                            void 0 !== i &&
                                            i.length &&
                                            (t.phone = t.phone.filter(
                                              (e) => e.userId
                                            )),
                                          (s = s ? Object(p.a)({}, s) : {}),
                                          (s.recentChat = t.recentChat),
                                          (s.groups = t.groups),
                                          (s.friends = t.friends),
                                          (s.oa = t.oa),
                                          (s.directory = t.directory),
                                          (s.searchKey = e),
                                          (s.phone = t.phone),
                                          (s.hiddenChat = a),
                                          (s.all = t.all),
                                          (s.orderAll = t.orderAll),
                                          (d +=
                                            (s.groups ? s.groups.length : 0) +
                                            (s.friends ? s.friends.length : 0) +
                                            (s.oa ? s.oa.length : 0)),
                                          (d +=
                                            (s.recentChat
                                              ? s.recentChat.length
                                              : 0) + s.hiddenChat.length);
                                      }
                                      v(ts.STEP_CONTACT, s);
                                    }
                                  })
                                  .catch((e) => {
                                    b.default.logCoreError(e);
                                  }),
                                  0 ==
                                    (null === (s = this.state.searchResult) ||
                                    void 0 === s ||
                                    null === (i = s.messages) ||
                                    void 0 === i
                                      ? void 0
                                      : i.length) &&
                                    0 ==
                                      (null === (n = this.state.searchResult) ||
                                      void 0 === n ||
                                      null === (r = n.all) ||
                                      void 0 === r
                                        ? void 0
                                        : r.length) &&
                                    0 ==
                                      (null === (o = this.state.searchResult) ||
                                      void 0 === o ||
                                      null === (c = o.files) ||
                                      void 0 === c
                                        ? void 0
                                        : c.length) &&
                                    Z.e.logAction(1232201),
                                  m === e ||
                                    this.trackSearchVietnamese ||
                                    ((this.trackSearchVietnamese = !0),
                                    Z.e.logAction(1232010));
                              }
                              filterByConversation(e, t) {
                                if (!e)
                                  return (
                                    (this.searchInput.value = ""),
                                    void this.updateState(
                                      Object(p.a)(
                                        Object(p.a)({}, Xt),
                                        {},
                                        {
                                          conversation: t,
                                          searching: !1,
                                          highlightId: "",
                                        }
                                      )
                                    )
                                  );
                                let s = (s, i = !1) => {
                                  this.isKeywordStale(e)
                                    ? b.default.logCoreError(
                                        "search: abort filtermode 1",
                                        this.state.searchText,
                                        e
                                      )
                                    : (!i || (s && 0 != s.length)) &&
                                      qt.a
                                        .getMessageOfConversation(
                                          s,
                                          t.userId,
                                          20
                                        )
                                        .then((a) => {
                                          if (this.isKeywordStale(e))
                                            return void b.default.logCoreError(
                                              "search: abort filtermode 2",
                                              this.state.searchText,
                                              e
                                            );
                                          let n = a.list;
                                          if (i && (!n || 0 === n.length))
                                            return;
                                          let r =
                                            n.length < 20 && s.length > 20;
                                          n.length > 0
                                            ? (this.updateState(
                                                Object(p.a)(
                                                  Object(p.a)({}, this.state),
                                                  {},
                                                  {
                                                    conversation: t,
                                                    searchResult: {
                                                      messageList: n.map(
                                                        (e) => ({
                                                          message: e,
                                                          conversation: t,
                                                        })
                                                      ),
                                                      realLen: a.len,
                                                      rawSearchResult: s,
                                                      lastOffset: 20,
                                                      progress: i,
                                                    },
                                                    searching: !1,
                                                    highlightId: n[0].msgId,
                                                  }
                                                )
                                              ),
                                              i ||
                                                (this.focusSearchBox(),
                                                r && this.loadMoreMessages()),
                                              !i &&
                                                this.searchResultList &&
                                                this.searchResultList
                                                  .scrollToTop &&
                                                this.searchResultList.scrollToTop())
                                            : (this.updateState(
                                                Object(p.a)(
                                                  Object(p.a)({}, this.state),
                                                  {},
                                                  {
                                                    conversation: t,
                                                    searchResult: {
                                                      messageList: [],
                                                      realLen: 0,
                                                      lastOffset: 0,
                                                      progress: !1,
                                                    },
                                                    searching: !1,
                                                    highlightId: "",
                                                  }
                                                )
                                              ),
                                              this.focusSearchBox(),
                                              !i &&
                                                r &&
                                                this.loadMoreMessages());
                                        });
                                };
                                qt.a
                                  .search(
                                    e,
                                    null,
                                    { convId: t.userId + "" },
                                    (e) => {
                                      s(e, !0);
                                    }
                                  )
                                  .then((e) => {
                                    s(e);
                                  });
                              }
                              _getSearchDelaySetting() {
                                return 70;
                              }
                              _upSearchDelay() {
                                let e = this.searchDelay;
                                (this.searchDelay = Math.min(
                                  400,
                                  Math.round(
                                    1.1 * this.searchDelay + 10 * Math.random()
                                  )
                                )),
                                  e !== this.searchDelay &&
                                    this._resetSearchFunction();
                              }
                              _downSearchDelay() {
                                let e = this.searchDelay;
                                (this.searchDelay = Math.max(
                                  70,
                                  Math.round(
                                    0.9 * this.searchDelay + 10 * Math.random()
                                  )
                                )),
                                  e !== this.searchDelay &&
                                    this._resetSearchFunction();
                              }
                              _resetSearchFunction() {
                                b.default.logCoreError(
                                  "__rssf__",
                                  this.searchDelay
                                ),
                                  (this.functionSearchByName =
                                    b.default.throttle(
                                      this._innerSearchFunc,
                                      this.searchDelay
                                    ));
                              }
                              _isSelectAllSearchText() {
                                if (this.searchInput) {
                                  const e = this.searchInput.selectionStart,
                                    t = this.searchInput.selectionEnd;
                                  return !(
                                    !this.searchInput.value.length ||
                                    0 != e ||
                                    t != this.searchInput.value.length
                                  );
                                }
                                return !1;
                              }
                              init() {}
                              getItem(e) {
                                return this.state;
                              }
                              getList(e) {
                                throw new Error("No imp!!!");
                              }
                              onGetItemFailure(e) {}
                              onGetListFailure(e) {}
                              loadOldestTime() {
                                qt.a
                                  .getOldestTime()
                                  .then((e) => {
                                    null != e && e.length && e[0].ts
                                      ? (this.oldestTime = parseFloat(e[0].ts))
                                      : (this.oldestTime = 0);
                                  })
                                  .catch((e) => {
                                    this.oldestTime = 0;
                                  });
                              }
                              getOldestTime() {
                                return this.oldestTime;
                              }
                            })
                          ) || zt)
                      ) || zt)
                  ) || zt)
              ) || zt)
          ) || zt)
      );
      var ss,
        is = s("dThN"),
        as = s("jnrz"),
        ns = s("Anfm"),
        rs = s("BZLJ"),
        os = (s("L+5E"), s("A9FD")),
        cs = s("BKm0"),
        ls = s("iKSP");
      const ds = {
          windowId: Ze.c,
          theme: gt.a.default,
          currentTab: Ct.SidebarTab.MESSAGE_TAB,
          previousTab: Ct.SidebarTab.MESSAGE_TAB,
          selectedId: null,
          previousId: null,
          showExportImportEntry: !0,
        },
        hs = "z_sendtome_bubbledot",
        us = "SIDEBAR CONTROLLER";
      function gs(...e) {
        b.default.logCoreInfo(`[${us}] - `, e);
      }
      Object(j.h)()(
        (ss =
          Object(B.b)(Ct.SidebarController)(
            (ss =
              (function (e, t) {
                return a.ModuleContainer.inject(Ct.ConvListController)(
                  e,
                  void 0,
                  0
                );
              })(
                (ss =
                  (function (e, t) {
                    return a.ModuleContainer.inject(Qt.b)(e, void 0, 1);
                  })(
                    (ss =
                      Reflect.metadata(
                        "design:type",
                        Function
                      )(
                        (ss =
                          Reflect.metadata("design:paramtypes", [
                            void 0 === Ct.ConvListController
                              ? Object
                              : Ct.ConvListController,
                            void 0 === Qt.b ? Object : Qt.b,
                          ])(
                            (ss = class {
                              constructor(e, t) {
                                (this.convListController = e),
                                  (this.searchController = t),
                                  Object(i.a)(
                                    this,
                                    "changeTabFromSearch",
                                    void 0
                                  ),
                                  Object(i.a)(
                                    this,
                                    "_firstTimePageLoad",
                                    void 0
                                  ),
                                  Object(i.a)(this, "_querySelect", void 0),
                                  Object(i.a)(this, "_convsLoaded", void 0),
                                  Object(i.a)(
                                    this,
                                    "_exportImportFinished",
                                    void 0
                                  ),
                                  Object(i.a)(
                                    this,
                                    "_exportImportProgressError",
                                    void 0
                                  ),
                                  Object(i.a)(this, "_allowAutoJumpFC", void 0),
                                  Object(i.a)(this, "_es", void 0),
                                  Object(i.a)(this, "_onSendMsg", (e) => {
                                    var t, s;
                                    const i =
                                        (null == e ||
                                        null === (t = e.messages) ||
                                        void 0 === t ||
                                        null === (s = t[0]) ||
                                        void 0 === s
                                          ? void 0
                                          : s.upSrc) & w.FILE_UP_SRC.TextEditor,
                                      a = this.getState();
                                    if (
                                      a.currentTab == Ct.SidebarTab.TODO_TAB ||
                                      a.currentTab ==
                                        Ct.SidebarTab.CATALOG_TAB ||
                                      i ||
                                      e.isChild
                                    )
                                      return;
                                    const n =
                                      this.searchController.getSearchState();
                                    a.currentTab !==
                                      Ct.SidebarTab.MESSAGE_TAB ||
                                    (n && n.searchText)
                                      ? ((a.currentTab =
                                          Ct.SidebarTab.MESSAGE_TAB),
                                        Object(yt.g)(this.name, Ze.c),
                                        Object(vt.f)({
                                          type: y.SideBarActions.SHOW_CHAT_VIEW,
                                        }),
                                        n &&
                                          n.searchText &&
                                          Z.e.logAction(1232007),
                                        this.searchController.clearSearch(!0))
                                      : a.currentTab ==
                                          Ct.SidebarTab.MESSAGE_TAB &&
                                        this.searchController.setRecentSearchFocusState(
                                          !1,
                                          !1,
                                          !0
                                        ),
                                      (this.searchController.closeBySendingMsg =
                                        !0),
                                      setTimeout(() => {
                                        this.convListController.scrollToTop(!1);
                                      }, 100);
                                  }),
                                  Object(i.a)(
                                    this,
                                    "changeTab",
                                    (e, t = Ze.c) => {
                                      const s = this._getStateByWindowId(t);
                                      s.currentTab !== e &&
                                        ((s.currentTab = e),
                                        Object(yt.g)(this.name, t)),
                                        this._onChangeTab(s.currentTab);
                                    }
                                  ),
                                  Object(i.a)(this, "togglePerfTab", (e) => {
                                    const t = this._getStateByWindowId(Ze.c);
                                    t.showPerfTab !== e &&
                                      ((t.showPerfTab = e),
                                      Object(yt.g)(this.name, Ze.c));
                                  }),
                                  Object(i.a)(
                                    this,
                                    "changeTheme",
                                    async (e) => {
                                      const t = this._getStateByWindowId(Ze.c);
                                      t.theme !== e &&
                                        ((t.theme = e),
                                        Object(yt.g)(this.name, Ze.c));
                                    }
                                  ),
                                  Object(i.a)(this, "selectMessageTab", () => {
                                    this.changeTab(Ct.SidebarTab.MESSAGE_TAB);
                                  }),
                                  Object(i.a)(this, "selectTodoTab", () => {
                                    this.changeTab(Ct.SidebarTab.TODO_TAB),
                                      Z.e.logAction(171),
                                      rs.h.setViewPopupTodoSrc(rs.c.TAB_ICON);
                                  }),
                                  Object(i.a)(
                                    this,
                                    "selectContactFromSearch",
                                    async (e, t = !1) => {
                                      if (!e)
                                        return (
                                          gs("Select friend null!"),
                                          Promise.resolve(!1)
                                        );
                                      const s = await a.ModuleContainer.resolve(
                                        pe.b
                                      ).openConversation(
                                        e.userId,
                                        pe.c.fromSearchList(e)
                                      );
                                      return (
                                        !0 === t
                                          ? (this.searchController.onCloseSearch(),
                                            this.searchController.resetState())
                                          : this.searchController.updateStateOf(
                                              "highlightId",
                                              e.userId
                                            ),
                                        s
                                          ? (e &&
                                              e.userId ===
                                                I.default.sendToMeId &&
                                              (Mt.g.getFlagForCurrentUser(
                                                this.currUser.userId,
                                                hs
                                              ) ||
                                                (ze.p.getHasShownSendToMeTip()
                                                  ? Mt.g.setFlagForCurrentUser(
                                                      this.currUser.userId,
                                                      hs,
                                                      1
                                                    )
                                                  : setTimeout(() => {
                                                      _.default.send(
                                                        y
                                                          .ConversationListActions
                                                          .SHOW_BUBBLE_DOT
                                                      ),
                                                        ze.p.setHasShownSendToMeTip(
                                                          !0
                                                        );
                                                    }, 144e5)),
                                              Z.e.logAction(1390101)),
                                            Promise.resolve(!0))
                                          : (gs("Open conv failure"),
                                            Promise.resolve(!1))
                                      );
                                    }
                                  ),
                                  Object(i.a)(
                                    this,
                                    "setupSelectConvOnPageLoad",
                                    () => {}
                                  ),
                                  Object(i.a)(
                                    this,
                                    "name",
                                    Ct.SIDEBAR_CONTROLLER
                                  ),
                                  Object(i.a)(this, "data", new Map()),
                                  Object(i.a)(this, "key", "windowId"),
                                  (this.changeTabFromSearch = !1),
                                  (this._firstTimePageLoad = !0),
                                  (this._convsLoaded = !1),
                                  (this._allowAutoJumpFC = !1),
                                  (this.selectConversationForFriend =
                                    this.selectConversationForFriend.bind(
                                      this
                                    )),
                                  this.listenEvents();
                              }
                              get currUser() {
                                return Object(wt.c)();
                              }
                              get autoJumFC() {
                                return this._allowAutoJumpFC;
                              }
                              get eventStore() {
                                return (
                                  this._es || (this._es = s("emRR").default),
                                  this._es
                                );
                              }
                              onStart(e) {
                                a.ModuleContainer.resolve(pe.b);
                              }
                              listenEvents() {
                                _.default.subscribe((e, t) => {
                                  switch (e) {
                                    case y.ChatBoxActions.SEND_MSG:
                                      this._onSendMsg(t);
                                      break;
                                    case y.ChatBoxActions.SELECT_FRIEND:
                                      this.selectConversationForFriend(t);
                                      break;
                                    case y.SideBarActions.SHOW_FILE_MANAGER:
                                      (this.getState().currentTab =
                                        Ct.SidebarTab.FILE_TAB),
                                        Object(yt.g)(this.name, Ze.c);
                                      break;
                                    case y.SideBarActions.SELECT_TAB_MSG:
                                      this.changeTab(Ct.SidebarTab.MESSAGE_TAB);
                                      break;
                                    case y.SideBarActions.SELECT_ZAVI_TAB:
                                      this.changeTab(Ct.SidebarTab.ZAVI_TAB);
                                      break;
                                    case y.FetchActions.DELETE_CONVERSATION:
                                    case y.FetchActions.GROUP_LEAVE: {
                                      const e = this.getState();
                                      e.previousId &&
                                        t === e.previousId &&
                                        (e.previousId = null);
                                      break;
                                    }
                                    case y.ChatBoxActions
                                      .JUMP_TO_MESSAGE_SEARCH_HIDDEN_CHAT:
                                    case y.ChatBoxActions
                                      .JUMP_TO_MESSAGE_SEARCH:
                                      this.getState().currentTab ==
                                        Ct.SidebarTab.FILE_TAB &&
                                        this.changeTab(
                                          Ct.SidebarTab.MESSAGE_TAB
                                        );
                                      break;
                                    case y.TodoActions.OPEN_TODO_LIST: {
                                      const e = Nt.b.instance().getTodoView();
                                      e
                                        ? e.onCheckOpenTab()
                                        : this.changeTab(
                                            Ct.SidebarTab.TODO_TAB
                                          );
                                      break;
                                    }
                                    case y.ActionList.ACT_OPEN_TAB_CHAT:
                                      this.selectMessageTab();
                                      break;
                                    case y.ActionList.ACT_OPEN_TAB_CONTACT:
                                      this.changeTab(Ct.SidebarTab.CONTACT_TAB);
                                      break;
                                    case y.ActionList.ACT_OPEN_GROUPLIST:
                                      if (
                                        this.getState().currentTab ===
                                        Ct.SidebarTab.CONTACT_TAB
                                      ) {
                                        const e = Nt.b
                                          .instance()
                                          .getContactList();
                                        e && e.onJumpGroupCenter();
                                      } else
                                        this.changeTab(
                                          Ct.SidebarTab.CONTACT_TAB
                                        );
                                      break;
                                    case cs.c.EXPORT_IMPORT_START:
                                      (this._exportImportFinished = !1),
                                        (this._exportImportProgressError = !1);
                                      break;
                                    case cs.c.EXPORT_IMPORT_FINISHED:
                                      (this._exportImportFinished = !0),
                                        (this._exportImportProgressError = !1);
                                      break;
                                    case cs.c.IMPORT_DB_PROGRESS:
                                    case cs.c.IMPORT_PROGRESS:
                                    case cs.c.EXPORT_PROGRESS:
                                    case cs.c.EXPORT_DB_PROGRESS:
                                      t &&
                                        t.error &&
                                        (this._exportImportProgressError = !0);
                                      break;
                                    case y.ConversationListActions
                                      .SELECT_CONVERSATION: {
                                      const e = this.getState();
                                      (e.currentTab !==
                                        Ct.SidebarTab.FILE_TAB &&
                                        e.currentTab !==
                                          Ct.SidebarTab.ZAVI_TAB &&
                                        e.currentTab !==
                                          Ct.SidebarTab.CATALOG_TAB) ||
                                        this.changeTab(
                                          Ct.SidebarTab.MESSAGE_TAB
                                        );
                                      break;
                                    }
                                  }
                                }),
                                  N.a.ConvInfoDataManager.addEventListener(
                                    Et.b.DoneLoadDB,
                                    (e) => {
                                      (this._convsLoaded = !0),
                                        this._autoSelectConv();
                                    }
                                  ),
                                  N.a.UnreadDataManager.addEventListener(
                                    Et.b.DoneLoadDB,
                                    (e) => {
                                      as.b.onDoneLoadUnreadDB(
                                        null == e ? void 0 : e.payload
                                      );
                                    }
                                  );
                              }
                              getState(e = Ze.c) {
                                return this._getStateByWindowId(e);
                              }
                              getSelectedId(e) {
                                return this.getState(e).selectedId || null;
                              }
                              getCurrMainConvId() {
                                const e = this.eventStore.getState();
                                return e && e.chatview.view === ls.c.CHAT_VIEW
                                  ? this.getSelectedId()
                                  : null;
                              }
                              updateSelectedId(e, t = Ze.c) {
                                const s = this._getStateByWindowId(t);
                                s.selectedId !== e &&
                                  ((s.previousId = e ? null : s.selectedId),
                                  (s.selectedId = e),
                                  Object(yt.g)(this.name, t));
                              }
                              isInImportExportProcess() {
                                const e =
                                  this._exportImportFinished ||
                                  this._exportImportProgressError;
                                return void 0 !== e && !e;
                              }
                              openFriendCenter() {}
                              selectConversationForFriend(e, t = !1) {
                                if (!e)
                                  return void b.default.logCoreError(
                                    "friend null"
                                  );
                                if (
                                  (vt.f &&
                                    (Object(vt.f)({
                                      type: y.ConversationListActions
                                        .SELECT_CONV_MINOR,
                                      payload: e,
                                    }),
                                    Object(vt.f)({
                                      type: y.ChatBoxActions.READ_CONVERSATION,
                                      payload: { conversationId: e.userId },
                                    })),
                                  e.userId == this.currUser.userId)
                                )
                                  return void this._showMyProfile();
                                let s =
                                    this.convListController.getRecentContactWithId(
                                      e.userId
                                    ),
                                  i = !1;
                                if (s) i = !0;
                                else {
                                  let t = (t) => {
                                    t &&
                                      t.includes(e.userId) &&
                                      (s = Object(p.a)({}, t[e.userId]));
                                  };
                                  s || t(ne.default.getGroupsListSync()),
                                    s || t(D.default.getFriendsSync()),
                                    s || (s = {}),
                                    Object.assign(s, e),
                                    (s.isFr = s.isFr || 0),
                                    (s.type = s.type || w.FRIEND_TYPE_NORMAL);
                                }
                                e.byPassPIN
                                  ? (s.byPassPIN = 1)
                                  : s.byPassPIN && delete s.byPassPIN,
                                  setTimeout(() => {
                                    Object(vt.f)({
                                      type: y.ConversationListActions
                                        .SELECT_CONVERSATION,
                                      payload: s,
                                    });
                                  }, 0);
                                const a = this.data.get(Ze.c);
                                let n = null == a ? void 0 : a.currentTab;
                                !0 === t
                                  ? ((n = i
                                      ? Ct.SidebarTab.MESSAGE_TAB
                                      : Ct.SidebarTab.CONTACT_TAB),
                                    n === Ct.SidebarTab.CONTACT_TAB &&
                                      (b.default.log(
                                        "sidebar: select from search, should highlight thread"
                                      ),
                                      (this.changeTabFromSearch = !0)),
                                    this.searchController.onCloseSearch(),
                                    this.searchController.resetState(),
                                    !e.userId ||
                                      (!e.byPassPIN &&
                                        ae.a.isThreadHidden(e.userId)) ||
                                      setTimeout(() => {
                                        _.default.send(
                                          y.ChatBoxActions.FOCUS_INPUT,
                                          { userId: e.userId, windowId: Ze.c }
                                        );
                                      }, 0))
                                  : this.searchController.updateStateOf(
                                      "highlightId",
                                      e.userId
                                    ),
                                  this.updateState(
                                    Object(p.a)(
                                      Object(p.a)({}, a),
                                      {},
                                      { currentTab: n, selectedId: e.userId }
                                    )
                                  ),
                                  e &&
                                    e.userId === I.default.sendToMeId &&
                                    (Mt.g.getFlagForCurrentUser(
                                      this.currUser.userId,
                                      hs
                                    ) ||
                                      (ze.p.getHasShownSendToMeTip()
                                        ? Mt.g.setFlagForCurrentUser(
                                            this.currUser.userId,
                                            hs,
                                            1
                                          )
                                        : setTimeout(() => {
                                            _.default.send(
                                              y.ConversationListActions
                                                .SHOW_BUBBLE_DOT
                                            ),
                                              ze.p.setHasShownSendToMeTip(!0);
                                          }, 144e5)));
                              }
                              showAddFriendModal() {
                                Z.e.logAction(1020203),
                                  Z.e.logAction(12316),
                                  He.ModalManagerV2.openModal({
                                    windowId: Ze.c,
                                    name: w.ModalIdentitiesDefine.FIND_FRIEND,
                                  });
                              }
                              showGroupCompose() {
                                Z.e.logAction(1020202),
                                  ns.c.markStart(
                                    ns.a.CREATE_GROUP,
                                    ns.b.Group.CREATE_GR_HEADER_ICON
                                  );
                                const e = ze.p.getSessionUserId(),
                                  t = (e = !0) => {
                                    He.ModalManagerV2.openModal({
                                      windowId: Ze.c,
                                      name: w.ModalIdentitiesDefine
                                        .CREATE_GROUP_COMPOSE,
                                      params: { needInitE2ee: e },
                                      forceCloseAll: !1,
                                    });
                                  };
                                !Mt.g.getTimeEntryPointE2eGroup(
                                  e,
                                  ns.b.Group.CREATE_GR_HEADER_ICON
                                ) &&
                                I.default.e2ee.enable_group &&
                                I.default.e2ee.group
                                  .can_enable_right_in_creation_step
                                  ? He.ModalManagerV2.openModal({
                                      windowId: Ze.c,
                                      name: w.ModalIdentitiesDefine
                                        .E2EE_ONBOARDING,
                                      params: {
                                        entry: os.e.CREATE_GROUP,
                                        entrySrc:
                                          ns.b.Group.CREATE_GR_HEADER_ICON,
                                        isGroup: !0,
                                        userId: "",
                                        callback: t,
                                        callbackCancel: t,
                                      },
                                      forceCloseAll: !1,
                                    })
                                  : t(!1);
                              }
                              enableAutoJupmFC() {
                                this._allowAutoJumpFC = !0;
                              }
                              disableAutoJupmFC() {
                                this._allowAutoJumpFC = !1;
                              }
                              init() {}
                              getItem(e) {
                                const t = e.key;
                                return this._getStateByWindowId(t);
                              }
                              getList(e) {
                                return Array.from(this.data.keys());
                              }
                              onGetItemFailure(e) {}
                              onGetListFailure(e) {}
                              updateState(e, t = Ze.c, s = !0) {
                                this.data.set(t, e),
                                  s && Object(yt.g)(this.name, t);
                              }
                              _getStateByWindowId(e) {
                                let t = this.data.get(e);
                                return (
                                  t ||
                                    ((t = Object(p.a)({}, ds)),
                                    this.data.set(e, t)),
                                  t
                                );
                              }
                              _onChangeTab(e) {
                                switch (
                                  ((function () {
                                    switch (e) {
                                      case Ct.SidebarTab.MESSAGE_TAB:
                                        Z.e.logAction(12801);
                                        break;
                                      case Ct.SidebarTab.CONTACT_TAB:
                                        Z.e.logAction(12802),
                                          3 ===
                                            I.default.noti_center_config
                                              .entry_position &&
                                            Z.e.logAction(1281205);
                                        break;
                                      case Ct.SidebarTab.MENTION_TAB:
                                        Z.e.logAction(12805);
                                        break;
                                      case Ct.SidebarTab.STAR_TAB:
                                        Z.e.logAction(12806);
                                        break;
                                      case Ct.SidebarTab.FILE_TAB:
                                        Z.e.logAction(133);
                                        break;
                                      case Ct.SidebarTab.TODO_TAB:
                                        3 ===
                                          I.default.noti_center_config
                                            .entry_position &&
                                          Z.e.logAction(1281206);
                                        break;
                                      case Ct.SidebarTab.ZAVI_TAB:
                                        Z.e.logAction(20701);
                                    }
                                  })(),
                                  ze.p.resetGlobalSearchMode(),
                                  this.searchController.clearSearch(!0),
                                  e)
                                ) {
                                  case Ct.SidebarTab.MESSAGE_TAB: {
                                    this._resetConversationList();
                                    const e = this.getState();
                                    !e.selectedId &&
                                      e.previousId &&
                                      this.updateSelectedId(e.previousId),
                                      Object(vt.f)({
                                        type: y.SideBarActions.SHOW_CHAT_VIEW,
                                      });
                                    break;
                                  }
                                  case Ct.SidebarTab.ZAVI_TAB:
                                    Object(vt.f)({
                                      type: y.SideBarActions.SELECT_ZAVI,
                                    });
                                  case Ct.SidebarTab.TODO_TAB:
                                }
                              }
                              _showMyProfile() {
                                He.ModalManagerV2.openModal({
                                  windowId: Ze.c,
                                  name: w.ModalIdentitiesDefine.FRIEND_PROFILE,
                                  params: this.currUser.userId,
                                });
                              }
                              _resetConversationList() {}
                              _getQueryParams() {
                                let e = {},
                                  t = window.location.search;
                                if (
                                  ((t = t ? t.substr(1).split("&") : null), t)
                                )
                                  for (let s = 0; s < t.length; s++) {
                                    let i = t[s].indexOf("=");
                                    if (i >= 0) {
                                      let a = t[s].slice(0, i),
                                        n = t[s].slice(i + 1, t[s].length);
                                      a &&
                                        a.length > 0 &&
                                        n &&
                                        n.length > 0 &&
                                        (e[a] = decodeURIComponent(n));
                                    }
                                  }
                                return e;
                              }
                              _autoSelectConv() {
                                this._querySelect &&
                                  this._convsLoaded &&
                                  (b.default.logCoreInfo(
                                    `[${this.name}] - auto select conv start`
                                  ),
                                  this._querySelect(),
                                  (this._querySelect = null));
                              }
                            })
                          ) || ss)
                      ) || ss)
                  ) || ss)
              ) || ss)
          ) || ss)
      );
      var ps;
      const ms = {
        id: bt.g,
        color: "#EA87FF",
        conversations: [],
        createTime: 1634956772046,
        emoij: "",
        offset: 100,
        text: "default",
      };
      var vs;
      !(function (e) {
        (e.ALL = "all"), (e.SELECTED = "selected");
      })(vs || (vs = {}));
      Object(B.b)(Ct.LabelDataManager)(
        (ps =
          Reflect.metadata(
            "design:type",
            Function
          )(
            (ps =
              Reflect.metadata(
                "design:paramtypes",
                []
              )(
                (ps = class extends re.b {
                  constructor() {
                    super(),
                      Object(i.a)(this, "allLabels", void 0),
                      Object(i.a)(this, "selectedLabel", void 0),
                      Object(i.a)(this, "name", Ct.LABEL_DATA_MANAGER),
                      Object(i.a)(this, "data", new Map()),
                      Object(i.a)(this, "key", "labelId"),
                      (this.allLabels = []),
                      (this.selectedLabel = []);
                  }
                  onLabelChange(e) {
                    const {
                        color: t,
                        conversations: s,
                        createTime: i,
                        emoij: a,
                        offset: n,
                        text: r,
                      } = e,
                      o = "" + e.id,
                      c = this.data.get(o);
                    if (
                      (!o ||
                        (c &&
                          s === c.conversations &&
                          i == (null == c ? void 0 : c.createTime) &&
                          a == c.emoij &&
                          n == c.offset &&
                          r === c.text &&
                          t == c.color) ||
                        (this.data.set(o, e),
                        Object(yt.g)(this.name, o),
                        Object(yt.h)(this.name, "all")),
                      c &&
                        c.conversations &&
                        c.conversations.length !== s.length)
                    ) {
                      let e = [];
                      s.length > c.conversations.length
                        ? ((e = s.filter((e) => !c.conversations.includes(e))),
                          this.dispatchEvent(
                            new It.c(It.d.LabelAddConvs, {
                              labelId: o,
                              convIds: e,
                            })
                          ))
                        : ((e = c.conversations.filter((e) => !s.includes(e))),
                          this.dispatchEvent(
                            new It.c(It.d.LabelRemoveConvs, {
                              labelId: o,
                              convIds: e,
                            })
                          ));
                    }
                  }
                  onFetchLabels(e) {
                    if (Array.isArray(e) && !(e.length < 0)) {
                      for (let t = 0; t < e.length; t++)
                        this.onLabelChange(e[t]);
                      this.data.forEach((t) => {
                        const s = "" + t.id;
                        e.some((e) => e.id == s) || this.data.delete(s);
                      }),
                        this._updateAllLabels(e.map((e) => e.id));
                    }
                  }
                  onLabelDeleted(e) {
                    "string" != typeof e &&
                      (b.default.logCoreError(
                        `[${this.name}] - delete label invalid lid type ${e}`
                      ),
                      (e = "" + e)),
                      this.data.has(e)
                        ? (this.data.delete(e),
                          this._updateAllLabels(
                            this.allLabels.filter((t) => t !== e)
                          ),
                          this.selectedLabel.includes(e) &&
                            this.onDeSelectLabel(e),
                          Object(yt.e)(this.name, e))
                        : b.default.logCoreError(
                            this.name + "Deleted not exists item!!!"
                          );
                  }
                  _updateAllLabels(e) {
                    return (
                      !b.default.shallowEqual(this.allLabels, e) &&
                      ((this.allLabels = e),
                      Object(yt.h)(this.name, vs.ALL),
                      !0)
                    );
                  }
                  onSelectLabel(e) {
                    (this.selectedLabel = ["" + e]),
                      Object(yt.h)(this.name, vs.SELECTED),
                      this.selectedLabelChanged();
                  }
                  onDeSelectLabel(e) {
                    (this.selectedLabel = this.selectedLabel.filter(
                      (t) => t !== e
                    )),
                      Object(yt.h)(this.name, vs.SELECTED),
                      this.selectedLabelChanged();
                  }
                  onClearFilter() {
                    (this.selectedLabel = []),
                      Object(yt.h)(this.name, vs.SELECTED),
                      this.selectedLabelChanged();
                  }
                  getLabelById(e) {
                    return e
                      ? ("string" != typeof e && (e = e.toString()),
                        e == bt.g
                          ? ms
                          : e == bt.h
                          ? { id: bt.h }
                          : this.data.get(e) || null)
                      : null;
                  }
                  getAllLabels() {
                    return Array.from(this.data.values());
                  }
                  getAllLabelIds() {
                    return this.allLabels;
                  }
                  applyNewFilter(e) {
                    (this.selectedLabel = e),
                      Object(yt.h)(this.name, vs.SELECTED),
                      this.selectedLabelChanged();
                  }
                  selectedLabelChanged() {
                    this.dispatchEvent(
                      new It.c(It.d.SelectedLabelChange, this.selectedLabel)
                    );
                  }
                  init() {
                    Tt.b.getAll().then((e) => {
                      this.onFetchLabels(e);
                    });
                  }
                  getItem(e) {
                    const t = e.key;
                    return this.getLabelById(t);
                  }
                  getList(e) {
                    const t = e.key;
                    return t === vs.ALL
                      ? this.allLabels
                      : t === vs.SELECTED
                      ? this.selectedLabel
                      : [];
                  }
                  onGetItemFailure(e) {}
                  onGetListFailure(e) {}
                })
              ) || ps)
          ) || ps)
      );
      a.ModuleContainer.register(mt.b, _t);
      var fs = s("k+R1"),
        bs = s("Py3H");
      let _s;
      !(function (e) {
        (e[(e.FULL = 0)] = "FULL"), (e[(e.WINDOWED = 1)] = "WINDOWED");
      })(_s || (_s = {}));
      var Ss,
        ys = s("tQbm"),
        Cs = s("qzuk"),
        Is = s("NMlV"),
        Os = s("4HQc"),
        Es = s("8RMw"),
        Ts = s("lPX+"),
        Rs = s("OU7N"),
        Ls = s("UYGI"),
        Ms = s("X4fA"),
        Fs = s("V8Oy"),
        ws = s("7WX+");
      let Ds;
      b.default.isWeb() || (Ds = s("Dprd").default);
      const js = { conversationId: null, mode: _s.FULL, windowId: Ze.c };
      Object(B.b)(ys.b)(
        (Ss =
          (function (e, t) {
            return a.ModuleContainer.inject(Ct.SidebarController)(e, void 0, 0);
          })(
            (Ss =
              Reflect.metadata(
                "design:type",
                Function
              )(
                (Ss =
                  Reflect.metadata("design:paramtypes", [
                    void 0 === Ct.SidebarController
                      ? Object
                      : Ct.SidebarController,
                  ])(
                    (Ss = class extends re.b {
                      constructor(e) {
                        super(),
                          (this.sidebar = e),
                          Object(i.a)(this, "data", new Map()),
                          Object(i.a)(this, "onLogOut", () => {
                            if (Rs.c.isCalling())
                              return void Dt.a.createWarning(
                                jt.default.str("STR_SIGNOUT_WITH_CALL")
                              );
                            let e = ze.p.getSessionUserId(),
                              t = "STR_LOGOUT_CONFIRM",
                              s = +Ls.b.isUploading();
                            if (
                              (!s && Ds && Ds.isDownloading() && (s = 2), s > 0)
                            ) {
                              const e =
                                1 === s
                                  ? jt.default.str("STR_TITLE_BAR_SEND")
                                  : jt.default.str("STR_TITLE_BAR_RECEIVE");
                              t =
                                jt.default.str("STR_LOGOUT_CANCEL_FILE") +
                                ` ${e} ` +
                                jt.default.str("STR_TITLE_BAR_EXIT_ZALO_P2");
                            }
                            Ms.default.getLogoutToken(),
                              At.a.openConfirm({
                                windowId: Ze.c,
                                name: w.MODAL_CONFIRM.confirmIdentities,
                                params: {
                                  message: jt.default.str(t),
                                  okText: jt.default.str("STR_LOGOUT_YES"),
                                  cancelText: jt.default.str("STR_LOGOUT_NO"),
                                  onOk: this.doLogout,
                                  options: [
                                    {
                                      default_val: Mt.g.isSetClearData(e),
                                      key: "del_history",
                                      title: "STR_LOGOUT_DEL_HISTORY",
                                    },
                                  ],
                                  "data-id": {
                                    confirmBtn: "btn_Logout_Logout",
                                    cancelBtn: "btn_Logout_No",
                                  },
                                },
                              });
                          }),
                          Object(i.a)(
                            this,
                            "openConversationInNewWindow",
                            async (e) => {
                              throw new Error("Method not implemented.");
                            }
                          ),
                          Object(i.a)(this, "openScreenCapture", async () => {
                            Z.e.logAction(12808),
                              _.default.send(y.ChatBoxActions.SIDEBAR_CAPTURE);
                          }),
                          Object(i.a)(this, "openZaloSupport", async () => {
                            const e = I.default.supportPage;
                            return e
                              ? a.ModuleContainer.resolve(
                                  pe.b
                                ).openConversation(e, pe.c.fromSupport())
                              : Promise.resolve(!1);
                          }),
                          Object(i.a)(this, "openUpdateMyProfile", async () => {
                            He.ModalManagerV2.openModal({
                              windowId: Ze.c,
                              name: w.ModalIdentitiesDefine.UPDATE_PROFILE,
                              params: { showCloseButton: !0 },
                            });
                          }),
                          Object(i.a)(this, "openUserInfo", async (e) => {
                            bs.a.setFriendRequestSource(
                              e,
                              w.FRIEND_REQUEST_SRC_CONTACT_LIST_SUGGESTION
                            ),
                              ze.p.setSelectConversationSource(178012),
                              He.ModalManagerV2.openModal({
                                windowId: Ze.c,
                                name: w.ModalIdentitiesDefine.FRIEND_PROFILE,
                                params: e,
                              });
                          }),
                          Object(i.a)(this, "openEditAlias", async (e) => {
                            const t = {
                              windowId: Ze.c,
                              name: w.ModalIdentitiesDefine.EDIT_ALIAS,
                              params: Object(p.a)({}, e),
                            };
                            He.ModalManagerV2.openModal(t);
                          }),
                          Object(i.a)(this, "sendFile", async (e, t) => {
                            const s = this._getStateByWindowId(Ze.c),
                              i = fs.default.getChatBoxControllerByConvId(
                                t || s.conversationId
                              );
                            null == i || i._uploadDragFile(e, null, t);
                          }),
                          Object(i.a)(
                            this,
                            "getConvId",
                            () => this._getStateByWindowId(Ze.c).conversationId
                          ),
                          Object(i.a)(
                            this,
                            "sendDirectMsgToSendToMe",
                            (e, t) => {
                              !I.default.isOffSendToMe &&
                                this.chatboxController &&
                                $e.default
                                  .getConversation(I.default.sendToMeId)
                                  .then((s) => {
                                    if (e === w.MSG_GIF && t.url) {
                                      var i;
                                      let e = {
                                        hd: {
                                          width: t.width ? t.width : 0,
                                          height: t.height ? t.height : 0,
                                          url: t.url,
                                        },
                                        original: {
                                          width: t.width ? t.width : 0,
                                          height: t.height ? t.height : 0,
                                          url: t.url,
                                        },
                                        normal: {
                                          width: t.width ? t.width : 0,
                                          height: t.height ? t.height : 0,
                                          url: t.url,
                                        },
                                      };
                                      null === (i = this.chatboxController) ||
                                        void 0 === i ||
                                        i._sendMessage(
                                          s,
                                          w.MSG_GIF,
                                          e,
                                          null,
                                          null,
                                          null,
                                          null,
                                          null
                                        );
                                    }
                                    Object(vt.e)({
                                      type: y.ConversationListActions
                                        .SELECT_CONVERSATION,
                                      payload: s,
                                    }),
                                      this.sidebar.updateSelectedId(
                                        I.default.sendToMeId
                                      );
                                  });
                            }
                          ),
                          Object(i.a)(
                            this,
                            "handleSendMessageError",
                            (e, t, s) => {
                              var i, a;
                              if (
                                ($e.default.deleteMessageById(t.msgId),
                                null === (i = this.chatboxController) ||
                                  void 0 === i ||
                                  i._cleanUpLocalTTLItem(t),
                                ze.p.isDelSendingMsg(t.clientId))
                              )
                                return;
                              const n = t.convertToUIMessageObject();
                              return (
                                null === (a = this.chatboxController) ||
                                  void 0 === a ||
                                  a._handleMessageFailure(e, t, n, s, !0),
                                e
                              );
                            }
                          ),
                          Object(i.a)(
                            this,
                            "broadCastMessage",
                            (e, t, s, i) => {
                              if (e && t)
                                for (let l = 0; l < e.length; l++) {
                                  const d = e[l];
                                  if (d) {
                                    let e = d.userId,
                                      l = e.startsWith(w.GROUPID_PREFIX);
                                    if (t.msgType === w.MSG_STICKER) {
                                      var a, n;
                                      const c = Is.a.next();
                                      t &&
                                        t.sendSrc &&
                                        ns.c.track(c, t.sendSrc);
                                      const h =
                                          b.default.getMsgIdSendingFromCliMsgId(
                                            c
                                          ),
                                        u = new Os.b(
                                          ze.p.getSessionUserId(),
                                          e,
                                          h,
                                          c,
                                          w.MSG_STICKER,
                                          l
                                        ),
                                        g =
                                          null === Es.default ||
                                          void 0 === Es.default ||
                                          null ===
                                            (a =
                                              Es.default
                                                .signalProtocolManager) ||
                                          void 0 === a
                                            ? void 0
                                            : a.isOnE2ee(d.userId);
                                      if (
                                        (u.updateMessageContentProp(
                                          Os.a.STICKER,
                                          t.message
                                        ),
                                        g)
                                      ) {
                                        var r;
                                        const e = {
                                          id: u.content.sticker.id,
                                          catId: u.content.sticker.cateId,
                                          type: u.content.sticker.type,
                                        };
                                        var o;
                                        if (
                                          null !== (r = t.message) &&
                                          void 0 !== r &&
                                          r.fssInfo
                                        )
                                          e.extInfo =
                                            null === (o = t.message) ||
                                            void 0 === o
                                              ? void 0
                                              : o.fssInfo;
                                        u.updateMessageContentProp(
                                          Os.a.STICKER,
                                          e
                                        ),
                                          (u.e2eeStatus = w.MSG_E2EE);
                                      }
                                      is.default
                                        .sendMsgObject(
                                          u,
                                          null,
                                          null,
                                          w.RETRY_MSG_TIMEOUT_DEFAULT
                                        )
                                        .then((t) => {
                                          if (s) {
                                            var a;
                                            const t = Is.a.next(),
                                              i =
                                                b.default.getMsgIdSendingFromCliMsgId(
                                                  t
                                                );
                                            let n = new Os.b(
                                              ze.p.getSessionUserId(),
                                              e,
                                              i,
                                              t,
                                              w.MSG_TEXT,
                                              l
                                            );
                                            n.updateMessageContentProp(
                                              Os.a.TEXT,
                                              s
                                            ),
                                              g && (n.e2eeStatus = w.MSG_E2EE),
                                              is.default
                                                .sendMsgObject(
                                                  n,
                                                  null,
                                                  null,
                                                  w.RETRY_MSG_TIMEOUT_DEFAULT
                                                )
                                                .then((e) => {
                                                  g &&
                                                    ((e =
                                                      b.default.parseE2eeResp(
                                                        e
                                                      )),
                                                    this.chatboxController._sentMessage(
                                                      n,
                                                      e
                                                    ));
                                                })
                                                .catch((e) => {
                                                  this.handleSendMessageError(
                                                    e,
                                                    n,
                                                    d
                                                  );
                                                }),
                                              null ===
                                                (a = this.chatboxController) ||
                                                void 0 === a ||
                                                a._showLocalMessage(n, d);
                                          }
                                          g &&
                                            ((t = b.default.parseE2eeResp(t)),
                                            this.chatboxController._sentMessage(
                                              u,
                                              t
                                            )),
                                            i && i(t);
                                        })
                                        .catch((e) => {
                                          b.default.logCoreError(
                                            "BroadcastErr: ",
                                            e
                                          ),
                                            this.handleSendMessageError(
                                              e,
                                              u,
                                              d
                                            ),
                                            i && i(e);
                                        }),
                                        null === (n = this.chatboxController) ||
                                          void 0 === n ||
                                          n._showLocalMessage(u, d);
                                    } else if (t.msgType === w.MSG_TEXT && s) {
                                      var c;
                                      const t = Is.a.next(),
                                        a =
                                          b.default.getMsgIdSendingFromCliMsgId(
                                            t
                                          );
                                      let n = new Os.b(
                                        ze.p.getSessionUserId(),
                                        e,
                                        a,
                                        t,
                                        w.MSG_TEXT,
                                        l
                                      );
                                      n.updateMessageContentProp(Os.a.TEXT, s);
                                      (null === Es.default ||
                                      void 0 === Es.default ||
                                      null ===
                                        (c =
                                          Es.default.signalProtocolManager) ||
                                      void 0 === c
                                        ? void 0
                                        : c.isOnE2ee(d.userId)) &&
                                        (n.e2eeStatus = w.MSG_E2EE),
                                        is.default
                                          .sendMsgObject(
                                            n,
                                            null,
                                            null,
                                            w.RETRY_MSG_TIMEOUT_DEFAULT
                                          )
                                          .then((e) => {
                                            i && i(e);
                                          })
                                          .catch((e) => {
                                            this.handleSendMessageError(
                                              e,
                                              n,
                                              d
                                            ),
                                              i && i(e);
                                          });
                                    }
                                  }
                                }
                            }
                          ),
                          Object(i.a)(this, "handleEvent", (e, t) => {
                            if (
                              e ===
                              y.ConversationListActions.SELECT_CONVERSATION
                            ) {
                              const e = this._getStateByWindowId(Ze.c);
                              if (t.userId !== e.conversationId)
                                return (
                                  this._updateStateByWindowId(Ze.c, (e) =>
                                    Object(p.a)(
                                      Object(p.a)({}, e),
                                      {},
                                      { conversationId: t.userId }
                                    )
                                  ),
                                  Object(yt.g)(this.name, Ze.c),
                                  void this.dispatchEvent(
                                    new Cs.a(t.userId, Ze.c)
                                  )
                                );
                            }
                          }),
                          Object(i.a)(this, "name", ys.a),
                          Object(i.a)(this, "key", "windowId"),
                          this.init();
                      }
                      get chatboxController() {
                        const e = this.sidebar.getState().selectedId;
                        return fs.default.getChatBoxControllerByConvId(
                          e || Ze.b
                        );
                      }
                      onInviteFriend() {
                        const e = [Ts.a];
                        He.ModalManagerV2.openModal({
                          windowId: Ze.c,
                          name: w.ModalIdentitiesDefine.SHARE_MSG_COMPOSE,
                          params: {
                            messages: e,
                            title: jt.default.str("STR_INVITE_FRIEND_1"),
                            disableGroup: !0,
                            disablePcUser: !0,
                            callback: (e, t) => {
                              _.default.send(y.SideBarActions.SEND_INVITATION, {
                                target: e,
                                message:
                                  (null == t ? void 0 : t.length) > 0
                                    ? t[0]
                                    : "",
                                link: `https://${I.default.CONFIG_DOMAIN}/may-tinh`,
                              });
                            },
                          },
                        });
                      }
                      onWhatNew() {
                        He.ModalManagerV2.openModal({
                          windowId: Ze.c,
                          name: w.ModalIdentitiesDefine.APP_UPDATE_INFO,
                          params: {
                            data: $e.default.getCacheRecentUpdate(),
                            isManual: !0,
                          },
                        });
                      }
                      showMyProfile() {
                        let e = ze.p.getSessionUserId();
                        He.ModalManagerV2.openModal({
                          windowId: Ze.c,
                          name: w.ModalIdentitiesDefine.FRIEND_PROFILE,
                          params: e,
                        });
                      }
                      get mainWindowConversationId() {
                        return this._getStateByWindowId(Ze.c).conversationId;
                      }
                      doLogout(e) {
                        let t = ze.p.getSessionUserId();
                        e && e.del_history
                          ? Mt.g.setClearData(t, 1)
                          : Mt.g.setClearData(t, 0),
                          Fs.a.logout(),
                          ws.a.logout(),
                          Ms.default.logout().catch((e) => {
                            e.error_code &&
                              18032 === e.error_code &&
                              He.ModalManagerV2.openModal({
                                windowId: Ze.c,
                                name: w.ModalIdentitiesDefine.CHANGE_PW,
                              });
                          });
                      }
                      init() {
                        _.default.subscribe(this.handleEvent);
                      }
                      getItem(e, t) {
                        return this._getStateByWindowId(e.key);
                      }
                      getList(e, t) {
                        return Array.from(this.data.keys());
                      }
                      onGetItemFailure(e) {}
                      onGetListFailure(e) {}
                      _getStateByWindowId(e) {
                        let t = this.data.get(e);
                        return (
                          t || ((t = Object(p.a)({}, js)), this.data.set(e, t)),
                          t
                        );
                      }
                      _updateStateByWindowId(e, t) {
                        const s = t(this._getStateByWindowId(e));
                        this.data.set(e, s);
                      }
                    })
                  ) || Ss)
              ) || Ss)
          ) || Ss)
      );
      var As,
        Ns = s("OI//");
      let Ps =
        a.ModuleContainer.injectable()(
          (As = class {
            async get(e) {
              return ne.default.getGroupByIdSync(e);
            }
            async getAll() {
              return await ne.default.getGroupsListSync();
            }
          })
        ) || As;
      var ks;
      let Us =
        a.ModuleContainer.injectable()(
          (ks =
            (function (e, t) {
              return a.ModuleContainer.inject(Ns.c)(e, void 0, 0);
            })(
              (ks =
                (function (e, t) {
                  return a.ModuleContainer.inject(O.ZLoggerFactory)(
                    e,
                    void 0,
                    1
                  );
                })(
                  (ks =
                    Reflect.metadata(
                      "design:type",
                      Function
                    )(
                      (ks =
                        Reflect.metadata("design:paramtypes", [
                          void 0 === Ns.c ? Object : Ns.c,
                          void 0 === O.ZLoggerFactory
                            ? Object
                            : O.ZLoggerFactory,
                        ])(
                          (ks = class {
                            constructor(e, t) {
                              (this.groupRepository = e),
                                Object(i.a)(this, "logger", void 0),
                                (this.logger = t.createZLogger("groups", [
                                  "group-manager",
                                ]));
                            }
                            getAll() {
                              return this.groupRepository
                                .getAll()
                                .then((e) => e.map((e) => new Ns.a(e)))
                                .catch(
                                  (e) => (
                                    this.logger.zsymb(18, 9887, 3e4, () => [
                                      "getAll error. return [].",
                                      { reason: e },
                                    ]),
                                    []
                                  )
                                );
                            }
                            get(e) {
                              return this.groupRepository
                                .get(e)
                                .then((e) => (e ? new Ns.a(e) : void 0))
                                .catch((e) => {
                                  this.logger.zsymb(18, 9887, 30001, () => [
                                    "get error. return undefined.",
                                    { reason: e },
                                  ]);
                                });
                            }
                          })
                        ) || ks)
                    ) || ks)
                ) || ks)
            ) || ks)
        ) || ks;
      a.ModuleContainer.registerSingleton(Ns.c, Ps),
        a.ModuleContainer.registerSingleton(Ns.b, Us);
      var Bs = s("/S2x"),
        Gs = s("vBob"),
        zs = s("qlGb"),
        xs = s("POdc");
      var Vs = s("fsN4");
      var qs = s("7gmC");
      class Hs {
        constructor(e, t, s, a) {
          Object(i.a)(this, "actionSrc", void 0),
            Object(i.a)(this, "msgType", void 0),
            Object(i.a)(this, "convType", void 0),
            Object(i.a)(this, "dlt", void 0),
            (this.actionSrc = e),
            (this.msgType = t),
            (this.convType = s),
            (this.dlt = a);
        }
        toString() {
          const e = [
            this.actionSrc,
            this.msgType,
            this.convType,
            this.dlt,
          ].filter((e) => void 0 !== e);
          return e.length <= 0
            ? ""
            : 1 == e.length
            ? e.join("")
            : e.length >= 2
            ? e.join(".")
            : "";
        }
      }
      class Ks {
        constructor() {
          Object(i.a)(this, "name", void 0), Object(i.a)(this, "code", void 0);
        }
      }
      class $s extends Ks {
        constructor() {
          super(), (this.name = "SYNC_DOWNLOAD_DATA_INVALID"), (this.code = 1);
        }
      }
      class Ws extends Ks {
        constructor() {
          super(), (this.name = "MESSAGE_INVALID"), (this.code = 2);
        }
      }
      class Zs extends Ks {
        constructor() {
          super(), (this.name = "TOPIC_INVALID"), (this.code = 3);
        }
      }
      class Qs extends Ks {
        constructor() {
          super(), (this.name = "DLT_DATA_INVALID"), (this.code = 4);
        }
      }
      class Ys extends Ks {
        constructor() {
          super(), (this.name = "ACTION_HASH_DUPLICATE"), (this.code = 6);
        }
      }
      class Js extends Ks {
        constructor() {
          super(), (this.name = "MESSAGE_KEY_INVALID"), (this.code = 7);
        }
      }
      class Xs extends Ks {
        constructor() {
          super(), (this.name = "DOWNLOAD_ERROR"), (this.code = 8);
        }
      }
      class ei {
        constructor(e) {
          this.topic = e;
        }
      }
      class ti {
        constructor(e) {
          this.topic = e;
        }
      }
      var si,
        ii = s("nkyP");
      const ai = a.ModuleContainer.resolve(O.ZLoggerFactory).createZLogger(
        "tri-log",
        ["producer produce"]
      );
      let ni =
        Object(a.injectable)()(
          (si =
            (function (e, t) {
              return Object(a.inject)(ii.i)(e, void 0, 0);
            })(
              (si =
                (function (e, t) {
                  return Object(a.inject)(ii.p)(e, void 0, 1);
                })(
                  (si =
                    (function (e, t) {
                      return Object(a.inject)(ii.j)(e, void 0, 2);
                    })(
                      (si =
                        (function (e, t) {
                          return Object(a.inject)(ii.k)(e, void 0, 3);
                        })(
                          (si =
                            (function (e, t) {
                              return Object(a.inject)(ii.m)(e, void 0, 4);
                            })(
                              (si =
                                (function (e, t) {
                                  return Object(a.inject)(ii.g)(e, void 0, 5);
                                })(
                                  (si =
                                    (function (e, t) {
                                      return Object(a.inject)(ii.n)(
                                        e,
                                        void 0,
                                        6
                                      );
                                    })(
                                      (si =
                                        (function (e, t) {
                                          return Object(a.inject)(ii.r)(
                                            e,
                                            void 0,
                                            7
                                          );
                                        })(
                                          (si =
                                            (function (e, t) {
                                              return Object(a.inject)(ii.c)(
                                                e,
                                                void 0,
                                                8
                                              );
                                            })(
                                              (si =
                                                (function (e, t) {
                                                  return Object(a.inject)(ii.a)(
                                                    e,
                                                    void 0,
                                                    9
                                                  );
                                                })(
                                                  (si =
                                                    (function (e, t) {
                                                      return Object(a.inject)(
                                                        ii.s
                                                      )(e, void 0, 10);
                                                    })(
                                                      (si =
                                                        Reflect.metadata(
                                                          "design:type",
                                                          Function
                                                        )(
                                                          (si =
                                                            Reflect.metadata(
                                                              "design:paramtypes",
                                                              [
                                                                Object,
                                                                Object,
                                                                Object,
                                                                Object,
                                                                Object,
                                                                void 0 ===
                                                                qs.IMediator
                                                                  ? Object
                                                                  : qs.IMediator,
                                                                Object,
                                                                Object,
                                                                Object,
                                                                Object,
                                                                Object,
                                                              ]
                                                            )(
                                                              (si = class {
                                                                constructor(
                                                                  e,
                                                                  t,
                                                                  s,
                                                                  i,
                                                                  a,
                                                                  n,
                                                                  r,
                                                                  o,
                                                                  c,
                                                                  l,
                                                                  d
                                                                ) {
                                                                  (this.duplicateBucket =
                                                                    e),
                                                                    (this.syncQueueRepository =
                                                                      t),
                                                                    (this.messageRepository =
                                                                      s),
                                                                    (this.messageValidator =
                                                                      i),
                                                                    (this.syncActionsRepository =
                                                                      a),
                                                                    (this.syncActionMediator =
                                                                      n),
                                                                    (this.syncDownloadDataValidator =
                                                                      r),
                                                                    (this.topicMapper =
                                                                      o),
                                                                    (this.compositeKeyMapper =
                                                                      c),
                                                                    (this.actionHashMapper =
                                                                      l),
                                                                    (this.topicValidator =
                                                                      d);
                                                                }
                                                                async produceByAction(
                                                                  e
                                                                ) {
                                                                  try {
                                                                    if (
                                                                      !this.syncDownloadDataValidator.validateSyncDownloadData(
                                                                        e
                                                                      )
                                                                    )
                                                                      throw new $s();
                                                                    const t =
                                                                      this.actionHashMapper.map(
                                                                        e
                                                                      );
                                                                    if (
                                                                      this.syncDownloadDataValidator.validateDuplicateSyncDownloadData(
                                                                        t
                                                                      )
                                                                    )
                                                                      throw new Ys();
                                                                    this.duplicateBucket.add(
                                                                      t.toString()
                                                                    );
                                                                    const s =
                                                                      await this.messageRepository.getMessageByCliMsgId(
                                                                        e.clientMsgId
                                                                      );
                                                                    if (
                                                                      !this.messageValidator.validateMessage(
                                                                        s
                                                                      )
                                                                    )
                                                                      throw new Ws();
                                                                    const i =
                                                                        this.compositeKeyMapper.mapByAction(
                                                                          e
                                                                        ),
                                                                      a =
                                                                        this.compositeKeyMapper.mapByMessage(
                                                                          s
                                                                        );
                                                                    if (
                                                                      !this.messageValidator.validateMessageByCompositeKey(
                                                                        a,
                                                                        i
                                                                      )
                                                                    )
                                                                      throw new Js();
                                                                    const n =
                                                                      this.topicMapper.map(
                                                                        e,
                                                                        s
                                                                      );
                                                                    if (
                                                                      !this.topicValidator.validateTopic(
                                                                        n
                                                                      )
                                                                    )
                                                                      throw new Zs();
                                                                    this.syncQueueRepository.addByTopic(
                                                                      n.toString(),
                                                                      {
                                                                        action:
                                                                          e,
                                                                        message:
                                                                          s,
                                                                        lastClientMsgId:
                                                                          e.clientMsgId,
                                                                      }
                                                                    ),
                                                                      requestAnimationFrame(
                                                                        async () => {
                                                                          await this.syncActionMediator.publish(
                                                                            new ti(
                                                                              n
                                                                            )
                                                                          );
                                                                        }
                                                                      );
                                                                  } catch (t) {
                                                                    t instanceof
                                                                      Ys ||
                                                                      requestAnimationFrame(
                                                                        async () => {
                                                                          var t;
                                                                          this.duplicateBucket.delete(
                                                                            null ===
                                                                              (t =
                                                                                this.actionHashMapper.map(
                                                                                  e
                                                                                )) ||
                                                                              void 0 ===
                                                                                t
                                                                              ? void 0
                                                                              : t.toString()
                                                                          );
                                                                        }
                                                                      );
                                                                  }
                                                                }
                                                                async produceByParams(
                                                                  e,
                                                                  t,
                                                                  s
                                                                ) {
                                                                  let i =
                                                                    await this.syncActionsRepository.getActionsByActionSrc(
                                                                      e,
                                                                      t,
                                                                      s
                                                                    );
                                                                  if (
                                                                    ((i.data
                                                                      .length <=
                                                                      0 ||
                                                                      (i.data
                                                                        .length >
                                                                        0 &&
                                                                        !1 ===
                                                                          i.hasMore)) &&
                                                                      (await this.syncActionMediator.publish(
                                                                        new ei(
                                                                          new Hs(
                                                                            e
                                                                          )
                                                                        )
                                                                      )),
                                                                    !(
                                                                      i.data
                                                                        .length <=
                                                                        0 ||
                                                                      null == i
                                                                    ) && i.data)
                                                                  )
                                                                    for (let [
                                                                      n,
                                                                      r,
                                                                    ] of i.data.entries())
                                                                      try {
                                                                        if (
                                                                          !this.syncDownloadDataValidator.validateSyncDownloadData(
                                                                            r
                                                                          )
                                                                        )
                                                                          throw new $s();
                                                                        const e =
                                                                          this.actionHashMapper.map(
                                                                            r
                                                                          );
                                                                        if (
                                                                          this.syncDownloadDataValidator.validateDuplicateSyncDownloadData(
                                                                            e
                                                                          )
                                                                        )
                                                                          throw new Ys();
                                                                        this.duplicateBucket.add(
                                                                          e.toString()
                                                                        );
                                                                        const t =
                                                                          await this.messageRepository.getMessageByCliMsgId(
                                                                            r.clientMsgId
                                                                          );
                                                                        if (
                                                                          !this.messageValidator.validateMessage(
                                                                            t
                                                                          )
                                                                        )
                                                                          throw new Ws();
                                                                        const s =
                                                                          this.topicMapper.map(
                                                                            r,
                                                                            t
                                                                          );
                                                                        if (
                                                                          !this.topicValidator.validateTopic(
                                                                            s
                                                                          )
                                                                        )
                                                                          throw new Zs();
                                                                        this.syncQueueRepository.addByTopic(
                                                                          s.toString(),
                                                                          {
                                                                            action:
                                                                              r,
                                                                            message:
                                                                              t,
                                                                            lastClientMsgId:
                                                                              i.lastClientMsgId,
                                                                            reproduce:
                                                                              0 ==
                                                                                n &&
                                                                              !1 !==
                                                                                i.hasMore,
                                                                          }
                                                                        ),
                                                                          await this.syncActionMediator.publish(
                                                                            new ti(
                                                                              s
                                                                            )
                                                                          );
                                                                      } catch (a) {
                                                                        ai.zsymb(
                                                                          23,
                                                                          10604,
                                                                          3e4,
                                                                          "produce error {}",
                                                                          a
                                                                        ),
                                                                          a instanceof
                                                                            Ys ||
                                                                            requestAnimationFrame(
                                                                              async () => {
                                                                                var e;
                                                                                this.duplicateBucket.delete(
                                                                                  null ===
                                                                                    (e =
                                                                                      this.actionHashMapper.map(
                                                                                        r
                                                                                      )) ||
                                                                                    void 0 ===
                                                                                      e
                                                                                    ? void 0
                                                                                    : e.toString()
                                                                                );
                                                                              }
                                                                            );
                                                                      }
                                                                }
                                                              })
                                                            ) || si)
                                                        ) || si)
                                                    ) || si)
                                                ) || si)
                                            ) || si)
                                        ) || si)
                                    ) || si)
                                ) || si)
                            ) || si)
                        ) || si)
                    ) || si)
                ) || si)
            ) || si)
        ) || si;
      var ri;
      let oi =
        Object(a.injectable)()(
          (ri =
            (function (e, t) {
              return Object(a.inject)(ii.i)(e, void 0, 0);
            })(
              (ri =
                Reflect.metadata(
                  "design:type",
                  Function
                )(
                  (ri =
                    Reflect.metadata("design:paramtypes", [Object])(
                      (ri = class {
                        constructor(e) {
                          this.duplicateBucket = e;
                        }
                        validateSyncDownloadData(e) {
                          return (
                            !!e &&
                            !(!e.clientMsgId || Number.isNaN(e.clientMsgId)) &&
                            !(
                              !e.actionSource || Number.isNaN(e.actionSource)
                            ) &&
                            !(!e.convId || !e.fromId)
                          );
                        }
                        validateDuplicateSyncDownloadData(e) {
                          return !!this.duplicateBucket.has(e.toString());
                        }
                      })
                    ) || ri)
                ) || ri)
            ) || ri)
        ) || ri;
      var ci,
        li = s("Y58e");
      let di =
        Object(a.injectable)()(
          (ci =
            (function (e, t) {
              return Object(a.inject)(li.a)(e, void 0, 0);
            })(
              (ci =
                Reflect.metadata(
                  "design:type",
                  Function
                )(
                  (ci =
                    Reflect.metadata("design:paramtypes", [
                      void 0 === li.a ? Object : li.a,
                    ])(
                      (ci = class {
                        constructor(e) {
                          Object(i.a)(this, "config", void 0),
                            (this.config = e);
                        }
                        validateTopic(e) {
                          if (!e.actionSrc) return !1;
                          return !!this.config
                            .get("syncDownload.topics")
                            .includes(e.toString());
                        }
                      })
                    ) || ci)
                ) || ci)
            ) || ci)
        ) || ci;
      const hi = a.ModuleContainer.resolve(O.ZLoggerFactory).createZLogger(
        "tri-log",
        ["queue add"]
      );
      class ui {
        constructor() {
          Object(i.a)(this, "maps", new Map());
        }
        unshiftByTopic(e, t) {
          var s;
          Array.isArray(this.maps.get(e))
            ? null === (s = this.maps.get(e)) || void 0 === s || s.unshift(t)
            : this.maps.set(e, [t]);
        }
        addByTopic(e, t) {
          var s;
          hi.zsymb(23, 10545, 3e4, "queue add topic {}, {}", e, t),
            Array.isArray(this.maps.get(e))
              ? null === (s = this.maps.get(e)) || void 0 === s || s.push(t)
              : this.maps.set(e, [t]);
        }
        popByTopic(e) {
          var t;
          return null === (t = this.maps.get(e)) || void 0 === t
            ? void 0
            : t.pop();
        }
        lengthByTopic(e) {
          var t;
          return (
            (null === (t = this.maps.get(e)) || void 0 === t
              ? void 0
              : t.length) || 0
          );
        }
        infosByTopic(e) {
          return [...this.maps.get(e)];
        }
      }
      var gi = s("jkDV");
      class pi {
        constructor(e) {
          this.topic = e;
        }
      }
      class mi {
        constructor(e, t, s) {
          (this.topic = e), (this.syncData = t), (this.reproduce = s);
        }
      }
      const vi = a.ModuleContainer.resolve(O.ZLoggerFactory).createZLogger(
        "downloadSyncActions",
        ["downloadSyncActions"]
      );
      class fi {
        constructor(e, t) {
          (this.topic = e), (this.DltSyncData = t);
        }
      }
      const bi = a.ModuleContainer.resolve(O.ZLoggerFactory).createZLogger(
        "tri-log",
        ["queue consume"]
      );
      class _i {
        constructor(e, t, s, i, a, n, r, o) {
          (this.duplicateBucket = e),
            (this.actionHashMapper = t),
            (this.cachedDTORepository = s),
            (this.DTOMapper = i),
            (this.syncQueueRepository = a),
            (this.mediator = n),
            (this.syncActionMediator = r),
            (this.topic = o);
        }
        async consume() {
          vi.zsymb(
            23,
            11668,
            3e4,
            "DownloadSyncActionConsumerService consume entry"
          );
          const e = this.syncQueueRepository.popByTopic(this.topic.toString()),
            t = null == e ? void 0 : e.action,
            s = null == e ? void 0 : e.message,
            i = null == e ? void 0 : e.reproduce;
          try {
            const e = this.DTOMapper.map(t, s);
            this.cachedDTORepository.setDTO(
              `${t.clientMsgId}.${this.topic.toString()}`,
              e
            ),
              bi.zsymb(
                23,
                11668,
                30001,
                "actionSrc {}, cliMsgId {}, globalMsgId {}, start download",
                t.actionSource,
                t.clientMsgId,
                t.globalMsgId
              );
            const i = await e.run();
            if ((null != i && i.downloadError) || null == i || !i.savePath)
              throw new Xs();
            this.cachedDTORepository.deleteDTO(
              `${t.clientMsgId}_${this.topic.toString()}`
            ),
              await this.syncActionMediator.publish(
                new gi.b(t.actionSource, t.fromId, t.convId, t.clientMsgId, {
                  isCached: Boolean(i.isCached),
                })
              );
          } catch (a) {
            t &&
              s &&
              bi.zsymb(
                23,
                11668,
                30002,
                "actionSrc {}, cliMsgId {}, globalMsgId {}, isCache {}, fail download go to retry",
                t.actionSource,
                t.clientMsgId,
                t.globalMsgId
              ),
              await this.syncActionMediator.publish(
                new fi(
                  new Hs(
                    this.topic.actionSrc,
                    this.topic.msgType,
                    this.topic.convType,
                    "dlt"
                  ),
                  { action: t, message: s, retry: 0 }
                )
              );
          }
          requestAnimationFrame(async () => {
            var e;
            this.duplicateBucket.delete(
              null === (e = this.actionHashMapper.map(t)) || void 0 === e
                ? void 0
                : e.toString()
            ),
              await this.mediator.publish(new pi(this.topic)),
              await this.mediator.publish(new mi(this.topic, t, i));
          });
        }
      }
      class Si {
        constructor(e) {
          this.topic = e;
        }
      }
      const yi = a.ModuleContainer.resolve(O.ZLoggerFactory).createZLogger(
        "tri-log",
        ["queue retry consume"]
      );
      class Ci {
        constructor(e, t, s, i, a, n, r, o, c) {
          (this.duplicateBucket = e),
            (this.actionHashMapper = t),
            (this.cachedDTORepository = s),
            (this.DTOMapper = i),
            (this.syncQueueDLTRepository = a),
            (this.mediator = n),
            (this.syncActionMediator = r),
            (this.DltValidator = o),
            (this.topic = c);
        }
        async consume() {
          vi.zsymb(
            23,
            10605,
            3e4,
            "DownloadSyncActionDltConsumer consume entry"
          );
          const e = this.syncQueueDLTRepository.popByTopic(
              this.topic.toString()
            ),
            t = null == e ? void 0 : e.action,
            s = null == e ? void 0 : e.message;
          try {
            if (!this.DltValidator.validateDlt(e)) throw new Qs();
            const i = this.DTOMapper.map(t, s);
            this.cachedDTORepository.setDTO(
              `${e.action.clientMsgId}_${this.topic.toString()}`,
              i
            ),
              yi.zsymb(
                23,
                10605,
                30001,
                "actionSrc {}, cliMsgId {}, globalMsgId {}, retry count {}, start retry download",
                t.actionSource,
                t.clientMsgId,
                t.globalMsgId,
                e.retry
              );
            const a = await i.run();
            if ((null != a && a.downloadError) || null == a || !a.savePath)
              throw (
                (yi.zsymb(
                  23,
                  10605,
                  30002,
                  "actionSrc {}, cliMsgId {}, globalMsgId {}, downloadError {}, savePath {}, done retry download",
                  t.actionSource,
                  t.clientMsgId,
                  t.globalMsgId,
                  null == a ? void 0 : a.downloadError,
                  null == a ? void 0 : a.savePath
                ),
                new Xs())
              );
            yi.zsymb(
              23,
              10605,
              30003,
              "actionSrc {}, cliMsgId {}, globalMsgId {}, isCache {}, done retry download",
              t.actionSource,
              t.clientMsgId,
              t.globalMsgId,
              a.isCached
            ),
              this.cachedDTORepository.deleteDTO(
                `${t.clientMsgId}_${this.topic.toString()}`
              ),
              await this.syncActionMediator.publish(
                new gi.b(t.actionSource, t.fromId, t.convId, t.clientMsgId, {
                  isCached: Boolean(a.isCached),
                })
              );
          } catch (i) {
            t &&
              s &&
              (i instanceof Qs ||
                (await this.mediator.publish(
                  new fi(this.topic, {
                    action: t,
                    message: s,
                    retry: e.retry + 1,
                  })
                ),
                yi.zsymb(
                  23,
                  10605,
                  30004,
                  "actionSrc {}, cliMsgId {}, globalMsgId {}, retry count {}, fail download increase retry",
                  t.actionSource,
                  t.clientMsgId,
                  t.globalMsgId,
                  e.retry
                )));
          }
          requestAnimationFrame(async () => {
            var e;
            this.duplicateBucket.delete(
              null === (e = this.actionHashMapper.map(t)) || void 0 === e
                ? void 0
                : e.toString()
            ),
              await this.mediator.publish(new pi(this.topic)),
              await this.mediator.publish(new Si(this.topic));
          });
        }
      }
      var Ii;
      let Oi =
        Object(a.injectable)()(
          (Ii =
            (function (e, t) {
              return Object(a.inject)(ii.i)(e, void 0, 0);
            })(
              (Ii =
                (function (e, t) {
                  return Object(a.inject)(ii.b)(e, void 0, 1);
                })(
                  (Ii =
                    (function (e, t) {
                      return Object(a.inject)(ii.a)(e, void 0, 2);
                    })(
                      (Ii =
                        (function (e, t) {
                          return Object(a.inject)(ii.e)(e, void 0, 3);
                        })(
                          (Ii =
                            (function (e, t) {
                              return Object(a.inject)(ii.p)(e, void 0, 4);
                            })(
                              (Ii =
                                (function (e, t) {
                                  return Object(a.inject)(ii.o)(e, void 0, 5);
                                })(
                                  (Ii =
                                    (function (e, t) {
                                      return Object(a.inject)(ii.g)(
                                        e,
                                        void 0,
                                        6
                                      );
                                    })(
                                      (Ii =
                                        (function (e, t) {
                                          return Object(a.inject)(ii.l)(
                                            e,
                                            void 0,
                                            7
                                          );
                                        })(
                                          (Ii =
                                            (function (e, t) {
                                              return Object(a.inject)(ii.f)(
                                                e,
                                                void 0,
                                                8
                                              );
                                            })(
                                              (Ii =
                                                Reflect.metadata(
                                                  "design:type",
                                                  Function
                                                )(
                                                  (Ii =
                                                    Reflect.metadata(
                                                      "design:paramtypes",
                                                      [
                                                        Object,
                                                        Object,
                                                        Object,
                                                        Object,
                                                        Object,
                                                        Object,
                                                        void 0 === qs.IMediator
                                                          ? Object
                                                          : qs.IMediator,
                                                        void 0 === qs.IMediator
                                                          ? Object
                                                          : qs.IMediator,
                                                        Object,
                                                      ]
                                                    )(
                                                      (Ii = class {
                                                        constructor(
                                                          e,
                                                          t,
                                                          s,
                                                          a,
                                                          n,
                                                          r,
                                                          o,
                                                          c,
                                                          l
                                                        ) {
                                                          (this.duplicateBucket =
                                                            e),
                                                            (this.cachedDTORepository =
                                                              t),
                                                            (this.actionHashMapper =
                                                              s),
                                                            (this.DTOMapper =
                                                              a),
                                                            (this.syncQueueRepository =
                                                              n),
                                                            (this.syncQueueDltRepository =
                                                              r),
                                                            (this.mediator = o),
                                                            (this.syncActionMediator =
                                                              c),
                                                            (this.dltValidator =
                                                              l),
                                                            Object(i.a)(
                                                              this,
                                                              "services",
                                                              new Map()
                                                            ),
                                                            Object(i.a)(
                                                              this,
                                                              "dltTopics",
                                                              new Map()
                                                            );
                                                        }
                                                        createByTopic(e) {
                                                          let t =
                                                              this.services.get(
                                                                e
                                                              ),
                                                            s =
                                                              this.services.get(
                                                                this.dltTopics.get(
                                                                  e
                                                                ) || ""
                                                              );
                                                          if (t && s)
                                                            return [t, s];
                                                          let i = e.split(".");
                                                          return (
                                                            (t = new _i(
                                                              this.duplicateBucket,
                                                              this.actionHashMapper,
                                                              this.cachedDTORepository,
                                                              this.DTOMapper,
                                                              this.syncQueueRepository,
                                                              this.mediator,
                                                              this.syncActionMediator,
                                                              new Hs(
                                                                Number(i[0]),
                                                                i[1],
                                                                i[2]
                                                              )
                                                            )),
                                                            (s = new Ci(
                                                              this.duplicateBucket,
                                                              this.actionHashMapper,
                                                              this.cachedDTORepository,
                                                              this.DTOMapper,
                                                              this.syncQueueDltRepository,
                                                              this.mediator,
                                                              this.syncActionMediator,
                                                              this.dltValidator,
                                                              new Hs(
                                                                Number(i[0]),
                                                                i[1],
                                                                i[2],
                                                                "dlt"
                                                              )
                                                            )),
                                                            this.services.set(
                                                              t.topic.toString(),
                                                              t
                                                            ),
                                                            this.services.set(
                                                              s.topic.toString(),
                                                              s
                                                            ),
                                                            [t, s]
                                                          );
                                                        }
                                                        deleteByTopic(e) {
                                                          this.services.delete(
                                                            e
                                                          );
                                                        }
                                                        getByTopic(e) {
                                                          return this.services.get(
                                                            e
                                                          );
                                                        }
                                                        getAll() {
                                                          return Array.from(
                                                            this.services.values()
                                                          );
                                                        }
                                                      })
                                                    ) || Ii)
                                                ) || Ii)
                                            ) || Ii)
                                        ) || Ii)
                                    ) || Ii)
                                ) || Ii)
                            ) || Ii)
                        ) || Ii)
                    ) || Ii)
                ) || Ii)
            ) || Ii)
        ) || Ii;
      const Ei = {
        [w.MSG_PHOTO]: "photo",
        [w.MSG_PHOTO_2]: "photo",
        [w.MSG_GIF]: "photo",
        [w.MSG_FILE]: "file",
        [w.MSG_VOICE]: "voice",
        [w.MSG_VIDEO]: "video",
      };
      var Ti;
      let Ri =
        Object(a.injectable)()(
          (Ti =
            (function (e, t) {
              return Object(a.inject)(li.a)(e, void 0, 0);
            })(
              (Ti =
                Reflect.metadata(
                  "design:type",
                  Function
                )(
                  (Ti =
                    Reflect.metadata("design:paramtypes", [
                      void 0 === li.a ? Object : li.a,
                    ])(
                      (Ti = class {
                        constructor(e) {
                          Object(i.a)(this, "config", void 0),
                            (this.config = e);
                        }
                        map(e, t) {
                          let s = Ei[t.msgType] || "";
                          const i = this.config.get("syncDownload.topics");
                          return i.includes(`${e.actionSource}`)
                            ? new Hs(e.actionSource)
                            : i.includes(`${e.actionSource}.${s}`)
                            ? new Hs(e.actionSource, s)
                            : void 0;
                        }
                      })
                    ) || Ti)
                ) || Ti)
            ) || Ti)
        ) || Ti;
      var Li;
      let Mi =
        Object(a.injectable)()(
          (Li =
            (function (e, t) {
              return Object(a.inject)(li.a)(e, void 0, 0);
            })(
              (Li =
                Reflect.metadata(
                  "design:type",
                  Function
                )(
                  (Li =
                    Reflect.metadata("design:paramtypes", [
                      void 0 === li.a ? Object : li.a,
                    ])(
                      (Li = class {
                        constructor(e) {
                          Object(i.a)(this, "config", void 0),
                            (this.config = e);
                        }
                        validateDlt(e) {
                          if (!e) return !1;
                          const t = this.config.get(
                            "syncDownload.dlt_max_retry"
                          );
                          return !(Number.isNaN(e.retry) || e.retry > t);
                        }
                      })
                    ) || Li)
                ) || Li)
            ) || Li)
        ) || Li;
      class Fi {
        constructor(e, t) {
          Object(i.a)(this, "actionSrc", void 0),
            Object(i.a)(this, "clientMsgId", void 0),
            (this.actionSrc = e),
            (this.clientMsgId = t);
        }
        toString() {
          return `${this.actionSrc}.${this.clientMsgId}`;
        }
      }
      class wi {
        constructor(e, t, s) {
          (this.cliMsgId = e), (this.fromUid = t), (this.toUid = s);
        }
        toString() {
          return `${this.cliMsgId}.${this.fromUid}.${this.toUid}`;
        }
      }
      a.ModuleContainer.register(
        ii.j,
        class {
          constructor() {
            Object(i.a)(this, "DB", void 0), (this.DB = Vs.a.getInstance());
          }
          async getMessageByCliMsgId(e) {
            return await this.DB.Core.Message.get(`${e}`, {
              index: "cliMsgIdIndex",
            });
          }
        }
      ),
        a.ModuleContainer.register(
          ii.m,
          class {
            constructor() {}
            async getActions() {
              return [];
            }
            getActionsByActionSrc(e) {
              return Object(xs.e)("SyncActionsRepository", e);
            }
          }
        ),
        a.ModuleContainer.registerSingleton(ii.o, ui),
        a.ModuleContainer.registerSingleton(ii.p, ui),
        a.ModuleContainer.registerSingleton(
          ii.b,
          class {
            constructor() {
              Object(i.a)(this, "cache", new Map());
            }
            getDTO(e) {
              return this.cache.get(e);
            }
            setDTO(e, t) {
              this.cache.set(e, t);
            }
            deleteDTO(e) {
              this.cache.delete(e);
            }
          }
        ),
        a.ModuleContainer.registerSingleton(
          ii.i,
          class {
            constructor() {
              Object(i.a)(this, "bucket", new Set());
            }
            add(e) {
              e && this.bucket.add(e);
            }
            has(e) {
              return this.bucket.has(e);
            }
            delete(e) {
              this.bucket.delete(e);
            }
          }
        ),
        a.ModuleContainer.register(ii.n, oi),
        a.ModuleContainer.register(
          ii.k,
          class {
            validateMessageByCompositeKey(e, t) {
              return e.toString() == t.toString();
            }
            validateMessage(e) {
              return (
                !!e &&
                !(!e.msgType || e.msgType == w.MSG_UNDO) &&
                !(!e.status || e.status > w.MSG_AFTER_READ) &&
                !!(e.msgId && e.cliMsgId && e.fromUid && e.toUid)
              );
            }
          }
        ),
        a.ModuleContainer.register(ii.s, di),
        a.ModuleContainer.register(ii.f, Mi),
        a.ModuleContainer.register(
          ii.e,
          class {
            map(e, t) {
              var s;
              const i = Object(zs.getDataFromMessage)(t),
                a = Object(zs.getTypeByMsg)(t),
                n = Object(zs.getUserId)();
              let r;
              xs.a.FromServer == e.actionSource &&
                (r = Gs.a.srcAction.SyncAuto),
                (xs.a.MsgFlow != e.actionSource &&
                  xs.a.FromTransfer != e.actionSource) ||
                  (r = Gs.a.srcAction.Auto);
              const o = {
                type: a,
                data: Object(p.a)(
                  Object(p.a)({}, i),
                  {},
                  { userId: n, localPath: void 0 }
                ),
                options: {
                  srcAction: r,
                  showProgress: { progressBar: !1, taskBar: !1 },
                  caching: !0,
                  duplicate: !1,
                },
              };
              return (
                (t.msgType != w.MSG_PHOTO && t.msgType != w.MSG_GIF) ||
                  (o.options.saveDir = Object(zs.getCachePath)(
                    i.conversationId,
                    n
                  )),
                t.msgType == w.MSG_FILE && (o.data.fileName = o.data.checksum),
                t.msgType == w.MSG_VOICE &&
                  (o.data.fileName =
                    null === (s = o.data.fileName) || void 0 === s
                      ? void 0
                      : s.replace(".aac", "")),
                new Bs.default(o)
              );
            }
          }
        ),
        a.ModuleContainer.register(ii.r, Ri),
        a.ModuleContainer.register(
          ii.a,
          class {
            map(e) {
              if (e) return new Fi(e.actionSource, e.clientMsgId);
            }
          }
        ),
        a.ModuleContainer.register(
          ii.c,
          class {
            mapByMessage(e) {
              var t, s;
              let i =
                null !== (t = e.toUid) &&
                void 0 !== t &&
                t.startsWith(w.GROUPID_PREFIX)
                  ? null === (s = e.toUid) || void 0 === s
                    ? void 0
                    : s.slice(w.GROUPID_PREFIX.length)
                  : null == e
                  ? void 0
                  : e.toUid;
              return new wi(e.cliMsgId, e.fromUid, i);
            }
            mapByAction(e) {
              var t, s;
              let i =
                  null !== (t = e.convId) &&
                  void 0 !== t &&
                  t.startsWith(w.GROUPID_PREFIX)
                    ? null === (s = e.convId) || void 0 === s
                      ? void 0
                      : s.slice(w.GROUPID_PREFIX.length)
                    : null == e
                    ? void 0
                    : e.convId,
                a = D.default.getUidMe() == e.fromId ? "0" : e.fromId;
              return new wi(e.clientMsgId, a, i);
            }
          }
        ),
        a.ModuleContainer.registerSingleton(
          ii.q,
          class {
            constructor() {
              Object(i.a)(this, "maps", new Map());
            }
            pauseByTopic(e) {
              this.maps.get(e).enable = !1;
            }
            resumeByTopic(e) {
              this.maps.get(e).enable = !0;
            }
            loadConfig(e, t) {
              this.maps.set(
                e,
                Object(p.a)(
                  Object(p.a)({ enable: !0 }, this.maps.get(e)),
                  {},
                  { capacity: t, tokens: t }
                )
              );
            }
            addByTopic(e) {
              const t = this.maps.get(e);
              (null == t ? void 0 : t.tokens) <
                (null == t ? void 0 : t.capacity) && (t.tokens += 1);
            }
            takeByTopic(e) {
              const t = this.maps.get(e);
              return (
                !!t.enable &&
                (null == t ? void 0 : t.tokens) > 0 &&
                ((t.tokens -= 1), !0)
              );
            }
          }
        ),
        a.ModuleContainer.registerSingleton(ii.h, ni),
        a.ModuleContainer.registerSingleton(ii.d, Oi),
        a.ModuleContainer.registerSingleton(ii.g, qs.Mediator);
      const Di = a.ModuleContainer.resolve(li.a),
        ji = a.ModuleContainer.resolve(ii.q),
        Ai = Di.get("syncDownload.topics");
      for (let Ch of Ai) ji.loadConfig(Ch, 2), ji.loadConfig(`${Ch}.dlt`, 2);
      const Ni = a.ModuleContainer.resolve(li.a).get("syncDownload.topics"),
        Pi = a.ModuleContainer.resolve(ii.d);
      for (let Ch of Ni) Pi.createByTopic(Ch);
      var ki;
      Object(qs.NotificationHandler)(pi, 1)(
        (ki =
          Reflect.metadata(
            "design:type",
            Function
          )(
            (ki =
              Reflect.metadata(
                "design:paramtypes",
                []
              )(
                (ki = class {
                  constructor() {
                    Object(i.a)(this, "tokenBucket", void 0),
                      (this.tokenBucket = a.ModuleContainer.resolve(ii.q));
                  }
                  async handle(e) {
                    this.tokenBucket.addByTopic(e.topic.toString());
                  }
                })
              ) || ki)
          ) || ki)
      );
      var Ui;
      const Bi = a.ModuleContainer.resolve(O.ZLoggerFactory).createZLogger(
        "tri-log",
        ["queue"]
      );
      Object(qs.NotificationHandler)(ei, 1)(
        (Ui =
          Reflect.metadata(
            "design:type",
            Function
          )(
            (Ui =
              Reflect.metadata(
                "design:paramtypes",
                []
              )(
                (Ui = class {
                  constructor() {
                    Object(i.a)(this, "tokenBucket", void 0),
                      Object(i.a)(this, "consumerServiceFactory", void 0),
                      (this.consumerServiceFactory = a.ModuleContainer.resolve(
                        ii.d
                      )),
                      (this.tokenBucket = a.ModuleContainer.resolve(ii.q));
                  }
                  async handle(e) {
                    vi.zsymb(23, 10601, 3e4, "AllActionsConsumedEvent entry");
                    const t = e.topic;
                    Bi.zsymb(
                      23,
                      10601,
                      30001,
                      "queue {}, done download",
                      e.topic.toString()
                    );
                    let s = this.consumerServiceFactory.getAll();
                    s = s
                      .filter((e) => e.topic.actionSrc == t.actionSrc)
                      .filter((e) => e.topic.dlt);
                    for (let i of s)
                      i &&
                        (this.tokenBucket.resumeByTopic(i.topic.toString()),
                        this.tokenBucket.takeByTopic(i.topic.toString()) &&
                          i.consume());
                  }
                })
              ) || Ui)
          ) || Ui)
      );
      var Gi;
      Object(qs.NotificationHandler)(mi, 1)(
        (Gi =
          Reflect.metadata(
            "design:type",
            Function
          )(
            (Gi =
              Reflect.metadata(
                "design:paramtypes",
                []
              )(
                (Gi = class {
                  constructor() {
                    Object(i.a)(this, "tokenBucket", void 0),
                      Object(i.a)(this, "consumerServiceFactory", void 0),
                      Object(i.a)(this, "syncQueue", void 0),
                      Object(i.a)(this, "producer", void 0),
                      Object(i.a)(this, "syncActionMediator", void 0),
                      (this.consumerServiceFactory = a.ModuleContainer.resolve(
                        ii.d
                      )),
                      (this.producer = a.ModuleContainer.resolve(ii.h)),
                      (this.tokenBucket = a.ModuleContainer.resolve(ii.q)),
                      (this.syncQueue = a.ModuleContainer.resolve(ii.p)),
                      (this.syncActionMediator = a.ModuleContainer.resolve(
                        ii.g
                      ));
                  }
                  async handle(e) {
                    vi.zsymb(23, 10599, 3e4, "PullDownloadCommand entry");
                    const t = this.consumerServiceFactory.getByTopic(
                      e.topic.toString()
                    );
                    var s;
                    if (this.syncQueue.lengthByTopic(e.topic.toString()) <= 0)
                      e.reproduce
                        ? this.producer.produceByParams(
                            e.topic.actionSrc,
                            void 0,
                            null === (s = e.syncData) || void 0 === s
                              ? void 0
                              : s.lastClientMsgId
                          )
                        : await this.syncActionMediator.publish(
                            new ei(new Hs(e.topic.actionSrc))
                          );
                    else
                      for (
                        ;
                        t && this.tokenBucket.takeByTopic(e.topic.toString());

                      )
                        t.consume();
                  }
                })
              ) || Gi)
          ) || Gi)
      );
      var zi;
      Object(qs.NotificationHandler)(ti, 1)(
        (zi =
          Reflect.metadata(
            "design:type",
            Function
          )(
            (zi =
              Reflect.metadata(
                "design:paramtypes",
                []
              )(
                (zi = class {
                  constructor() {
                    Object(i.a)(this, "tokenBucket", void 0),
                      Object(i.a)(this, "consumerServiceFactory", void 0),
                      (this.consumerServiceFactory = a.ModuleContainer.resolve(
                        ii.d
                      )),
                      (this.tokenBucket = a.ModuleContainer.resolve(ii.q));
                  }
                  async handle(e) {
                    vi.zsymb(23, 10598, 3e4, "PushDownloadCommand entry");
                    const t = `${e.topic}.dlt`;
                    this.tokenBucket.pauseByTopic(t);
                    const s = this.consumerServiceFactory.getByTopic(
                      e.topic.toString()
                    );
                    s &&
                      this.tokenBucket.takeByTopic(e.topic.toString()) &&
                      s.consume();
                  }
                })
              ) || zi)
          ) || zi)
      );
      var xi;
      Object(qs.NotificationHandler)(fi, 1)(
        (xi =
          Reflect.metadata(
            "design:type",
            Function
          )(
            (xi =
              Reflect.metadata(
                "design:paramtypes",
                []
              )(
                (xi = class {
                  constructor() {
                    Object(i.a)(this, "syncQueueDLTRepository", void 0),
                      (this.syncQueueDLTRepository = a.ModuleContainer.resolve(
                        ii.o
                      ));
                  }
                  async handle(e) {
                    vi.zsymb(
                      23,
                      10603,
                      3e4,
                      "DeadLetterUnshiftCommandHandler entry"
                    ),
                      this.syncQueueDLTRepository.unshiftByTopic(
                        e.topic.toString(),
                        e.DltSyncData
                      );
                  }
                })
              ) || xi)
          ) || xi)
      );
      var Vi;
      const qi = a.ModuleContainer.resolve(O.ZLoggerFactory).createZLogger(
        "tri-log",
        ["queue retry"]
      );
      Object(qs.NotificationHandler)(Si, 1)(
        (Vi =
          Reflect.metadata(
            "design:type",
            Function
          )(
            (Vi =
              Reflect.metadata(
                "design:paramtypes",
                []
              )(
                (Vi = class {
                  constructor() {
                    Object(i.a)(this, "tokenBucket", void 0),
                      Object(i.a)(this, "consumerServiceFactory", void 0),
                      Object(i.a)(this, "syncDltQueue", void 0),
                      (this.consumerServiceFactory = a.ModuleContainer.resolve(
                        ii.d
                      )),
                      (this.tokenBucket = a.ModuleContainer.resolve(ii.q)),
                      (this.syncDltQueue = a.ModuleContainer.resolve(ii.o));
                  }
                  async handle(e) {
                    vi.zsymb(23, 10600, 3e4, "PullDownloadCommandDlt entry");
                    const t = this.consumerServiceFactory.getByTopic(
                      e.topic.toString()
                    );
                    if (
                      this.syncDltQueue.lengthByTopic(e.topic.toString()) <= 0
                    )
                      return (
                        qi.zsymb(
                          23,
                          10600,
                          30001,
                          "retry queue {}, done download",
                          e.topic.toString()
                        ),
                        void this.tokenBucket.pauseByTopic(e.topic.toString())
                      );
                    for (
                      ;
                      t && this.tokenBucket.takeByTopic(e.topic.toString());

                    )
                      t.consume();
                  }
                })
              ) || Vi)
          ) || Vi)
      );
      var Hi,
        Ki = s("MqnV"),
        $i = s("yEZN");
      let Wi =
        a.ModuleContainer.injectable()(
          (Hi =
            (function (e, t) {
              return a.ModuleContainer.inject(me.d)(e, void 0, 0);
            })(
              (Hi =
                (function (e, t) {
                  return a.ModuleContainer.inject($i.b)(e, void 0, 1);
                })(
                  (Hi =
                    (function (e, t) {
                      return a.ModuleContainer.inject(me.f)(e, void 0, 2);
                    })(
                      (Hi =
                        Reflect.metadata(
                          "design:type",
                          Function
                        )(
                          (Hi =
                            Reflect.metadata("design:paramtypes", [
                              void 0 === me.d ? Object : me.d,
                              void 0 === $i.b ? Object : $i.b,
                              void 0 === me.f ? Object : me.f,
                            ])(
                              (Hi = class {
                                constructor(e, t, s) {
                                  (this.conversationRepository = e),
                                    (this.messageManager = t),
                                    (this.muteManager = s);
                                }
                                async get(e) {
                                  const t = await this.conversationRepository
                                    .get(e)
                                    .catch(() => {});
                                  if (t)
                                    return new me.c(
                                      t,
                                      this,
                                      this.messageManager
                                    );
                                }
                                isPinned(e) {
                                  return this.conversationRepository
                                    .get(e)
                                    .then((e) => !(null == e || !e.pinned))
                                    .catch(() => !1);
                                }
                                isMuted(e) {
                                  return !!this.muteManager.isMuted(e);
                                }
                              })
                            ) || Hi)
                        ) || Hi)
                    ) || Hi)
                ) || Hi)
            ) || Hi)
        ) || Hi;
      var Zi;
      let Qi =
        a.ModuleContainer.injectable()(
          (Zi =
            (function (e, t) {
              return a.ModuleContainer.inject(me.b)(e, void 0, 0);
            })(
              (Zi =
                Reflect.metadata(
                  "design:type",
                  Function
                )(
                  (Zi =
                    Reflect.metadata("design:paramtypes", [
                      void 0 === me.b ? Object : me.b,
                    ])(
                      (Zi = class {
                        constructor(e) {
                          this.convManager = e;
                        }
                        get(e) {
                          return this.convManager.getConvById(e);
                        }
                      })
                    ) || Zi)
                ) || Zi)
            ) || Zi)
        ) || Zi;
      var Yi = s("SVh1");
      var Ji,
        Xi = new (class {
          constructor() {}
          showMyProfile() {
            He.ModalManagerV2.openModal({
              windowId: Ze.c,
              name: w.ModalIdentitiesDefine.FRIEND_PROFILE,
              params: ze.p.getSessionUserId(),
            });
          }
        })(),
        ea = s("idnp"),
        ta = s("SWHF"),
        sa = s("rkiK");
      function ia(...e) {
        b.default.logCoreInfo("[Conversation controller] - ", e);
      }
      let aa =
        Object(a.singleton)()(
          (Ji =
            Object(a.injectable)()(
              (Ji =
                (function (e, t) {
                  return Object(a.inject)(me.h)(e, void 0, 0);
                })(
                  (Ji =
                    (function (e, t) {
                      return Object(a.inject)(ta.b)(e, void 0, 1);
                    })(
                      (Ji =
                        (function (e, t) {
                          return Object(a.inject)(Ct.SidebarController)(
                            e,
                            void 0,
                            2
                          );
                        })(
                          (Ji =
                            (function (e, t) {
                              return Object(a.inject)(me.b)(e, void 0, 3);
                            })(
                              (Ji =
                                Reflect.metadata(
                                  "design:type",
                                  Function
                                )(
                                  (Ji =
                                    Reflect.metadata("design:paramtypes", [
                                      void 0 === me.h ? Object : me.h,
                                      void 0 === ta.b ? Object : ta.b,
                                      void 0 === Ct.SidebarController
                                        ? Object
                                        : Ct.SidebarController,
                                      void 0 === me.b ? Object : me.b,
                                    ])(
                                      (Ji = class {
                                        constructor(e, t, a, n) {
                                          (this.previewManager = e),
                                            (this.adminSettingController = t),
                                            (this.sidebar = a),
                                            (this.convDataManager = n),
                                            Object(i.a)(this, "ipc", void 0),
                                            Object(i.a)(
                                              this,
                                              "lastOpenConv",
                                              new Map()
                                            ),
                                            Object(i.a)(this, "_es", void 0),
                                            Object(i.a)(
                                              this,
                                              "onRequestJumtoMsg",
                                              (e, t) => {
                                                const s = t.conversation,
                                                  i =
                                                    e ===
                                                      y.ChatBoxActions
                                                        .JUMP_TO_MESSAGE_SEARCH_HIDDEN_CHAT ||
                                                    ae.a
                                                      .getListChatBoxViewCurrent()
                                                      .includes(
                                                        null == s
                                                          ? void 0
                                                          : s.userId
                                                      ) ||
                                                    s.byPassPIN;
                                                if (!s) return;
                                                if (
                                                  s &&
                                                  !i &&
                                                  ae.a.isThreadHidden(s.userId)
                                                )
                                                  return (
                                                    Object(wt.b)(
                                                      { type: e, payload: t },
                                                      !0
                                                    ),
                                                    void ia(
                                                      "req jum to msg rejected because hidden chat"
                                                    )
                                                  );
                                                sa.default.Fps.record(
                                                  sa.MetricName.fps_jump_to_msg
                                                ),
                                                  ia(
                                                    "req jum to msg open on main"
                                                  ),
                                                  Object(wt.b)(
                                                    { type: e, payload: t },
                                                    !0
                                                  );
                                                const a =
                                                  ea.b.fromJumpMessage();
                                                this.openConversationForJump(
                                                  s.userId,
                                                  a
                                                );
                                              }
                                            ),
                                            Object(i.a)(
                                              this,
                                              "tryToFocusChild",
                                              (e, t) =>
                                                !!fs.default.isOpenChildWindowByConvId(
                                                  e
                                                ) &&
                                                (ia(
                                                  "Open conv forward because already open in child => call focus"
                                                ),
                                                fs.default.focusOnChildWindow(
                                                  e,
                                                  null == t
                                                    ? void 0
                                                    : t.callPoint
                                                ),
                                                !0)
                                            ),
                                            Object(i.a)(
                                              this,
                                              "handleOutConversation",
                                              (e) => {
                                                this.closeConversation(
                                                  e.convId
                                                );
                                              }
                                            ),
                                            this.listenEvent(),
                                            (this.ipc = s("NLsH").ipcRenderer);
                                        }
                                        get eventStore() {
                                          return (
                                            this._es ||
                                              (this._es = s("emRR").default),
                                            this._es
                                          );
                                        }
                                        listenEvent() {
                                          _.default.subscribe((e, t) => {
                                            switch (e) {
                                              case y.ConversationListActions
                                                .SELECT_CONVERSATION_HIDDEN:
                                                this.sidebar.updateSelectedId(
                                                  t.userId
                                                );
                                                break;
                                              case y.ChatBoxActions
                                                .OPEN_CONV_JUMP_TO_MESSAGE_SEARCH:
                                                this.onRequestJumtoMsg(
                                                  y.ChatBoxActions
                                                    .JUMP_TO_MESSAGE_SEARCH,
                                                  t
                                                );
                                                break;
                                              case y.ChatBoxActions
                                                .OPEN_CONV_JUMP_TO_MESSAGE_SEARCH_HIDDEN_CHAT:
                                                this.onRequestJumtoMsg(
                                                  y.ChatBoxActions
                                                    .JUMP_TO_MESSAGE_SEARCH_HIDDEN_CHAT,
                                                  t
                                                );
                                            }
                                          }),
                                            this.convDataManager.addEventListener(
                                              Et.b.DeleteConv,
                                              this.handleOutConversation
                                            ),
                                            this.convDataManager.addEventListener(
                                              Et.b.EmptyConv,
                                              this.handleOutConversation
                                            ),
                                            this.convDataManager.addEventListener(
                                              Et.b.LeaveGroup,
                                              this.handleOutConversation
                                            );
                                        }
                                        isConvOpeningInMain(e) {
                                          const t = this.eventStore.getState(),
                                            s =
                                              this.sidebar.getState()
                                                .selectedId;
                                          return (
                                            t &&
                                            t.chatview.view ===
                                              ls.c.CHAT_VIEW &&
                                            s === e
                                          );
                                        }
                                        openConversationForJump(e, t = ea.a) {
                                          return new Promise(async (s) => {
                                            if (
                                              (ia(
                                                `Request open conv for jum: ${e}`
                                              ),
                                              !e || this.isConvOpeningInMain(e))
                                            ) {
                                              if (
                                                (ia(
                                                  `Open conv rejected because null or opened: ${e}`
                                                ),
                                                e)
                                              ) {
                                                this.tryToFocusChild(e, t) ||
                                                  fs.default.focusOnMainWindow();
                                              }
                                              return s(!1);
                                            }
                                            if (
                                              !(await this.conversationWillOpen(
                                                e
                                              ))
                                            )
                                              return s(!1);
                                            let i = !1;
                                            if (t.window === Yi.b.Child)
                                              return (
                                                (i = this.tryToFocusChild(
                                                  e,
                                                  t
                                                )),
                                                s(i)
                                              );
                                            if (t.window === Yi.b.PreferChild) {
                                              if (
                                                ((i = this.tryToFocusChild(
                                                  e,
                                                  t
                                                )),
                                                i)
                                              )
                                                return s(!0);
                                            } else
                                              t.window === Yi.b.MainAndChild &&
                                                (i = this.tryToFocusChild(
                                                  e,
                                                  t
                                                ));
                                            i || fs.default.focusOnMainWindow(),
                                              _.default.send(
                                                y.ConversationListActions
                                                  .SELECT_CONV_MINOR,
                                                { userId: e }
                                              ),
                                              Object(wt.b)({
                                                type: y.ConversationListActions
                                                  .OPEN_CONV_FOR_JUMP,
                                                payload: { userId: e },
                                              }),
                                              this.sidebar.updateSelectedId(e),
                                              s(!0),
                                              this.conversationDidOpen(e);
                                          });
                                        }
                                        openConversation(e, t = ea.a) {
                                          return new Promise(async (s, i) => {
                                            if (
                                              (ia(
                                                `Request open conv from: ${e} - ${t.callPoint}`
                                              ),
                                              !e ||
                                                (this.isConvOpeningInMain(e) &&
                                                  !t.force))
                                            ) {
                                              if (
                                                (ia(
                                                  `Open conv rejected because null or opened: ${e}`
                                                ),
                                                e)
                                              ) {
                                                this.tryToFocusChild(e, t) ||
                                                  fs.default.focusOnMainWindow();
                                              }
                                              return s(!1);
                                            }
                                            const a = ze.p.getSessionUserId();
                                            if (e == a)
                                              return Xi.showMyProfile(), s(!1);
                                            sa.default.Fps.record(
                                              sa.MetricName.fps_switch_conv
                                            );
                                            if (
                                              !(await this.conversationWillOpen(
                                                e
                                              ))
                                            )
                                              return s(!1);
                                            let n = !1;
                                            if (t.window === Yi.b.Child)
                                              return (
                                                (n = this.tryToFocusChild(
                                                  e,
                                                  t
                                                )),
                                                s(n)
                                              );
                                            if (t.window === Yi.b.PreferChild) {
                                              if (
                                                ((n = this.tryToFocusChild(
                                                  e,
                                                  t
                                                )),
                                                n)
                                              )
                                                return s(!0);
                                            } else
                                              t.window === Yi.b.MainAndChild &&
                                                (n = this.tryToFocusChild(
                                                  e,
                                                  t
                                                ));
                                            let r = t.credentConv;
                                            if (
                                              (r ||
                                                ((r = await $e.default
                                                  .getLikeConversation(e)
                                                  .catch((e) => {
                                                    ia(
                                                      `Failure to load conv from store ${e}`
                                                    );
                                                  })),
                                                ia(
                                                  `Try to use storage conv: ${!!r}`
                                                )),
                                              r ||
                                                ((r = t.defaultConv),
                                                ia(
                                                  `Try to use default conv: ${!!r}`
                                                )),
                                              !r)
                                            )
                                              return (
                                                ia(
                                                  `Open conv not exists: ${e}`
                                                ),
                                                s(!1)
                                              );
                                            n || fs.default.focusOnMainWindow(),
                                              _.default.send(
                                                y.ConversationListActions
                                                  .SELECT_CONV_MINOR,
                                                r
                                              );
                                            const o = ae.a.isThreadHidden(e);
                                            o &&
                                              ae.a.checkShowUnreadHiddenChat(e),
                                              t.byPassPIN
                                                ? ((r = Object(p.a)({}, r)),
                                                  (r.byPassPIN = 1))
                                                : delete r.byPassPIN,
                                              this.eventStore.dispatch({
                                                type: y.ConversationListActions
                                                  .SELECT_CONVERSATION,
                                                payload: r,
                                              }),
                                              _.default.send(
                                                y.ConversationListActions
                                                  .SELECT_CONVERSATION,
                                                {
                                                  userId: r.userId,
                                                  needScroll:
                                                    t.callPoint !==
                                                    Yi.a.ConvItem,
                                                  callPoint: t.callPoint,
                                                }
                                              );
                                            (!o ||
                                              t.byPassPIN ||
                                              ae.a
                                                .getListChatBoxViewCurrent()
                                                .includes(r.userId)) &&
                                              this.sidebar.updateSelectedId(e),
                                              s(!0),
                                              this.conversationDidOpen(e);
                                          });
                                        }
                                        closeConversation(e, t = Ze.c) {
                                          return new Promise((s) => {
                                            if (
                                              e &&
                                              this.sidebar.getState()
                                                .selectedId !== e
                                            )
                                              return s(!1);
                                            if (t === Ze.c) {
                                              const e = {
                                                conversation: null,
                                                convId: null,
                                              };
                                              this.eventStore.dispatch({
                                                type: y.ConversationListActions
                                                  .SELECT_CONVERSATION,
                                                payload: e,
                                              }),
                                                _.default.send(
                                                  y.ConversationListActions
                                                    .SELECT_CONVERSATION,
                                                  e
                                                ),
                                                this.sidebar.updateSelectedId(
                                                  null
                                                );
                                            }
                                            s(!0);
                                          });
                                        }
                                        closeAllConversations() {
                                          return Promise.resolve(!0);
                                        }
                                        deleteConversation(e, t = Ze.c) {
                                          return new Promise(async (s) => {
                                            if (
                                              (this.conversationWillDelete(e),
                                              await ft.a.deleteConversation(
                                                e,
                                                !0,
                                                t
                                              ),
                                              t === Ze.c)
                                            ) {
                                              const t = { userId: null };
                                              this.eventStore.dispatch({
                                                type: y.ConversationListActions
                                                  .SELECT_CONVERSATION,
                                                payload: t,
                                              }),
                                                _.default.send(
                                                  y.ConversationListActions
                                                    .SELECT_CONVERSATION,
                                                  t
                                                ),
                                                this.sidebar.updateSelectedId(
                                                  null
                                                ),
                                                s(!0),
                                                this.conversationDidDelete(e);
                                            } else s(!1);
                                          });
                                        }
                                        pinConversation(e) {
                                          return Promise.resolve(!0);
                                        }
                                        renameConversation(e) {
                                          return Promise.resolve(!0);
                                        }
                                        getLastOpenConv(e) {
                                          return this.lastOpenConv.get(e);
                                        }
                                        conversationWillOpen(e) {
                                          return (
                                            ia(`Will open conv ${e}`),
                                            this.lastOpenConv.set(
                                              e,
                                              Date.now()
                                            ),
                                            Promise.resolve(!0)
                                          );
                                        }
                                        conversationDidOpen(e) {
                                          sa.default.start(
                                            sa.MetricName.open_conversation,
                                            e
                                          ),
                                            ia(`Did open conv ${e}`),
                                            this.adminSettingController.onLoadSetting(
                                              e
                                            ),
                                            setTimeout(() => {
                                              this.previewManager.revalidate(e);
                                            }, 0);
                                        }
                                        conversationWillDelete(e) {
                                          return (
                                            ia(`Will delete conv ${e}`),
                                            Promise.resolve()
                                          );
                                        }
                                        conversationDidDelete(e) {
                                          ia(`Did delete conv ${e}`),
                                            this.lastOpenConv.delete(e);
                                        }
                                      })
                                    ) || Ji)
                                ) || Ji)
                            ) || Ji)
                        ) || Ji)
                    ) || Ji)
                ) || Ji)
            ) || Ji)
        ) || Ji;
      var na,
        ra = s("s9sK"),
        oa = s("TeMN"),
        ca = (s("EHdh"), s("Ln14")),
        la = s("bdot"),
        da = s("cfFl"),
        ha = s.n(da);
      const ua = {
          userId: w.CONV_FILTER.STRANGER,
          label: null,
          isGroup: !1,
          respondedByMe: !1,
          numMsg: 0,
          pinned: 0,
          outside: 0,
          topOut: !1,
          infoCheckSearch: null,
        },
        ga = [
          "userId",
          "label",
          "firstSmsLocalId",
          "lastSmsLocalId",
          "isGroup",
          "respondedByMe",
          "numMsg",
          "pinned",
          "outside",
          "lastActionId",
          "topOutImprTimeOut",
          "topOutTimeOut",
          "syncFromMobile",
          "topOut",
          "localType",
          "infoCheckSearch",
          "preLastSmsLocalId",
        ];
      Object(B.b)(ca.c)(
        (na =
          (function (e, t) {
            return a.ModuleContainer.inject(oa.b)(e, void 0, 0);
          })(
            (na =
              Reflect.metadata(
                "design:type",
                Function
              )(
                (na =
                  Reflect.metadata("design:paramtypes", [
                    void 0 === Et.IReactiveDB ? Object : Et.IReactiveDB,
                  ])(
                    (na = class extends re.b {
                      constructor(e) {
                        super(),
                          (this.DBConvInfo = e),
                          Object(i.a)(this, "name", void 0),
                          Object(i.a)(this, "key", void 0),
                          Object(i.a)(this, "data", void 0),
                          Object(i.a)(this, "didInit", void 0),
                          Object(i.a)(this, "doneLoadDB", void 0),
                          Object(i.a)(this, "fetchAllHolder", void 0),
                          Object(i.a)(this, "preloadCached", void 0),
                          Object(i.a)(this, "_pm", void 0),
                          Object(i.a)(this, "pinEventQueue", void 0),
                          Object(i.a)(this, "labelEventQueue", void 0),
                          Object(i.a)(this, "doneEventQueue", void 0),
                          (this.name = ca.a),
                          (this.key = "convId"),
                          (this.data = new Map()),
                          (this.didInit = !1),
                          (this.doneLoadDB = !1),
                          (this.fetchAllHolder = null),
                          (this.preloadCached = null),
                          (this._pm = null),
                          (this.pinEventQueue = []),
                          (this.labelEventQueue = []),
                          (this.doneEventQueue = !1);
                      }
                      get previewManager() {
                        return (
                          this._pm ||
                            (this._pm = a.ModuleContainer.resolve(me.h)),
                          this._pm
                        );
                      }
                      get unreadManager() {
                        return N.a.UnreadDataManager;
                      }
                      init() {
                        return this.didInit
                          ? Promise.resolve()
                          : ((this.didInit = !0), this.loadData());
                      }
                      async loadData() {
                        this.fetchAllHolder ||
                          (this.fetchAllHolder = this.DBConvInfo.getAll());
                        const e =
                            (await this.fetchAllHolder.catch((e) => {
                              b.default.logCoreInfo(
                                `[${this.name}] - load conv from DB got error ${e}`
                              );
                            })) || [],
                          t = await this.onLoadDataFromDB(e);
                        b.default.logCoreInfo(
                          `[${this.name}] - done load db ${e.length}`
                        ),
                          (this.doneLoadDB = !0),
                          this.doIdleTask(),
                          this.broadcastEvent(Et.b.DoneLoadDB, "", e),
                          this.previewManager.migrate(t.map((e) => e.userId)),
                          this.setCacheData(w.CONV_FILTER.STRANGER, ua, !0);
                      }
                      async doIdleTask() {
                        const e = this.pinEventQueue.slice(),
                          t = this.labelEventQueue.slice();
                        (this.pinEventQueue = []), (this.labelEventQueue = []);
                        const s = ha.a.series(e),
                          i = ha.a.series(t);
                        return Promise.all([s, i]).then((e) =>
                          this.pinEventQueue.length ||
                          this.labelEventQueue.length
                            ? this.doIdleTask()
                            : ((this.doneEventQueue = !0), e)
                        );
                      }
                      getItem(e, t) {
                        return this.data.get(e.key);
                      }
                      getList(e, t) {
                        return e.key === ca.b.ALL
                          ? Array.from(this.data.keys())
                          : [];
                      }
                      onGetItemFailure(e) {}
                      onGetListFailure(e) {}
                      async onLoadDataFromDB(e) {
                        const t = await Ot.a.filterOutdatedConv(e);
                        b.default.logCoreInfo(
                          `[${this.name}] - done filter outdate ${e.length} ${t.length}`
                        );
                        const s = new Date().getTime().toString(),
                          i = [];
                        Object(yt.i)(s);
                        for (let a = 0; a < t.length; a++) {
                          if (!t[a].userId) continue;
                          const e = Object(p.a)({}, t[a]),
                            n = this.data.get(e.userId);
                          if (
                            ((e.verified = !0),
                            void 0 === e.isGroup &&
                              (e.isGroup = e.userId.startsWith(
                                w.GROUPID_PREFIX
                              )),
                            n)
                          ) {
                            if (!n.verified) {
                              const t = this.mergeConv(e, n);
                              (t.verified = !0),
                                this.setCacheData(e.userId, t),
                                Object(yt.f)(s, this.name, e.userId),
                                this.updateInDB(t);
                            }
                          } else
                            this.setCacheData(e.userId, e),
                              Object(yt.f)(s, this.name, e.userId);
                          e.infoCheckSearch &&
                            (e.infoCheckSearch &&
                            b.default.msgTypeValid(e.infoCheckSearch.lastType)
                              ? Kt.a.pushCacheLastChat(
                                  e.userId,
                                  e.infoCheckSearch.lastMessageTime
                                )
                              : e.numMsg && e.numMsg > 1 && i.push(e.userId));
                        }
                        return (
                          i.length > 0 && Kt.a.cacheCheckLastChatInDb(i),
                          Object(yt.c)(s),
                          t
                        );
                      }
                      onReceiveNewMessages(
                        e,
                        t,
                        s = { outside: void 0, isGroup: !1 }
                      ) {
                        return new Promise((i, a) => {
                          var n;
                          if (!t || t.length < 0) return a("Empty msgs");
                          const r = t[t.length - 1],
                            o = t[0],
                            c = this.data.get(e),
                            l = Ot.a.getLastValidMsg(t);
                          let d;
                          l &&
                            ((d = {
                              lastMessageTime: Number(l.sendDttm),
                              lastType: l.msgType,
                            }),
                            Kt.a.pushCacheLastChat(e, d.lastMessageTime));
                          const h = {
                            userId: e,
                            firstSmsLocalId: o.msgId,
                            isGroup:
                              s.isGroup || e.startsWith(w.GROUPID_PREFIX),
                            numMsg: t.length,
                            respondedByMe: Pt.b.includeMyMessage(t),
                            pinned: 0,
                            label: null,
                            topOut: r.topOut,
                            verified: !1,
                            lastSmsLocalId: r.msgId,
                            outside: s.outside,
                            cloudMore: !1,
                            infoCheckSearch: d,
                          };
                          if (
                            (this.preloadCached &&
                              this.preloadCached.onNewMsg(e, r),
                            c)
                          ) {
                            const t = this.mergeConv(Object(p.a)({}, c), h);
                            this.setCacheData(e, t),
                              this.shouldSignalUpdate(c, t) &&
                                Object(yt.g)(this.name, e),
                              c.verified && this.updateInDB(t),
                              i(t);
                          } else {
                            const t = Tt.b.getLabelObjByConversaionId(e);
                            if (
                              ((h.label = t ? t.id : null),
                              this.setCacheData(e, h, !0),
                              this.doneLoadDB)
                            )
                              return (
                                (h.verified = !0), this.updateInDB(h), i(h)
                              );
                            this.DBConvInfo.getById(e).then((t) => {
                              const s = this.data.get(e);
                              if (!s) return a("Internal logic handle wrong");
                              let n = Object(p.a)({}, s);
                              (n.verified = !0),
                                t
                                  ? s.verified ||
                                    ((n = this.mergeConv(n, t)),
                                    this.setCacheData(e, n),
                                    this.shouldSignalUpdate(n, s) &&
                                      Object(yt.g)(this.name, e),
                                    this.updateInDB(n))
                                  : this.updateInDB(n),
                                i(n);
                            });
                          }
                          (c && c.respondedByMe) ||
                            null === (n = this.data.get(e)) ||
                            void 0 === n ||
                            !n.respondedByMe ||
                            (b.default.logCoreInfo(
                              `[${this.name}] - Detect first my msg ${e} ${r.msgId}`
                            ),
                            this.previewManager.forceChangeItem(e));
                        });
                      }
                      async onDeleteMessages(e, t) {
                        const s = this.data.get(e);
                        if (
                          (b.default.logCoreInfo(
                            `[${this.name}] - onDeleteMessages #1 ${e} ${t.length}`
                          ),
                          s && s.verified)
                        ) {
                          let i = !1;
                          if (
                            t.find(({ msgId: e }) => s.firstSmsLocalId === e)
                          ) {
                            const t = await (
                              await la.b.getFirstMessage(e)
                            ).firstMsg;
                            if (!t)
                              return (
                                b.default.logCoreInfo(
                                  `[${this.name}] - onDeleteMessages #4 ${e} `
                                ),
                                this.forkDeleteCacheAndDB(e),
                                { deletedId: e }
                              );
                            (s.firstSmsLocalId = null == t ? void 0 : t.msgId),
                              (i = !0);
                          }
                          if (
                            t.find(({ msgId: e }) => s.lastSmsLocalId === e)
                          ) {
                            const t = await la.b.getLastMessage(
                              e,
                              s.lastSmsLocalId
                            );
                            if (!t || t.length < 1)
                              return (
                                b.default.logCoreInfo(
                                  `[${
                                    this.name
                                  }] - onDeleteMessages #5 ${e} ${!!t}`
                                ),
                                this.forkDeleteCacheAndDB(e),
                                { deletedId: e }
                              );
                            (s.lastSmsLocalId = t[0].msgId), (i = !0);
                          }
                          return (
                            b.default.logCoreInfo(
                              `[${this.name}] - onDeleteMessages #6 ${e} ${i}`
                            ),
                            i &&
                              (this.setCacheData(e, Object(p.a)({}, s)),
                              this.updateInDB(s)),
                            { conversation: s, updated: i }
                          );
                        }
                        {
                          const t = await (
                              await la.b.getFirstMessage(e)
                            ).firstMsg,
                            s = await la.b.getLastMessage(e),
                            i = s && s[0];
                          if (!t || !i)
                            return (
                              b.default.logCoreInfo(
                                `[${
                                  this.name
                                }] - onDeleteMessages #2 ${e} ${!!t} ${!!i}`
                              ),
                              N.a.PinDataManager.isPinned(e) ||
                                this.onDeleteConversation(e),
                              { deletedId: e }
                            );
                          const a = await this.DBConvInfo.getById(e);
                          let n = b.default.msgTypeValid(i)
                            ? {
                                lastMessageTime: i.sendDttm,
                                lastType: i.msgType,
                              }
                            : void 0;
                          if (
                            (b.default.logCoreInfo(
                              `[${this.name}] - onDeleteMessages #3 ${e} ${!!a}`
                            ),
                            a)
                          ) {
                            let s = !1;
                            a.firstSmsLocalId !==
                              (null == t ? void 0 : t.msgId) &&
                              ((a.firstSmsLocalId =
                                null == t ? void 0 : t.msgId),
                              (s = !0)),
                              a.lastSmsLocalId !== i.msgId &&
                                ((a.lastSmsLocalId =
                                  null == i ? void 0 : i.msgId),
                                (s = !0));
                            const n = Object(p.a)(
                              Object(p.a)({}, a),
                              {},
                              { verified: !0 }
                            );
                            return (
                              this.setCacheData(e, n, !0),
                              s && this.updateInDB(n),
                              { conversation: n, updated: !0 }
                            );
                          }
                          {
                            const s = {
                              userId: e,
                              isGroup: e.startsWith(w.GROUPID_PREFIX),
                              pinned: 0,
                              label: null,
                              topOut: void 0,
                              verified: !0,
                              outside: null,
                              cloudMore: !1,
                              firstSmsLocalId: t.msgId,
                              lastSmsLocalId: i.msgId,
                              numMsg: 2,
                              respondedByMe:
                                "0" == t.fromUid || "0" == i.fromUid,
                              infoCheckSearch: n,
                            };
                            return (
                              this.setCacheData(e, s, !0),
                              this.updateInDB(s),
                              { conversation: s, updated: !0 }
                            );
                          }
                        }
                      }
                      mergeConv(e, t) {
                        return (
                          (!e.lastSmsLocalId ||
                            (t.lastSmsLocalId &&
                              t.lastSmsLocalId > e.lastSmsLocalId)) &&
                            ((e.preLastSmsLocalId =
                              e.lastSmsLocalId || t.lastSmsLocalId),
                            (e.lastSmsLocalId = t.lastSmsLocalId),
                            (e.outside = t.outside)),
                          (e.numMsg = (e.numMsg || 0) + t.numMsg),
                          (e.respondedByMe =
                            e.respondedByMe || t.respondedByMe),
                          (!e.firstSmsLocalId ||
                            (t.firstSmsLocalId &&
                              t.firstSmsLocalId < e.firstSmsLocalId)) &&
                            (e.firstSmsLocalId = t.firstSmsLocalId),
                          (!e.infoCheckSearch ||
                            !e.infoCheckSearch.lastMessageTime ||
                            (t.infoCheckSearch &&
                              t.infoCheckSearch.lastMessageTime >
                                e.infoCheckSearch.lastMessageTime)) &&
                            (e.infoCheckSearch = t.infoCheckSearch),
                          e.preLastSmsLocalId ||
                            (e.preLastSmsLocalId = t.lastSmsLocalId),
                          !t.respondedByMe && t.topOut && (e.topOut = t.topOut),
                          "string" != typeof e.firstSmsLocalId &&
                            (e.firstSmsLocalId = "" + e.firstSmsLocalId),
                          e
                        );
                      }
                      async onEmptyConversation(e) {
                        const t = await this.getConvById(e);
                        if (
                          (b.default.logCoreInfo(
                            `[${this.name}] - onEmptyConversation ${e} ${!!t}`
                          ),
                          !t)
                        )
                          return;
                        const s = Object(p.a)({}, t);
                        return (
                          delete s.firstSmsLocalId,
                          delete s.lastSmsLocalId,
                          (s.numMsg = 0),
                          (s.respondedByMe = !1),
                          this.setCacheData(e, s, !0),
                          this.broadcastEvent(Et.b.EmptyConv, e),
                          Object(yt.g)(this.name, e),
                          N.a.PinDataManager.isPinned(e) &&
                            N.a.PinDataManager.unpin([e]),
                          this.updateInDB(s)
                        );
                      }
                      onDeleteConversation(e) {
                        b.default.logCoreInfo(
                          `[${this.name}] - onDeleteConversation ${e}`
                        );
                        const t = this.data.get(e);
                        return this.doDeleteConversation(e).then((s) => {
                          this.broadcastEvent(Et.b.DeleteConv, e, t);
                        });
                      }
                      doDeleteConversation(e) {
                        const t = this.data.get(e);
                        return (
                          b.default.logCoreInfo(
                            `[${this.name}] - doDeleteConversation ${e} ${!!t}`
                          ),
                          t &&
                            (this.data.delete(e), Object(yt.e)(this.name, e)),
                          N.a.PinDataManager.isPinned(e) &&
                            N.a.PinDataManager.unpinLocal([e]),
                          this.deleteInDB(e)
                        );
                      }
                      onPinConversation(e, t) {
                        return new Promise((s) => {
                          this.doneEventQueue
                            ? this.doUpdatePin(e, t).then(s)
                            : this.pinEventQueue.push(async () => {
                                const i = await this.doUpdatePin(e, t);
                                s(i);
                              });
                        });
                      }
                      doUpdatePin(e, t) {
                        if (t && Ot.a.isStrangerV2(e))
                          return Promise.resolve(null);
                        if (!this.data.get(e)) {
                          if (!t) return Promise.resolve(null);
                          const s = this.getEmptyConv(e);
                          (s.verified = !0), this.setCacheData(e, s);
                        }
                        const s = new Map();
                        return (
                          s.set("pinned", t),
                          this.updateFields(e, s)
                            .then(
                              (s) => (
                                this.broadcastEvent(Et.b.ChangePinConv, e, t), s
                              )
                            )
                            .catch(
                              (t) => (
                                b.default.logCoreInfo(
                                  `[${this.name}] - doUpdatePin err`,
                                  t
                                ),
                                this.data.get(e)
                              )
                            )
                        );
                      }
                      onLeaveGroup(e) {
                        return (
                          b.default.logCoreInfo(
                            `[${this.name}] - onLeaveGroup ${e}`
                          ),
                          this.doDeleteConversation(e).then((t) => {
                            this.broadcastEvent(Et.b.LeaveGroup, e);
                          })
                        );
                      }
                      async onChangeConvLabel(e, t) {
                        return new Promise((s) => {
                          const i = this.data.get(e);
                          if (i && i.label === t) return s(i);
                          this.doneEventQueue
                            ? this.doUpdateConvLabel(e, t).then(s)
                            : this.labelEventQueue.push(async () => {
                                const i = await this.doUpdateConvLabel(e, t);
                                s(i);
                              });
                        });
                      }
                      doUpdateConvLabel(e, t) {
                        if (!e)
                          return (
                            b.default.logCoreInfo(
                              `[${this.name}] - doUpdateConvLabel with undefined ${t}`
                            ),
                            Promise.resolve(null)
                          );
                        const s = this.data.get(e);
                        if (s && s.label === t) return Promise.resolve(s);
                        if (!s) {
                          if (!t) return Promise.resolve(null);
                          const s = this.getEmptyConv(e);
                          (s.verified = !0), this.setCacheData(e, s);
                        }
                        const i = new Map();
                        return (
                          i.set("label", t),
                          this.updateFields(e, i).then(
                            (i) => (
                              this.unreadManager.onChangeConvLabel(
                                e,
                                null == s ? void 0 : s.label,
                                t
                              ),
                              i
                            )
                          )
                        );
                      }
                      onFetchConvLabels(e) {
                        if (!e || !Array.isArray(e)) return;
                        b.default.logCoreInfo(
                          `[${this.name}] - onChangeConvLabel ${e.length}`
                        );
                        const t = {};
                        this.getAllConv().then((s) => {
                          for (let e = 0; e < s.length; e++) t[s[e].userId] = 1;
                          for (let i = 0; i < e.length; i++) {
                            const s = e[i].id,
                              a = e[i].conversations;
                            if (a)
                              for (let e = 0; e < a.length; e++) {
                                const i = a[e];
                                delete t[i], this.onChangeConvLabel(i, s);
                              }
                          }
                          for (const e in t)
                            Object.hasOwnProperty.call(t, e) &&
                              this.onChangeConvLabel(e, null);
                        });
                      }
                      onDeleteConvLabels(e) {
                        b.default.logCoreInfo(
                          `[${this.name}] - onDeleteConvLabels ${e.length}`
                        ),
                          e.forEach((e) => {
                            const t = e.conversations;
                            if (t && t.length)
                              for (let s = 0; s < t.length; s++)
                                this.data.has(t[s]) &&
                                  this.onChangeConvLabel(t[s], null);
                          });
                      }
                      async onUpdateMsgId(e, t, s) {
                        if (!t || !s || t === s)
                          return Promise.reject(
                            "[Conv-info-manager]- call update with invalid params!"
                          );
                        const i = this.data.get(e);
                        let a = i || {},
                          n = !1;
                        if (!i || !i.verified) {
                          const t = await this.DBConvInfo.getById(e);
                          if (!i && !t) {
                            const t = await this.createEmptyConvForUser(
                              e,
                              0,
                              void 0,
                              { firstSmsLocalId: s, lastSmsLocalId: s }
                            );
                            return this.setCacheData(e, t), t;
                          }
                          i && t
                            ? ((a = this.mergeConv(i, t)), (n = !0))
                            : ((a = i || t), (a.verified = !0), (n = !0));
                        }
                        return (
                          (a.firstSmsLocalId && a.firstSmsLocalId !== t) ||
                            ((n = !0), (a.firstSmsLocalId = s)),
                          (a.lastSmsLocalId && a.lastSmsLocalId !== t) ||
                            ((n = !0), (a.lastSmsLocalId = s)),
                          n && (this.setCacheData(e, a), this.updateInDB(a)),
                          a
                        );
                      }
                      async addOrUpdateConv(e, t, s, i, a, n) {
                        "number" == typeof t && (t = "" + t),
                          "number" == typeof s && (s = "" + s);
                        const r = this.data.get(e);
                        b.default.logCoreInfo(
                          `[${this.name}] - addOrUpdateConv ${e} ${!!r} ${s}`
                        );
                        const o = (e) => (
                          (!e.firstSmsLocalId ||
                            (t && t < e.firstSmsLocalId)) &&
                            (e.firstSmsLocalId = t),
                          (!e.lastSmsLocalId || (s && s > e.lastSmsLocalId)) &&
                            (e.lastSmsLocalId = s),
                          (e.cloudMore = i),
                          (e.respondedByMe = e.respondedByMe || a),
                          (e.numMsg = (e.numMsg || 0) + n),
                          e
                        );
                        if (r && r.verified) {
                          const t = o(r);
                          return (
                            this.setCacheData(e, Object(p.a)({}, t)),
                            this.updateInDB(t),
                            t
                          );
                        }
                        {
                          const r = await this.DBConvInfo.getById(e);
                          if (
                            (b.default.logCoreInfo(
                              `[${this.name}] - addOrUpdateConv #2 ${e} ${!!r}`
                            ),
                            r)
                          ) {
                            const t = o(r);
                            return (
                              this.setCacheData(
                                e,
                                Object(p.a)(
                                  Object(p.a)({}, t),
                                  {},
                                  { verified: !0 }
                                )
                              ),
                              this.updateInDB(t),
                              t
                            );
                          }
                          {
                            const r = {
                              userId: e,
                              firstSmsLocalId: t,
                              lastSmsLocalId: s,
                              isGroup: e.startsWith(w.GROUPID_PREFIX),
                              respondedByMe: a,
                              numMsg: n || 2,
                              label: null,
                              pinned: 0,
                              verified: !0,
                              cloudMore: i,
                              outside: null,
                              topOut: null,
                              infoCheckSearch: void 0,
                            };
                            return (
                              this.setCacheData(e, r, !0), this.updateInDB(r), r
                            );
                          }
                        }
                      }
                      async addIfNotExistsConv(e, t, s, i, a, n) {
                        const r = this.data.get(e);
                        if (
                          (b.default.logCoreInfo(
                            `[${
                              this.name
                            }] - addIfNotExistsConv #1 ${e} ${!!r} ${i}`
                          ),
                          r)
                        )
                          return !1;
                        const o = await this.DBConvInfo.getById(e);
                        if (
                          (b.default.logCoreInfo(
                            `[${this.name}] - addIfNotExistsConv #2 ${!!o}`
                          ),
                          o)
                        )
                          return !1;
                        {
                          const r = {
                            userId: e,
                            firstSmsLocalId: s,
                            lastSmsLocalId: i,
                            isGroup: t || e.startsWith(w.GROUPID_PREFIX),
                            respondedByMe: a,
                            numMsg: n || 1,
                            label: null,
                            pinned: 0,
                            verified: !0,
                            outside: null,
                            topOut: null,
                            infoCheckSearch: void 0,
                          };
                          return (
                            this.setCacheData(e, r, !0), this.updateInDB(r), !0
                          );
                        }
                      }
                      createEmptyConvForUser(
                        e,
                        t,
                        s = w.CONV_OT_STATE.none,
                        i
                      ) {
                        return new Promise((a, n) => {
                          this.getConvById(e)
                            .then((a) => {
                              let n;
                              if (
                                (b.default.logCoreInfo(
                                  `[${
                                    this.name
                                  }] - createEmptyConvForUser ${e} ${!!a}`
                                ),
                                a)
                              ) {
                                const i = new Map();
                                return (
                                  (n = a),
                                  s !== w.CONV_OT_STATE.none &&
                                    void 0 !== s &&
                                    ((n.outside = s), i.set("outside", s)),
                                  t &&
                                    !N.a.PinDataManager.isPinned(n.userId) &&
                                    N.a.PinDataManager.pin([n.userId]),
                                  this.updateFields(e, i),
                                  n
                                );
                              }
                              return (
                                (n = Object(p.a)(
                                  {
                                    userId: e,
                                    lastMessageTime: t ? 0 : Y.a.getTimeNow(),
                                    isGroup: e.startsWith(w.GROUPID_PREFIX),
                                  },
                                  i
                                )),
                                s !== w.CONV_OT_STATE.none &&
                                  void 0 !== s &&
                                  (n.outside = s),
                                t && N.a.PinDataManager.pin([n.userId]),
                                (n.verified = !0),
                                this.setCacheData(e, n, !0),
                                this.updateInDB(n),
                                n
                              );
                            })
                            .then((e) => {
                              a(e);
                            })
                            .catch((e) => {
                              b.default.logCoreError(e), n(e);
                            });
                        });
                      }
                      updateLastMsgId(e, t) {
                        const s = this.data.get(e);
                        if (s && s.lastSmsLocalId === t)
                          return Promise.resolve(s);
                        const i = new Map();
                        return (
                          i.set("lastSmsLocalId", t), this.updateFields(e, i)
                        );
                      }
                      updateInfoCheckSearch(e, t, s) {
                        const i = this.data.get(e);
                        if (
                          i &&
                          i.infoCheckSearch &&
                          i.infoCheckSearch.lastMessageTime === t
                        )
                          return Promise.resolve(i);
                        const a = new Map();
                        return (
                          a.set("infoCheckSearch", {
                            lastMessageTime: t,
                            lastType: s,
                          }),
                          this.updateFields(e, a)
                        );
                      }
                      updateConvSetting(e, t) {
                        let s = this.data.get(e);
                        if (!s) {
                          const i = !!this.doneLoadDB;
                          (s = { userId: e, verified: i }),
                            i ||
                              b.default.logCoreInfo(
                                `[${this.name}] - update conv setting before done load db ${e}`,
                                t
                              );
                        }
                        b.default.shallowEqual(s.setting, t) ||
                          ((s.setting = t),
                          this.setCacheData(e, s, !0),
                          b.default.logCoreInfo(
                            `[${this.name}] - update conv setting for conv ${e}`,
                            t
                          ));
                      }
                      async isRespondedByMe(e) {
                        const t = await this.getConvById(e);
                        return !!t && Boolean(t.respondedByMe);
                      }
                      isRespondedByMeSync(e) {
                        const t = this.data.get(e);
                        return !!t && Boolean(t.respondedByMe);
                      }
                      isDoneLoadDB() {
                        return this.doneLoadDB;
                      }
                      getConvByIdSync(e) {
                        return (
                          "string" != typeof e &&
                            b.default.logCoreInfo(
                              `[${this.name}] - getConvByIdSync with invalid id type`,
                              e,
                              !!this.data.get(e),
                              !!this.data.get("" + e)
                            ),
                          this.data.get(e)
                        );
                      }
                      getConvById(e) {
                        return new Promise((t, s) => {
                          if (this.data.has(e)) return t(this.data.get(e));
                          this.DBConvInfo.getById(e)
                            .then((e) => {
                              t(e);
                            })
                            .catch(s);
                        });
                      }
                      getAllConvSync() {
                        return Array.from(this.data.values()) || [];
                      }
                      getAllConv() {
                        return new Promise((e, t) => {
                          if (this.doneLoadDB) {
                            return e(this.getAllConvSync());
                          }
                          this.fetchAllHolder ||
                            (this.fetchAllHolder = this.DBConvInfo.getAll()),
                            this.fetchAllHolder.then(e).catch(t);
                        });
                      }
                      getAllConvIdsSync() {
                        return Array.from(this.data.keys());
                      }
                      setPreloadCache(e) {
                        this.preloadCached = e;
                      }
                      onDoneSyncMobile() {
                        b.default.logCoreInfo(
                          `[${this.name}] - onDoneSyncMobile`
                        ),
                          this.getAllConv().then((e) => {
                            e &&
                              this.previewManager.migrate(
                                e.map((e) => e.userId),
                                !0
                              );
                          });
                      }
                      setCacheData(e, t, s = !1) {
                        this.data.set(t.userId, t),
                          s && Object(yt.g)(this.name, e);
                      }
                      updateFields(e, t) {
                        return new Promise((s, i) => {
                          const a = this.data.get(e),
                            n = (a) => {
                              b.default.logCoreInfo(
                                `[${this.name}] - updateFields #2`
                              );
                              const n = Object(p.a)({}, a);
                              t.forEach((e, t) => {
                                n[t] = e;
                              }),
                                this.setCacheData(e, n, !0),
                                this.updateInDB(n)
                                  .then(() => {
                                    s(n);
                                  })
                                  .catch(i);
                            };
                          a
                            ? n(a)
                            : this.DBConvInfo.getById(e).then((e) => {
                                e && n(e);
                              });
                        });
                      }
                      forkDeleteCacheAndDB(e) {
                        if (
                          (b.default.logCoreInfo(
                            `[${this.name}] - forkDeleteCacheAndDB ${e}`
                          ),
                          !N.a.PinDataManager.isPinned(e))
                        ) {
                          const t = this.data.get(e);
                          b.default.logCoreInfo(
                            `[${this.name}] - forkDeleteCacheAndDB ${e} ${!!t}`
                          ),
                            this.data.delete(e),
                            Object(yt.e)(this.name, e),
                            this.deleteInDB(e).then((s) => {
                              this.broadcastEvent(Et.b.DeleteConv, e, t);
                            });
                        }
                      }
                      broadcastEvent(e, t = "", s) {
                        this.dispatchEvent(new Et.a(e, t, s));
                      }
                      shouldSignalUpdate(e, t) {
                        return (
                          N.a.PinDataManager.isPinned(e.userId) !==
                            N.a.PinDataManager.isPinned(t.userId) ||
                          e.label !== t.label ||
                          e.respondedByMe !== t.respondedByMe
                        );
                      }
                      cleanConversation(e) {
                        return (
                          Object.keys(e).forEach((t) => {
                            ga.includes(t) || delete e[t];
                          }),
                          e
                        );
                      }
                      getEmptyConv(e) {
                        return {
                          userId: e,
                          isGroup: e.startsWith(w.GROUPID_PREFIX),
                          numMsg: 0,
                          respondedByMe: !1,
                          pinned: 0,
                          label: null,
                          outside: null,
                          infoCheckSearch: null,
                          topOut: null,
                        };
                      }
                      updateInDB(e) {
                        const t = this.cleanConversation(Object(p.a)({}, e));
                        return this.DBConvInfo.addOrUpdate(t).catch((e) => {
                          b.default.logCoreInfo(
                            `[${this.name}] - updateInDB got error ${e}`
                          );
                        });
                      }
                      deleteInDB(e) {
                        return this.DBConvInfo.remove(e).catch((e) => {
                          b.default.logCoreInfo(
                            `[${this.name}] - deleteInDB got error ${e}`
                          );
                        });
                      }
                    })
                  ) || na)
              ) || na)
          ) || na)
      );
      var pa = s("NSWB"),
        ma = s("1Abx"),
        va = s("XEtq"),
        fa = s("ZRfj"),
        ba = s("EqtE"),
        _a = s("oH3T"),
        Sa = s("13iL"),
        ya = s("mea/"),
        Ca = s("MPLC"),
        Ia = s("WK05");
      var Oa,
        Ea = s("dwTj"),
        Ta = s("RVT8"),
        Ra = s("hkvp"),
        La = s("6tnf"),
        Ma = s("sg3c"),
        Fa = s("4pY7"),
        wa = s("ofhN"),
        Da = s("D8f9");
      const ja = "9999999999999999",
        Aa = "zum_m",
        Na = "1.0.0",
        Pa = !1,
        ka = "total",
        Ua = (e) => ({
          convId: e,
          smsUnreadCount: 0,
          smsUnreadNotCount: 0,
          mentionUnreadCount: 0,
          strangerUnreadCount: 0,
          lastProcessMsgId: "",
          lastSeenReactId: "",
          unreadMark: void 0,
        }),
        Ba = { CALL_INIT: !1 },
        Ga = 1,
        za = 2;
      Object(B.b)(Ta.b)(
        (Oa =
          (function (e, t) {
            return a.ModuleContainer.inject(Ra.b)(e, void 0, 0);
          })(
            (Oa =
              Reflect.metadata(
                "design:type",
                Function
              )(
                (Oa =
                  Reflect.metadata("design:paramtypes", [
                    void 0 === Et.IReactiveDB ? Object : Et.IReactiveDB,
                  ])(
                    (Oa = class extends re.b {
                      constructor(e) {
                        super(),
                          (this.DBConvUnread = e),
                          Object(i.a)(this, "name", void 0),
                          Object(i.a)(this, "key", void 0),
                          Object(i.a)(this, "didInit", void 0),
                          Object(i.a)(this, "doneLoadDB", void 0),
                          Object(i.a)(this, "data", void 0),
                          Object(i.a)(this, "pendingMessage", void 0),
                          Object(i.a)(this, "previewMsgs", void 0),
                          Object(i.a)(this, "pendingClearUnread", void 0),
                          Object(i.a)(this, "fetchAllHolder", void 0),
                          Object(i.a)(this, "total", void 0),
                          Object(i.a)(this, "loadState", Ba),
                          Object(i.a)(this, "isLoadDBStarted", void 0),
                          Object(i.a)(this, "updateTotalQueue", void 0),
                          Object(i.a)(this, "_logger", void 0),
                          Object(i.a)(this, "setupQueue", () =>
                            Object(da.queue)(async (e) => {
                              this.doneLoadDB &&
                                (await this.calculateComputeUnreadCount(e));
                            }, 1)
                          ),
                          Object(i.a)(
                            this,
                            "_getDeletedMsgByTTLItem",
                            (e, t) => {
                              if (t)
                                return t.find((t) =>
                                  e.msgId
                                    ? e.msgId === t.msgId
                                    : e.cliMsgId === t.cliMsgId
                                );
                            }
                          ),
                          (this.name = Ta.a),
                          (this.key = "convId"),
                          (this.didInit = !1),
                          (this.doneLoadDB = !1),
                          (this.data = new Map()),
                          (this.isLoadDBStarted = !1),
                          (this.pendingMessage = new Map()),
                          (this.previewMsgs = []),
                          (this.pendingClearUnread = new Map()),
                          (this.fetchAllHolder = null),
                          (this.total = this.getEmptyTotal()),
                          (this.updateTotalQueue = this.setupQueue());
                      }
                      init() {
                        this.didInit ||
                          (this.logger.zsymb(3, 10093, 3e4, "call init unread"),
                          (this.didInit = !0),
                          this.addListener(),
                          this.onState("CALL_INIT"));
                      }
                      onState(e) {
                        this.loadState[e] = !0;
                        const t = Object.values(this.loadState).every(
                          (e) => !0 === e
                        );
                        t &&
                          !this.isLoadDBStarted &&
                          (this.logger.zsymb(
                            3,
                            10093,
                            30001,
                            "done all state, ready to load db..."
                          ),
                          this.loadData());
                      }
                      get logger() {
                        return (
                          this._logger ||
                            (this._logger = a.ModuleContainer.resolve(
                              O.ZLoggerFactory
                            ).createZLogger(Ut.b.conversation, [Ut.b.unread])),
                          this._logger
                        );
                      }
                      getEmptyTotal() {
                        return {
                          convId: "total",
                          smsUnreadCount: 0,
                          smsUnreadNotCount: 0,
                          mentionUnreadCount: 0,
                          strangerUnreadCount: 0,
                          lastProcessMsgId: "0",
                          lastSeenReactId: "0",
                          unreadMark: 0,
                          smsUnreadNomute: 0,
                        };
                      }
                      loadData() {
                        const e = r.a.getInstance().getItemForCurrentUser(Aa);
                        if (e === Na)
                          (this.isLoadDBStarted = !0),
                            this.logger.zsymb(
                              3,
                              10093,
                              30002,
                              "start load unread {}",
                              e
                            ),
                            this.fetchAllHolder ||
                              (this.fetchAllHolder =
                                this.DBConvUnread.getAll()),
                            this.fetchAllHolder.then((e) => {
                              this.onLoadUnreadFromDBV2(za, e),
                                this.doDoneLoadDBTask();
                            });
                        else {
                          N.a.ConvInfoDataManager.isDoneLoadDB() &&
                            ((this.isLoadDBStarted = !0), this.migrateV2());
                        }
                      }
                      async migrateV2() {
                        const e = r.a.getInstance(),
                          t = e.getItemForCurrentUser(Aa) === Na;
                        if (
                          (this.logger.zsymb(
                            3,
                            10093,
                            30003,
                            "call migrate unread {}",
                            t
                          ),
                          t)
                        )
                          return;
                        const s = N.a.ConvInfoDataManager.getAllConvSync(),
                          i = [];
                        s.forEach((e) => {
                          const t = e.smsUnreadCount || 0,
                            s = e.smsUnreadNotCount || 0,
                            a = e.mentionUnreadCount || 0,
                            n = e.unreadMark || null;
                          if (!(e && e.userId && (t || s || a || n))) return;
                          const r = {
                            convId: e.userId,
                            smsUnreadCount: t,
                            smsUnreadNotCount: s,
                            strangerUnreadCount: 0,
                            mentionUnreadCount: a,
                            lastProcessMsgId:
                              e.lastMessageIdFromServerv2 || "0",
                            lastSeenReactId: e.lastSeenReactId || "0",
                            unreadMark: n,
                          };
                          i.push(r);
                        }),
                          this.onLoadUnreadFromDBV2(Ga, i),
                          this.doDoneLoadDBTask(),
                          this.logger.zsymb(
                            3,
                            10093,
                            30004,
                            "done migrate unread {}",
                            i.length
                          ),
                          e.setItemForCurrentUser(Aa, Na);
                      }
                      doDoneLoadDBTask() {
                        const e = Array.from(this.data.values());
                        (this.doneLoadDB = !0),
                          this.broadcastEvent(Et.b.DoneLoadDB, "total", e),
                          this.logger.zsymb(
                            3,
                            10093,
                            30005,
                            "done load unread {}",
                            e.length
                          ),
                          a.ModuleContainer.resolve(Fa.a).onLoadUnreads(e),
                          setTimeout(() => {
                            this.unreadChanged("init");
                          }, 200);
                      }
                      addListener() {
                        N.a.MuteDataManager.addEventListener(
                          Et.b.MuteChanged,
                          (e) => {
                            this.onMuteConversation(e.convId, !!e.payload);
                          }
                        ),
                          N.a.ConvInfoDataManager.addEventListener(
                            Et.b.LeaveGroup,
                            (e) => {
                              this.doDeleteUnread(e.convId);
                            }
                          ),
                          N.a.ConvInfoDataManager.addEventListener(
                            Et.b.DeleteConv,
                            (e) => {
                              this.doDeleteUnread(e.convId);
                            }
                          ),
                          N.a.ConvInfoDataManager.addEventListener(
                            Et.b.EmptyConv,
                            (e) => {
                              this.doDeleteUnread(e.convId);
                            }
                          ),
                          N.a.ConvInfoDataManager.addEventListener(
                            Et.b.DoneLoadDB,
                            (e) => {
                              this.onState("CALL_INIT");
                            }
                          ),
                          N.a.ArchivedChatManager.addEventListener(
                            Et.b.UpdateListArchivedChat,
                            (e) => {
                              this.onArchivedChat(e.convId);
                            }
                          ),
                          _.default.subscribe((e, t) => {
                            if (
                              null != t &&
                              t.length &&
                              e ===
                                y.ConversationListActions.CLEAR_MARK_AS_UNREAD
                            )
                              t.forEach((e) => {
                                this.updateUnreadMark(e, null);
                              });
                            else if (
                              null != t &&
                              t.length &&
                              e === y.GeneralActions.UPDATE_HIDDEN_CHAT
                            )
                              for (let s = 0; s < t.length; s++) {
                                const e = t[s];
                                this.onHiddenConversation(e.uid, e.isHide);
                              }
                          });
                      }
                      getItem(e, t) {
                        if (e.key === ka) return this.total;
                        return this.data.get(e.key);
                      }
                      getList(e, t) {
                        return Array.from(this.data.keys());
                      }
                      onGetItemFailure(e) {}
                      onGetListFailure(e) {
                        throw new Error("Method not implemented.");
                      }
                      onMuteConversation(e, t) {
                        const s = this.data.get(e);
                        !s ||
                          (s.smsUnreadCount < 1 && !s.unreadMark) ||
                          ae.a.isThreadHidden(e) ||
                          Ot.a.isOAType({ userId: e }) ||
                          (this.logger.zsymb(
                            0,
                            10093,
                            30006,
                            "onMuteConversation:",
                            e,
                            t,
                            s.smsUnreadCount,
                            s.smsUnreadNotCount
                          ),
                          this.unreadChanged(e));
                      }
                      onHiddenConversation(e, t) {
                        const s = this.data.get(e);
                        !s ||
                          (s.smsUnreadCount < 1 && !s.unreadMark) ||
                          $e.default.isMuted(e) ||
                          Ot.a.isOAType({ userId: e }) ||
                          (this.logger.zsymb(
                            0,
                            10093,
                            30007,
                            "onHiddenConversation: ",
                            e,
                            t,
                            s.smsUnreadCount,
                            s.smsUnreadNotCount
                          ),
                          this.unreadChanged(e));
                      }
                      onArchivedChat(e) {
                        const t = this.data.get(e);
                        !t ||
                          (t.smsUnreadCount < 1 && !t.unreadMark) ||
                          $e.default.isMuted(e) ||
                          Ot.a.isOAType({ userId: e }) ||
                          this.unreadChanged(e);
                      }
                      onChangeConvLabel(e, t, s) {
                        const i = this.data.get(e);
                        t === s ||
                          !i ||
                          i.smsUnreadCount < 1 ||
                          $e.default.isMuted(e) ||
                          this.unreadChanged(e);
                      }
                      onReceivePreviewMessages(e) {
                        e.length > 0 &&
                          (this.previewMsgs = [...this.previewMsgs, ...e]);
                      }
                      onReceiveNewMessagesOld(e, t, s) {
                        if (!s || !t) return;
                        const i = this.data.get(e);
                        if (i)
                          this.logger.zsymb(
                            0,
                            10093,
                            30008,
                            "receive msg",
                            e,
                            i.lastProcessMsgId,
                            s
                          ),
                            (!i.lastProcessMsgId || i.lastProcessMsgId < t) &&
                              (this.handleNewMessages(e, s, t),
                              Object(yt.g)(this.name, e));
                        else {
                          const t = this.pendingMessage.get(e),
                            i = t ? s.concat(t) : s;
                          this.pendingMessage.set(e, i),
                            i.length === s.length &&
                              this.DBConvUnread.getById(e).then((t) => {
                                if (!t) {
                                  const t = this.pendingMessage.get(e);
                                  if (t) {
                                    const s = t.filter(
                                        (e, t, s) => s.indexOf(e) === t
                                      ),
                                      i = Pt.b.getLastMessageInList(s);
                                    if (!i) return;
                                    this.pendingMessage.delete(e),
                                      this.handleNewMessages(e, s, i.msgId),
                                      Object(yt.g)(this.name, e);
                                  }
                                }
                              });
                        }
                      }
                      onReceiveNewMessages(e, t, s) {
                        if (!s || !s.length || !t) return;
                        const i = this.data.get(e);
                        if (this.doneLoadDB) {
                          if (
                            !i ||
                            !i.lastProcessMsgId ||
                            i.lastProcessMsgId < t
                          ) {
                            const a = s.map((e) => e.msgId).join("-");
                            this.logger.zsymb(
                              0,
                              10093,
                              30009,
                              `onReceiveNewMessages: ${
                                null == i ? void 0 : i.lastProcessMsgId
                              } ${e} ${t} ${a}`
                            ),
                              this.handleNewMessages(e, s, t),
                              Object(yt.g)(this.name, e);
                          }
                        } else {
                          const t = this.pendingMessage.get(e),
                            i = t ? s.concat(t) : s;
                          this.pendingMessage.set(e, i);
                        }
                      }
                      onDoneOffLineMessages() {
                        this.logger.zsymb(0, 10093, 30010, "ph7 done offline"),
                          as.b.onDoneEntry(as.a.FIRST_FETCH),
                          this.previewMsgs.length > 0 &&
                            setTimeout(() => {
                              this.handlePreviewMsgs();
                            }, 0);
                      }
                      doDeleteUnread(e) {
                        if (!e) return;
                        const t = this.data.get(e);
                        this.logger.zsymb(
                          0,
                          10093,
                          30011,
                          `doDeleteUnread ${!!t}`
                        ),
                          this.data.delete(e) &&
                            (Object(yt.e)(this.name, e), this.unreadChanged(e)),
                          this.deleteInDB(e);
                      }
                      onReceiveDeleteConvMsg(e, t) {
                        if (this.doneLoadDB) {
                          const s = this.safeGetUnreadCached(e);
                          if (0 === s.smsUnreadCount) return;
                          if (t >= +s.lastProcessMsgId) {
                            const t = Object(p.a)(
                              Object(p.a)({}, s),
                              {},
                              { smsUnreadCount: 0, smsUnreadNotCount: 0 }
                            );
                            this.data.set(t.convId, t),
                              Object(yt.g)(this.name, e),
                              this.unreadChanged(e);
                          }
                        } else this.pendingClearUnread.set(e, t);
                      }
                      onClearUnreadConversations(e) {
                        if (!e || e.length < 0) return;
                        let t = [];
                        for (let s = 0; s < e.length; s++) {
                          const i = e[s],
                            a = this.data.get(i.userId) || Ua(i.userId);
                          this.logger.zsymb(
                            0,
                            10093,
                            30012,
                            "onClearUnreadConversations",
                            !!i,
                            null == a ? void 0 : a.smsUnreadCount
                          ),
                            i &&
                              (t.push(i.userId),
                              a.smsUnreadCount > 0 &&
                                $e.default
                                  .getLastMessageFrom(
                                    i.userId,
                                    i.lastSmsLocalId,
                                    ja,
                                    a.smsUnreadCount,
                                    !0
                                  )
                                  .then((e) => {
                                    let t = {};
                                    if (e && e.length > 0)
                                      for (let i = 0; i < e.length; i++) {
                                        let s = e[i];
                                        b.default.validMessageFromOther(s) &&
                                          (t[s.msgId] = s);
                                      }
                                    const s = {
                                      userId: i.userId,
                                      lastSmsLocalId: i.lastSmsLocalId,
                                      smsUnreadCount: a.smsUnreadCount,
                                    };
                                    this.clearUnreadConversation(s, t),
                                      this.resetUnreadToZero(
                                        i.userId,
                                        a.lastProcessMsgId
                                      );
                                  })
                                  .catch((e) => {
                                    this.logger.zsymb(
                                      21,
                                      10093,
                                      30013,
                                      "clear unread conv failure {}",
                                      e
                                    );
                                  }),
                              Ia.a.clearUnreadIfExist({
                                userId: i.userId,
                                lastSeenReactId: a.lastSeenReactId,
                              }));
                        }
                        ba.a.clearUnreadMark(t, e.length);
                      }
                      onReadConversation(e, t) {
                        var s;
                        if (
                          I.default.mark_unread.enable &&
                          !ba.a.canSendUnread(e)
                        )
                          return (
                            this.logger.zsymb(
                              0,
                              10093,
                              30014,
                              `[read-message] dont clear ${e}`,
                              I.default.mark_unread.enable,
                              ba.a.canSendUnread(e)
                            ),
                            !1
                          );
                        ba.a.getUnreadMark(e) &&
                          (e.startsWith(w.GROUPID_PREFIX)
                            ? Z.e.logAction(2160024)
                            : Z.e.logAction(2160023),
                          Z.e.logAction(2160022));
                        const i = this.data.get(e) || Ua(e),
                          a = i.smsUnreadCount;
                        if (!t && !a) {
                          this.logger.zsymb(
                            0,
                            10093,
                            30015,
                            `[read-message] dont clear ${e} unread `,
                            a,
                            t
                          );
                          const s = Ia.a.sendClearUnread(e, i.lastSeenReactId);
                          return (
                            ba.a.clearUnreadMark([e], 0),
                            s != i.lastSeenReactId &&
                              ((i.lastSeenReactId = s),
                              this.data.set(e, Object(p.a)({}, i)),
                              Object(yt.g)(this.name, e),
                              this.updateInDB(i)),
                            !1
                          );
                        }
                        const n = this.acquireConvManager().getConvByIdSync(e);
                        if (!n)
                          return (
                            this.logger.zsymb(
                              0,
                              10093,
                              30016,
                              `[read-message] convinfo not exists ${e}`
                            ),
                            !1
                          );
                        const r = [],
                          o = {},
                          c = n.lastSmsLocalId
                            ? n.lastSmsLocalId.toString().split("_")[0]
                            : "";
                        let l = !1;
                        const d =
                          null === (s = Ca.b.messageCache) || void 0 === s
                            ? void 0
                            : s.getLast({ userId: e }, a);
                        for (let g = d.length - 1; g > -1; g--) {
                          let e = d[g];
                          if (
                            b.default.validMessageFromOther(e) &&
                            e.zglobalMsgId &&
                            -1 != e.zglobalMsgId &&
                            !r.includes(e.zglobalMsgId) &&
                            (r.push(e.zglobalMsgId),
                            (o[e.zglobalMsgId] = e),
                            e.zglobalMsgId == c && (l = !0),
                            r.length == a)
                          )
                            break;
                        }
                        const h = {
                          userId: e,
                          lastSmsLocalId: n.lastSmsLocalId,
                          smsUnreadCount: a,
                        };
                        var u;
                        !c || l || o[c]
                          ? this.clearUnreadConversation(h, o)
                          : (this.logger.zsymb(
                              0,
                              10093,
                              30017,
                              `[read-message] append lastMsgIdInConv ${c} ${
                                Object.keys(o).length
                              }`
                            ),
                            null === (u = Ca.b.messageCache) ||
                              void 0 === u ||
                              u
                                .getMessageByMsgIdAsync(c)
                                .then((e) => {
                                  (o[c] = Object(p.a)({}, e)),
                                    this.clearUnreadConversation(h, o);
                                })
                                .catch((e) => {
                                  this.clearUnreadConversation(h, o);
                                }));
                        return (
                          ba.a.clearUnreadMark([e], 0),
                          (i.lastSeenReactId = Ia.a.sendClearUnread(
                            e,
                            i.lastSeenReactId
                          )),
                          this.resetUnreadToZero(e, i.lastProcessMsgId),
                          !0
                        );
                      }
                      getUnreadByConvIdSync(e) {
                        return this.data.get(e);
                      }
                      getUnreadByConvId(e) {
                        return new Promise((t, s) => {
                          if (this.data.has(e))
                            return t(this.getUnreadByConvIdSync(e));
                          this.DBConvUnread.getById(e)
                            .then((e) => t(e))
                            .catch(s);
                        });
                      }
                      getAllUnreadsSync() {
                        return Array.from(this.data.values());
                      }
                      getAllUnreads() {
                        return new Promise((e, t) => {
                          if (this.doneLoadDB)
                            return e(this.getAllUnreadsSync());
                          this.fetchAllHolder ||
                            (this.fetchAllHolder = this.DBConvUnread.getAll()),
                            this.fetchAllHolder.then((t) => e(t)).catch(t);
                        });
                      }
                      resetUnreadToZero(e, t) {
                        return this.getUnreadByConvId(e).then((s) => {
                          if (
                            (_a.b.onClearUnreadConv(e),
                            !s || (!s.smsUnreadCount && !s.smsUnreadNotCount))
                          )
                            return !1;
                          this.logger.zsymb(
                            3,
                            10093,
                            30018,
                            "resetUnreadToZero {} {} {}",
                            e,
                            t,
                            s.smsUnreadCount
                          );
                          const i = {
                            convId: e,
                            smsUnreadCount: 0,
                            mentionUnreadCount: 0,
                            strangerUnreadCount: 0,
                            smsUnreadNotCount: 0,
                            lastProcessMsgId: t,
                            lastSeenReactId: s.lastSeenReactId || "",
                            unreadMark: s.unreadMark,
                          };
                          return (
                            s.smsUnreadCount > 0 && fa.a.notiMainClearunread(e),
                            this.forkUpdateCacheAndDB(i)
                              .then(
                                (t) => (
                                  this.broadcastEvent(Et.b.ReadConv, e), !0
                                )
                              )
                              .catch(
                                (t) => (
                                  this.logger.zsymb(
                                    21,
                                    10093,
                                    30019,
                                    "resetUnreadToZero failure {} {}",
                                    e,
                                    t
                                  ),
                                  !1
                                )
                              )
                          );
                        });
                      }
                      isUnreadMessage(e) {
                        const {
                            message: t,
                            convId: s,
                            lastProcessMsgId: i,
                          } = e,
                          a = Pt.b.isMyMessage(t),
                          n = ma.b.isRead({
                            userId: s,
                            actionId: t.actionId,
                            msgId: t.msgId,
                            msgSendDttm: t.ts || t.serverTime || t.sendDttm,
                            msgLocalId: void 0,
                            e2eeStatus: Object(Ma.f)(t),
                          }),
                          r = !t.msgId || !i || t.msgId <= i;
                        return !n && r && !a;
                      }
                      _updateTTLUnreadCount(e, t, s) {
                        const i = this.data.get(e) || null;
                        if (
                          (this.logger.zsymb(
                            0,
                            10093,
                            30020,
                            "_updateTTLUnreadCount",
                            e,
                            null == i ? void 0 : i.smsUnreadCount
                          ),
                          i &&
                            i.smsUnreadCount === t &&
                            i.smsUnreadNotCount === s)
                        )
                          return;
                        let a = this.safeGetUnreadCached(e);
                        (a.smsUnreadCount = t),
                          (a.smsUnreadNotCount = s),
                          this.forkUpdateCacheAndDB(a);
                      }
                      updateUnreadTTLConversation(e, t, s) {
                        const i = this.getUnreadByConvIdSync(e);
                        if (i) {
                          let a = i.smsUnreadCount,
                            n = i.smsUnreadNotCount;
                          t
                            .filter(
                              (t) =>
                                t.ttlType === Da.a.Message &&
                                this.isUnreadMessage({
                                  message: this._getDeletedMsgByTTLItem(t, s),
                                  convId: e,
                                  lastProcessMsgId: i.lastProcessMsgId,
                                })
                            )
                            .forEach((e) => {
                              const t = this._getDeletedMsgByTTLItem(e, s),
                                i = b.default.getDataReminder(t),
                                r = Pt.b.isMyMessage(t);
                              i && r && (t.idTo === I.default.sendToMeId || r)
                                ? ((n -= 1), (a -= 1))
                                : (a -= 1);
                            }),
                            this._updateTTLUnreadCount(
                              e,
                              Math.max(a, 0),
                              Math.max(n, 0)
                            );
                        }
                      }
                      updateUnreadCount(e, t) {
                        const s = this.data.get(e) || null;
                        if (
                          (this.logger.zsymb(
                            0,
                            10093,
                            30021,
                            "updateUnreadCount",
                            e,
                            null == s ? void 0 : s.smsUnreadCount
                          ),
                          s && s.smsUnreadCount === t)
                        )
                          return;
                        let i = this.safeGetUnreadCached(e);
                        (i.smsUnreadCount = t), this.forkUpdateCacheAndDB(i);
                      }
                      updateMentionCount(e, t) {
                        this.logger.zsymb(
                          0,
                          10093,
                          30022,
                          "updateMentionCount",
                          e,
                          t
                        );
                        let s = this.safeGetUnreadCached(e);
                        (s.mentionUnreadCount = t),
                          this.forkUpdateCacheAndDB(s, !1),
                          La.a.updateUnreadMentions(
                            this.getTotalMentionCount()
                          );
                      }
                      updateLastSeenReactId(e, t) {
                        let s = this.safeGetUnreadCached(e);
                        (s.lastSeenReactId = t),
                          this.forkUpdateCacheAndDB(s, !1);
                      }
                      updateUnreadMark(e, t) {
                        let s = this.safeGetUnreadCached(e);
                        s.unreadMark || (s.unreadMark = null),
                          t || (t = null),
                          t !== s.unreadMark &&
                            ((this.total.unreadMark += t ? 1 : -1),
                            Object(yt.g)(this.name, ka),
                            (s.unreadMark = t),
                            this.forkUpdateCacheAndDB(s));
                      }
                      shouldClearUnread(e, t) {
                        const s = this.data.get(e),
                          i = null == s ? void 0 : s.smsUnreadCount,
                          a = null == s ? void 0 : s.lastProcessMsgId;
                        return !!i && !!(a && t && +t >= +a);
                      }
                      async forkUpdateCacheAndDB(e, t = !0) {
                        this.data.set(e.convId, e),
                          Object(yt.g)(this.name, e.convId),
                          t &&
                            this.isValidConvKey(e.convId) &&
                            this.unreadChanged(e.convId),
                          await this.updateInDB(e);
                      }
                      safeGetUnreadCached(e) {
                        const t = this.data.get(e);
                        let s;
                        return (
                          (s = t
                            ? Object(p.a)({}, t)
                            : {
                                convId: e,
                                smsUnreadCount: 0,
                                smsUnreadNotCount: 0,
                                mentionUnreadCount: 0,
                                strangerUnreadCount: 0,
                                lastProcessMsgId: "0",
                                lastSeenReactId: "0",
                                unreadMark: null,
                              }),
                          s
                        );
                      }
                      getTotalMentionCount() {
                        let e = 0;
                        return (
                          this.data.forEach((t) => {
                            e += t.mentionUnreadCount;
                          }),
                          e
                        );
                      }
                      isValidConvKey(e) {
                        return (
                          !(!e || e.length < 3) &&
                          "null" != e &&
                          e !== w.CONV_FILTER.STRANGER &&
                          e !== ka
                        );
                      }
                      unreadChanged(e) {
                        "null" != e &&
                          (this.updateTotalQueue.remove((e) => !0),
                          this.updateTotalQueue.push(e));
                      }
                      async calculateComputeUnreadCount(e) {
                        try {
                          var t;
                          const i = this.getEmptyTotal(),
                            n =
                              (null ===
                                (t = this.data.get(w.CONV_FILTER.STRANGER)) ||
                              void 0 === t
                                ? void 0
                                : t.smsUnreadCount) || 0;
                          let o = 0,
                            c = 0;
                          const l = new Map(),
                            d = new Map(),
                            h = new Map();
                          N.a.LabelDataManager.getAllLabelIds().map((e) => {
                            const t = "" + e;
                            h.set(t, t);
                          });
                          const u = new Map(),
                            g = [];
                          for (let e of Array.from(this.data.keys())) {
                            if (!this.isValidConvKey(e)) continue;
                            const t = this.data.get(e);
                            if (!t || ae.a.isThreadHidden(e)) continue;
                            const s =
                              Boolean(t.smsUnreadCount) ||
                              Boolean(t.smsUnreadNotCount) ||
                              Boolean(t.unreadMark);
                            if (s)
                              if (
                                s &&
                                kt.a.isArchivedChat(e) &&
                                !$e.default.isMuted(e)
                              ) {
                                let t = a.ModuleContainer.resolve(
                                  me.h
                                ).getPreviewByIDSync(e);
                                t &&
                                  c < parseInt(t.messageTime) &&
                                  (c = parseInt(t.messageTime) || 0);
                              } else u.set(e, t), g.push(e);
                          }
                          Pa;
                          if (
                            ((await Ot.a.verifyOATypeAsync(g)).forEach(
                              ({ cid: e, isOA: t }) => {
                                const s = u.get(e),
                                  a = s.convId,
                                  n =
                                    this.acquireConvManager().getConvByIdSync(
                                      a
                                    ),
                                  r = $e.default.isMuted(a);
                                const c = s.smsUnreadCount || 0,
                                  h = s.smsUnreadNotCount || 0;
                                if (
                                  ((i.smsUnreadCount += c),
                                  n &&
                                    !r &&
                                    !t &&
                                    n.userId !==
                                      w.FAKE_CONVERSATION_ID.FRIEND_CENTER)
                                ) {
                                  const e = Math.max(c - h, 0);
                                  i.smsUnreadNomute += e;
                                  const t = n.label ? "" + n.label : "",
                                    r = "0" == t || !!t;
                                  if (
                                    (r &&
                                      (l.has(t)
                                        ? l.set(t, l.get(t) + e)
                                        : l.set(t, e)),
                                    s.unreadMark)
                                  ) {
                                    const e = i.unreadMark || 0;
                                    (i.unreadMark = e + 1),
                                      r &&
                                        (d.has(t)
                                          ? d.set(t, d.get(t) + 1)
                                          : d.set(t, 1));
                                  }
                                  e > 0 && this.isInStrangerBox(a) && (o += e);
                                }
                              }
                            ),
                            this.total.smsUnreadCount !== i.smsUnreadCount ||
                              this.total.smsUnreadNomute !==
                                i.smsUnreadNomute ||
                              this.total.unreadMark !== i.unreadMark)
                          ) {
                            var s;
                            const t =
                                null === (s = this.data.get(e)) || void 0 === s
                                  ? void 0
                                  : s.smsUnreadCount,
                              a = $e.default.isMuted(e);
                            (this.total = i),
                              this.dispatchEvent(
                                new Et.a(Et.b.ChangeUnreadCount, ka, {
                                  unreadNoMute: i.smsUnreadNomute,
                                  totalUnread: i.smsUnreadCount,
                                  convId: e,
                                  currentUnread: t,
                                  curentUnreadNoMute: a ? 0 : t,
                                })
                              ),
                              this.data.set(ka, i),
                              Object(yt.g)(this.name, ka);
                          }
                          const p = a.ModuleContainer.resolve(
                              Wt.b
                            ).isShowUnreadArchivedChat(),
                            m =
                              r.a
                                .getInstance()
                                .getItemForCurrentUser(
                                  "last_time_clear_archive_chat"
                                ) || "0",
                            v = c > parseInt(m);
                          if (
                            (v !== p &&
                              this.dispatchEvent(
                                new Et.a(Et.b.ChangeUnreadArchiveChat, ka, {
                                  hasUnreadArchivedChat: v,
                                })
                              ),
                            n !== o)
                          ) {
                            const e = this.safeGetUnreadCached("");
                            (e.smsUnreadCount = o),
                              (e.convId = w.CONV_FILTER.STRANGER),
                              this.data.set(w.CONV_FILTER.STRANGER, e),
                              Object(yt.g)(this.name, w.CONV_FILTER.STRANGER);
                          }
                          for (let e of Array.from(l.keys())) {
                            const t = this.safeGetUnreadCached("");
                            (t.smsUnreadCount = l.get(e)),
                              (t.unreadMark = d.get(e)),
                              this.data.set(e, t),
                              h.delete(e),
                              Object(yt.g)(this.name, e);
                          }
                          for (let e of Array.from(h.keys()))
                            this.data.delete(e) && Object(yt.g)(this.name, e);
                        } catch (i) {
                          this.logger.zsymb(
                            21,
                            10093,
                            30027,
                            " unread err - contact phucnh7 please!!! {}",
                            i
                          );
                        }
                      }
                      acquireConvManager() {
                        return N.a.ConvInfoDataManager;
                      }
                      onLoadUnreadFromDBV2(e, t) {
                        if (
                          (this.logger.zsymb(
                            0,
                            10093,
                            30029,
                            "onLoadUnreadFromDB",
                            t.length
                          ),
                          t.length < 1)
                        )
                          return;
                        const s = new Date().getTime().toString();
                        Object(yt.i)(s);
                        for (let i = 0; i < t.length; i++) {
                          const a = t[i];
                          if (
                            (ma.b.isRead({
                              userId: a.convId,
                              msgId: +a.lastProcessMsgId,
                              e2eeStatus: void 0,
                              actionId: void 0,
                              msgSendDttm: void 0,
                              msgLocalId: void 0,
                            }) &&
                              (a.smsUnreadCount || a.smsUnreadNotCount) &&
                              (this.logger.zsymb(
                                0,
                                10093,
                                30030,
                                "clear offline",
                                a.convId,
                                a.smsUnreadCount
                              ),
                              (a.smsUnreadCount = 0),
                              (a.strangerUnreadCount = 0),
                              (a.smsUnreadNotCount = 0)),
                            this.pendingClearUnread.has(a.convId))
                          ) {
                            const e = this.pendingClearUnread.get(a.convId);
                            e &&
                              e >= +a.lastProcessMsgId &&
                              (this.logger.zsymb(
                                0,
                                10093,
                                30031,
                                "clear pending",
                                this.pendingClearUnread.size,
                                a.convId
                              ),
                              (a.smsUnreadCount = 0),
                              (a.strangerUnreadCount = 0),
                              (a.smsUnreadNotCount = 0));
                          }
                          "null" === a.lastProcessMsgId &&
                            (a.lastProcessMsgId = ""),
                            this.data.set(a.convId, a),
                            Object(yt.f)(s, this.name, a.convId),
                            e === Ga && this.updateInDB(a),
                            a.unreadMark && this.total.unreadMark++;
                        }
                        this.pendingClearUnread.clear(),
                          this.processPendingMessages(),
                          Object(yt.c)(s);
                      }
                      processPendingMessages() {
                        this.logger.zsymb(
                          0,
                          10093,
                          30032,
                          "start processPendingMessages",
                          this.pendingMessage.size
                        ),
                          this.pendingMessage.forEach((e, t) => {
                            const s = new Map(),
                              i = this.data.get(t);
                            e.forEach((e) => {
                              var t;
                              (!i || i.lastProcessMsgId < e.msgId) &&
                                s.set(
                                  `${(t = e).uidFrom || t.fromUid}_${
                                    t.idTo || t.toUid
                                  }_${t.cliMsgId}`,
                                  e
                                );
                            }),
                              this.logger.zsymb(
                                0,
                                10093,
                                30033,
                                "check processPendingMessages #2",
                                t,
                                null == i ? void 0 : i.smsUnreadCount,
                                e.map((e) => e.msgId),
                                s.keys()
                              );
                            const a = Array.from(s.values()),
                              n = Pt.b.getLastMessageInList(a);
                            this.handleNewMessages(
                              t,
                              a,
                              null == n ? void 0 : n.msgId
                            );
                          }),
                          this.pendingMessage.clear();
                      }
                      handleNewMessages(e, t, s) {
                        if (!t || !t.length) return;
                        let i = !1;
                        const a = {
                            convId: e,
                            strangerUnreadCount: 0,
                            smsUnreadCount: 0,
                            smsUnreadNotCount: 0,
                            mentionUnreadCount: 0,
                            lastProcessMsgId: s,
                            lastSeenReactId: "0",
                          },
                          n = Date.now(),
                          r = new Set();
                        if (
                          (t.forEach((t) => {
                            const o = Pt.b.isMyMessage(t);
                            if (t.status !== w.MSG_READ && !o) {
                              const s = t.ts || t.serverTime || t.sendDttm;
                              ma.b.isRead({
                                userId: e,
                                actionId: t.actionId,
                                msgId: t.msgId,
                                msgSendDttm: s,
                                msgLocalId: void 0,
                                e2eeStatus: Object(Ma.f)(t),
                              }) &&
                                (I.default.stagingAccount &&
                                  this.logger.zsymb(
                                    0,
                                    10093,
                                    30034,
                                    `mark msg status as read ${e} ${t.actionId} ${t.msgId}`
                                  ),
                                (t.status = w.MSG_READ));
                            }
                            let c = va.a.get(t.msgId, t.status);
                            c != t.status &&
                              I.default.stagingAccount &&
                              this.logger.zsymb(
                                0,
                                10093,
                                30035,
                                `change msg status ${t.status} => ${c}`
                              ),
                              (t.status = c);
                            let l = !1;
                            if ("chat.todo" === t.msgType) {
                              let e = t.content;
                              if (e) {
                                "todo.remind" === e.action && (l = !0);
                              }
                            }
                            let d = b.default.getDataReminder(t);
                            var h, u;
                            (t.status !== w.MSG_READ && !o) || !0 === l
                              ? (t.paramsExt &&
                                  b.default.valueValid(
                                    t.paramsExt.countUnread
                                  ) &&
                                  0 == t.paramsExt.countUnread &&
                                  (a.smsUnreadNotCount += 1),
                                this.isCallTimeMessage(t) ||
                                  ((a.smsUnreadCount += 1),
                                  (a.strangerUnreadCount += 1)),
                                pa.b.isMessageMentionMe(t) &&
                                  a.mentionUnreadCount++)
                              : d && o && (t.idTo === I.default.sendToMeId || o)
                              ? ((a.smsUnreadCount += 1),
                                (a.smsUnreadNotCount += 1),
                                this.logger.zsymb(
                                  0,
                                  10093,
                                  30036,
                                  `new unread #2: ${n} ${e} ${t.msgId} ${t.idTo} ${t.toUid} ${t.src} ${s}`
                                ))
                              : !(h = t) ||
                                ("0" == h.uidFrom &&
                                  (null === (u = h.paramsExt) || void 0 === u
                                    ? void 0
                                    : u.platformType) == os.i.DeviceIds.SYSTEM)
                              ? (r.add(t.msgId),
                                this.logger.zsymb(
                                  0,
                                  10093,
                                  30037,
                                  "_addMessages: skipped clear unread for",
                                  t.idTo
                                ))
                              : t.isCallMessage ||
                                ((a.smsUnreadCount = 0),
                                (a.strangerUnreadCount = 0),
                                (a.mentionUnreadCount = 0),
                                (i = !0)),
                              a.smsUnreadCount > 0 &&
                                as.b.markGotUnread(e, t.msgId),
                              as.b.isLastMsgV2(t) &&
                                this.onDoneOffLineMessages();
                          }),
                          r.has(s))
                        )
                          for (let c = t.length - 1; c >= 0; c--) {
                            const s = t[c];
                            if (
                              b.default.validMessageFromServer(s) &&
                              !r.has(s.msgId)
                            ) {
                              this.logger.zsymb(
                                0,
                                10093,
                                30038,
                                "update last process id",
                                e,
                                a.lastProcessMsgId,
                                s.msgId
                              ),
                                (a.lastProcessMsgId = s.msgId);
                              break;
                            }
                            var o;
                            0 == c &&
                              (a.lastProcessMsgId =
                                (null === (o = this.data.get(e)) || void 0 === o
                                  ? void 0
                                  : o.lastProcessMsgId) || "0");
                          }
                        return this.updateUnread(e, i, a);
                      }
                      handlePreviewMsgs() {
                        if (!this.previewMsgs.length) return;
                        const e = [...this.previewMsgs];
                        (this.previewMsgs = []),
                          this.logger.zsymb(
                            0,
                            10093,
                            30039,
                            "handle preview",
                            e.map((e) => e.msgId)
                          ),
                          e.forEach((e) => {
                            const t = e.toUid,
                              s = Ea.default.checkDuplicate(t, {
                                uidFrom: e.fromUid,
                                cliMsgId: e.cliMsgId,
                              });
                            s &&
                              s.src &&
                              s.msgId !== e.msgId &&
                              (this.logger.zsymb(
                                0,
                                10093,
                                30040,
                                "detect dup msg",
                                e.msgId,
                                s.msgId
                              ),
                              (e.msgId = s.msgId)),
                              this.onReceiveNewMessages(t, e.msgId, [e]);
                          });
                      }
                      updateUnread(e, t, s) {
                        let i = this.data.get(e);
                        if (i) {
                          const e = i.lastSeenReactId || "0";
                          t
                            ? (i = s)
                            : ((i.smsUnreadNotCount += s.smsUnreadNotCount),
                              (i.smsUnreadCount += s.smsUnreadCount),
                              (i.strangerUnreadCount += s.strangerUnreadCount),
                              (i.mentionUnreadCount += s.mentionUnreadCount),
                              (i.lastProcessMsgId = s.lastProcessMsgId)),
                            (i.lastSeenReactId = e);
                        } else {
                          if (((i = s), !i))
                            return void this.logger.zsymb(
                              18,
                              10093,
                              30041,
                              `updateUnread undefined item ${e}`
                            );
                          i.lastSeenReactId = wa.a.getLastSeen(e) || "0";
                        }
                        this.data.set(e, Object.assign({}, i)),
                          this.updateInDB(i),
                          0 != s.mentionUnreadCount &&
                            La.a.updateUnreadMentions(
                              this.getTotalMentionCount()
                            ),
                          this.unreadChanged(e);
                      }
                      isInStrangerBox(e) {
                        const t = N.a.ConvInfoDataManager.getConvByIdSync(e);
                        return fa.a.isInStrangerBox(t);
                      }
                      isCallTimeMessage(e) {
                        if ("chat.recommended" === e.msgType && e.content) {
                          if (e.content.action === w.CallMessageAction.CallTime)
                            return !0;
                          if (
                            e.content.action === w.CallMessageAction.MissCall
                          ) {
                            let s = e.content.params;
                            if ("string" == typeof s)
                              try {
                                s = JSON.parse(e.content.params);
                              } catch (t) {}
                            if (s && 3 === s.reason) return !0;
                          }
                        }
                        return !1;
                      }
                      clearUnreadConversation(e, t = {}) {
                        if (e && e.smsUnreadCount)
                          try {
                            let s = !0,
                              i = Object.keys(t);
                            (i && 0 != i.length) ||
                              ((s = !1),
                              this.logger.zsymb(
                                0,
                                10093,
                                30043,
                                `[read-message] actually, no need send seen in that case 2: ${i.length}`
                              )),
                              !s &&
                                I.default.chat_aggressive_send_seen &&
                                (s = !0),
                              s
                                ? i && 0 !== i.length
                                  ? this.sendClearUnreadToServer(t, e.userId)
                                  : $e.default
                                      .getLastMessageFrom(
                                        e.userId,
                                        e.lastSmsLocalId,
                                        ja,
                                        e.smsUnreadCount,
                                        !0
                                      )
                                      .then((t) => {
                                        let s = [],
                                          i = {};
                                        if (t && t.length)
                                          for (let e = 0; e < t.length; e++) {
                                            let a = t[e];
                                            b.default.validMessageFromOther(
                                              a
                                            ) &&
                                              a.zglobalMsgId &&
                                              -1 != a.zglobalMsgId &&
                                              (s.push(a.zglobalMsgId),
                                              (i[a.zglobalMsgId] = a));
                                          }
                                        0 === s.length
                                          ? this.logger.zsymb(
                                              3,
                                              10093,
                                              30044,
                                              "- [read-message] get ids.length == 0 {}",
                                              e.userId
                                            )
                                          : this.sendClearUnreadToServer(
                                              i,
                                              e.userId
                                            );
                                      })
                                      .catch((e) => {
                                        this.logger.zsymb(
                                          21,
                                          10093,
                                          30045,
                                          " [read-message] get msgs err {}",
                                          e
                                        );
                                      })
                                : this.logger.zsymb(
                                    3,
                                    10093,
                                    30046,
                                    "[read-message] no send {}",
                                    e.userId
                                  );
                          } catch (s) {
                            this.logger.zsymb(
                              21,
                              10093,
                              30047,
                              "[read-message] err {}",
                              s
                            );
                          }
                        else
                          this.logger.zsymb(
                            0,
                            10093,
                            30042,
                            `[read-message] actually, no need send seen in that case 1: ${
                              null == e ? void 0 : e.userId
                            }`
                          );
                      }
                      async sendClearUnreadToServer(e = {}, t) {
                        const s = Object.keys(e),
                          i = fa.a.isGroup(t),
                          a = ya.a.newReq();
                        try {
                          await is.default.sendSeen(e, t, i, a),
                            I.default.stagingAccount &&
                              this.logger.zsymb(
                                0,
                                10093,
                                30048,
                                `[read-message] done ${t} msgId:\n\t\t\t\t\t${
                                  s && s.length ? s[s.length - 1] : 0
                                }`
                              );
                        } catch (n) {
                          if (
                            (this.logger.zsymb(
                              21,
                              10093,
                              30049,
                              "[read-message] err {}",
                              n
                            ),
                            !(s && s.length > 0))
                          )
                            throw (
                              (this.logger.zsymb(
                                21,
                                10093,
                                30051,
                                "[read-message] send seen fail!!! convId:{} msgId len = 0",
                                t
                              ),
                              n)
                            );
                          if (
                            (this.logger.zsymb(
                              21,
                              10093,
                              30050,
                              "[read-message] send seen fail!! convId:{} msgId:{}",
                              t,
                              s[s.length - 1]
                            ),
                            n && (114 === n.error_code || -69 === n.error_code))
                          )
                            throw (
                              (this.logger.zsymb(
                                21,
                                10093,
                                30052,
                                "[read-message] send seen fail!!! no need retry {}",
                                n.error_code
                              ),
                              n)
                            );
                          throw (
                            (I.default.retrySendSeen
                              ? (this.logger.zsymb(
                                  21,
                                  10093,
                                  30053,
                                  "[read-message] send seen fail!!! retry"
                                ),
                                Sa.b.retryAction(
                                  Sa.a.SEND_SEEN_V2,
                                  [e, t, i, a],
                                  {
                                    startedTime: Date.now(),
                                    duration: I.default.retrySendSeen.timeout,
                                  }
                                ))
                              : this.logger.zsymb(
                                  21,
                                  10093,
                                  30054,
                                  "[read-message] send seen fail!!! not retry"
                                ),
                            n)
                          );
                        }
                      }
                      broadcastEvent(e, t, s) {
                        this.dispatchEvent(new Et.a(e, t, s));
                      }
                      updateInDB(e) {
                        null == e.lastSeenReactId &&
                          ((e.lastSeenReactId =
                            wa.a.getLastSeen(e.convId) || "0"),
                          this.logger.zsymb(
                            18,
                            10093,
                            30055,
                            `update invalid lastSeen ${e.convId}`
                          )),
                          this.DBConvUnread.addOrUpdate(e);
                      }
                      deleteInDB(e) {
                        this.DBConvUnread.remove(e);
                      }
                    })
                  ) || Oa)
              ) || Oa)
          ) || Oa)
      );
      var xa = s("8Nax"),
        Va = s("GSHL"),
        qa = s("w5bt");
      let Ha;
      var Ka, $a;
      ((Ka = Ha || (Ha = {})).modelToEntity = function (e) {
        if (!e)
          throw new Error("[PreviewHelper] Convert undefined model to entity");
        return {
          convId: e.convId,
          msgId: e.msgId,
          dName: e.dName,
          message: e.message,
          messageType: e.messageType,
          messageTime: e.messageTime,
          isGroup: e.isGroup,
          fromUid: e.fromUid,
          toUid: e.toUid,
          urgencyLevel: e.urgencyLevel,
          properties: e.properties ? { type: e.properties.type } : null,
          mentions: e.mentions ? e.mentions : null,
          ttl: e.ttl,
          cliMsgId: e.cliMsgId,
          actionId: e.actionId,
          status: e.status,
          substate: e.substate,
          computedMessage: e.computedMessage,
          computedIcon: e.computedIcon,
        };
      }),
        (Ka.entityToModel = function (e) {
          return e
            ? {
                convId: e.convId,
                msgId: e.msgId,
                dName: e.dName,
                message: e.message,
                messageType: e.messageType,
                messageTime: e.messageTime,
                isGroup: e.isGroup,
                fromUid: e.fromUid,
                toUid: e.toUid,
                urgencyLevel: e.urgencyLevel,
                properties: e.properties,
                mentions: e.mentions,
                ttl: e.ttl,
                cliMsgId: e.cliMsgId,
                actionId: e.actionId,
                status: e.status,
                substate: e.substate,
                computedMessage: e.computedMessage,
                computedIcon: e.computedIcon,
                src: "db.preview",
                verified: !1,
              }
            : null;
        });
      const Wa = "zpm_m",
        Za = "1.0.0";
      Object(B.b)(qa.b)(
        ($a =
          (function (e, t) {
            return a.ModuleContainer.inject(Va.b)(e, void 0, 0);
          })(
            ($a =
              Reflect.metadata(
                "design:type",
                Function
              )(
                ($a =
                  Reflect.metadata("design:paramtypes", [
                    void 0 === Et.IReactiveDB ? Object : Et.IReactiveDB,
                  ])(
                    ($a = class extends re.b {
                      constructor(e) {
                        super(),
                          (this.DBConvPreview = e),
                          Object(i.a)(this, "name", void 0),
                          Object(i.a)(this, "key", void 0),
                          Object(i.a)(this, "didInit", void 0),
                          Object(i.a)(this, "data", void 0),
                          Object(i.a)(this, "list", void 0),
                          Object(i.a)(this, "deleteQueue", void 0),
                          Object(i.a)(this, "doneLoadDB", void 0),
                          Object(i.a)(this, "migrating", void 0),
                          Object(i.a)(this, "_Logger", void 0),
                          (this.name = qa.a),
                          (this.key = "convId"),
                          (this.didInit = !1),
                          (this.data = new Map()),
                          (this.list = new Map()),
                          (this.deleteQueue = []),
                          (this.doneLoadDB = !1),
                          (this.migrating = !1);
                      }
                      init() {
                        return this.didInit
                          ? Promise.resolve()
                          : ((this.didInit = !0), this.loadData());
                      }
                      get Logger() {
                        return (
                          this._Logger ||
                            (this._Logger = a.ModuleContainer.resolve(
                              O.ZLoggerFactory
                            ).createZLogger("conversation", [this.name])),
                          this._Logger
                        );
                      }
                      signalRenderItem(e, t) {
                        Object(yt.g)(e, t),
                          this.broadcastEvent(Et.b.PreviewChanged, t, {
                            changedItem: this.data.get(t),
                            all: Array.from(this.data.values()),
                          });
                      }
                      loadData() {
                        return new Promise((e, t) => {
                          r.a.getInstance().getItemForCurrentUser(Wa) !== Za ||
                          this.migrating
                            ? e()
                            : (this.Logger.zsymb(
                                3,
                                11663,
                                3e4,
                                "start load preview"
                              ),
                              this.DBConvPreview.getAll()
                                .then((t) => {
                                  this.onLoadPreviewsFromDB(t)
                                    .then(e)
                                    .catch((t) => {
                                      this.Logger.zsymb(
                                        21,
                                        11663,
                                        30001,
                                        "load previews from db failure #1! {}",
                                        t
                                      ),
                                        e();
                                    });
                                })
                                .catch((t) => {
                                  this.Logger.zsymb(
                                    21,
                                    11663,
                                    30002,
                                    "load preview from db failure #2! {}",
                                    t
                                  ),
                                    e();
                                }));
                        });
                      }
                      async revalidate(e) {
                        const t = !!this.getPreviewByIDSync(e),
                          s = await la.b
                            .getPreviewMessage(e)
                            .catch(
                              (s) => (
                                this.Logger.zsymb(
                                  21,
                                  11663,
                                  30003,
                                  "revalidate failure #1 {} {} {}",
                                  e,
                                  t,
                                  s
                                ),
                                { previewMsg: void 0 }
                              )
                            );
                        return (
                          !!s.previewMsg &&
                          this.onReceiveNewMessage("db.message", s.previewMsg)
                            .then(
                              (s) => (
                                this.Logger.zsymb(
                                  3,
                                  11663,
                                  30004,
                                  "revalidate success {} {} {}",
                                  e,
                                  t,
                                  s
                                ),
                                !0
                              )
                            )
                            .catch(
                              (s) => (
                                this.Logger.zsymb(
                                  21,
                                  11663,
                                  30005,
                                  "revalidate failure #2 {} {} {}",
                                  e,
                                  t,
                                  s
                                ),
                                !1
                              )
                            )
                        );
                      }
                      migrate(e, t = !1) {
                        return new Promise((s) => {
                          const i = r.a.getInstance().getItemForCurrentUser(Wa);
                          if (i === Za && !t) return;
                          if (
                            (this.Logger.zsymb(
                              3,
                              11663,
                              30006,
                              "start migrate {} {}",
                              i,
                              t
                            ),
                            (this.migrating = !0),
                            0 === e.length)
                          )
                            return this.doneMigratePreivew(0), s(0);
                          let a = 0,
                            n = 0;
                          const o = () => {
                              if ((a++, a === e.length))
                                return this.doneMigratePreivew(n), s(n);
                            },
                            c = () => {
                              n++, o();
                            },
                            l = () => {
                              for (let t = 0; t < e.length; t++)
                                la.b
                                  .getPreviewMessage(e[t])
                                  .then((s) => {
                                    s && s.previewMsg
                                      ? this.onReceiveNewMessage(
                                          "db.message",
                                          s.previewMsg
                                        )
                                          .then(c)
                                          .catch(o)
                                      : (this.Logger.zsymb(
                                          3,
                                          11663,
                                          30007,
                                          "migrate not exists msg {}",
                                          e[t]
                                        ),
                                        o());
                                  })
                                  .catch((s) => {
                                    o(),
                                      this.Logger.zsymb(
                                        21,
                                        11663,
                                        30008,
                                        "migrate failure for conv {} {}",
                                        e[t],
                                        s
                                      );
                                  });
                            };
                          let d = e.filter(
                            (e) =>
                              e !== w.FAKE_CONVERSATION_ID.FRIEND_CENTER &&
                              e !== w.FAKE_CONVERSATION_ID.GROUP_CENTER &&
                              !e.startsWith(w.GROUPID_PREFIX)
                          );
                          if (d.length > 0)
                            return D.default
                              .getProfileFriendByIds(
                                d,
                                w.SRC_GET_PROFILE.FETCH_MINI_INFO
                              )
                              .then(() => {
                                l();
                              })
                              .catch(() => {
                                l();
                              });
                          l();
                        });
                      }
                      doneMigratePreivew(e) {
                        this.Logger.zsymb(
                          3,
                          11663,
                          30009,
                          "done migrate preview {}",
                          e
                        );
                        r.a.getInstance().setItemForCurrentUser(Wa, Za),
                          this.broadcastEvent(Et.b.DoneMigratePreview, "");
                      }
                      upgradeItemsVersion(e = []) {
                        this.Logger.zsymb(
                          3,
                          11663,
                          30010,
                          "upgradeItemsVersion"
                        );
                        const t = new Date().getTime().toString();
                        Object(yt.i)(t),
                          0 !== e.length
                            ? e.forEach((e) => {
                                Object(yt.f)(t, this.name, e);
                              })
                            : this.data.forEach((e) => {
                                Object(yt.f)(t, this.name, e.convId);
                              }),
                          Object(yt.c)(t);
                      }
                      updateStrangerBox(e) {
                        const t = this.data.get(e);
                        t &&
                          (this.data.set(
                            w.CONV_FILTER.STRANGER,
                            Object(p.a)({}, t)
                          ),
                          Object(yt.g)(this.name, w.CONV_FILTER.STRANGER));
                      }
                      forceChangeItem(e) {
                        this.signalRenderItem(this.name, e);
                      }
                      getItem(e, t) {
                        const s = this.data.get(e.key);
                        return (
                          s ||
                            this.Logger.zsymb(
                              5,
                              11663,
                              30011,
                              "try to get item not exist in cache {}",
                              e.key
                            ),
                          s
                        );
                      }
                      getList(e, t) {
                        return Array.from(this.data.keys());
                      }
                      onGetItemFailure(e) {
                        this.Logger.zsymb(
                          11,
                          11663,
                          30012,
                          "onGetItemFailure {}",
                          e
                        );
                      }
                      onGetListFailure(e, t) {
                        this.Logger.zsymb(
                          11,
                          11663,
                          30013,
                          "onGetListFailure {} {}",
                          e,
                          t
                        );
                      }
                      onLoadPreviewsFromDB(e) {
                        return new Promise((t, s) => {
                          if (
                            (this.Logger.zsymb(
                              3,
                              11663,
                              30014,
                              "onLoadPreviewsFromDB {}",
                              null == e ? void 0 : e.length
                            ),
                            !e || 0 === e.length)
                          )
                            return this.doneLoadPreview(0), t();
                          let i = 0;
                          const a = () => {
                            i++,
                              i === e.length && (this.doneLoadPreview(i), t());
                          };
                          for (let n = 0; n < e.length; n++) {
                            const t = Ha.entityToModel(e[n]);
                            t &&
                              !xa.a.instance.filterExpiredPreview(t) &&
                              ((t.messageType = w.MSG_VANISH),
                              (t.message = ""),
                              this.updateInDB(t)),
                              this.addPreviewToManager(t)
                                .then(() => {
                                  a();
                                })
                                .catch((e) => {
                                  a(),
                                    this.Logger.zsymb(
                                      21,
                                      11663,
                                      30015,
                                      "onload preview failure for item {} {}",
                                      null == t ? void 0 : t.convId,
                                      e
                                    );
                                });
                          }
                        });
                      }
                      doneLoadPreview(e) {
                        this.Logger.zsymb(
                          3,
                          11663,
                          30016,
                          "doneLoadPreview {}",
                          e
                        ),
                          (this.doneLoadDB = !0),
                          this.broadcastEvent(
                            Et.b.DoneLoadPreview,
                            "",
                            Array.from(this.data.values())
                          ),
                          Object(yt.h)(this.name, "all");
                      }
                      onReceiveNewMessage(e, t) {
                        return new Promise((s, i) => {
                          if (!t) return s(!1);
                          const a = this.convertDBMessageToPreviewItem(e, t);
                          this.addPreviewToManager(a)
                            .then((e) =>
                              e
                                ? (this.signalRenderItem(this.name, t.toUid),
                                  s(!0))
                                : s(!1)
                            )
                            .catch(i);
                        });
                      }
                      onReceiveNewMessages(e, t) {
                        return new Promise((s) => {
                          if (!t) return s(!1);
                          const i = this.groupMessageByConvId(t),
                            a = [];
                          for (const e in i) {
                            if (!Object.prototype.hasOwnProperty.call(i, e))
                              continue;
                            const t = i[e];
                            for (let e = t.length - 1; e >= 0; e--) {
                              if (Pt.b.isValidPreviewMessage(t[e])) {
                                a.push(t[e]);
                                break;
                              }
                              this.Logger.zsymb(
                                3,
                                11663,
                                30017,
                                "receive msg but not preview {}",
                                t[e].msgId
                              );
                            }
                          }
                          return a.length
                            ? Promise.all(
                                a.map(async (t) =>
                                  this.onReceiveNewMessage(e, t)
                                )
                              )
                                .then((e) => {
                                  const t = e.some((e) => 1 == e);
                                  s(t);
                                })
                                .catch((e) => {
                                  this.Logger.zsymb(
                                    21,
                                    11663,
                                    30018,
                                    "add messages to preview got error {}",
                                    e
                                  ),
                                    s(!1);
                                })
                            : s(!1);
                        });
                      }
                      onUndoMessage(e, t) {
                        if (!t) return;
                        this.Logger.zsymb(
                          3,
                          11663,
                          30019,
                          "onUndoMessage {}",
                          t.msgId
                        );
                        const s = this.convertDBMessageToPreviewItem(e, t);
                        (s.messageType = w.MSG_UNDO),
                          (s.message = ""),
                          this.addPreviewToManager(s).then((e) => {
                            e && this.signalRenderItem(this.name, t.toUid);
                          });
                      }
                      onUpdateE2EEMessage(e, t) {
                        this.Logger.zsymb(0, 1416, 10007, "smation" + JSON.stringify(e));
                        this.Logger.zsymb(0, 1416, 10007, "smation" + JSON.stringify(t));
                        if (!t) return;
                        const s = t.toUid,
                          i = this.data.get(s);
                        if (
                          (this.Logger.zsymb(
                            3,
                            11663,
                            30020,
                            "onUpdateE2EEMessage {} {} {}",
                            s,
                            null == i ? void 0 : i.msgId,
                            t.msgId
                          ),
                          i && (i.msgId !== t.msgId || !pa.b.isSameMsg(i, t)))
                        )
                          return;
                        const a = this.convertDBMessageToPreviewItem(e, t),
                          n =
                            b.default.normalizeMessageTypeFromSubState(
                              null == t ? void 0 : t.e2eeStatus
                            ) || t.msgType;
                        (a.message =
                          a.message || Pt.b.getPlainText({ msgType: n })),
                          (a.verified = !0),
                          (a.messageType = n),
                          this.data.set(t.toUid, a),
                          this.updateInDB(a),
                          this.signalRenderItem(this.name, t.toUid);
                      }
                      onDeleteMessage(e, t) {
                        return new Promise((e, s) => {
                          if (!t) return e(!1);
                          this.Logger.zsymb(
                            3,
                            11663,
                            30021,
                            "onDeleteMessage {}",
                            t.msgId
                          );
                          const i = this.convertDBMessageToPreviewItem(
                            "db.message",
                            t
                          );
                          this.deleteMessageInManager(i).then((s) => {
                            s
                              ? (this.Logger.zsymb(
                                  3,
                                  11663,
                                  30022,
                                  "onDeleteMessage success {}",
                                  t.msgId
                                ),
                                this.signalRenderItem(this.name, t.toUid),
                                e(!0))
                              : e(!1);
                          });
                        });
                      }
                      onDeleteMessages(e, t) {
                        if (!t || t.length < 1) return;
                        const s = this.groupMessageByConvId(t);
                        for (const i in s)
                          if (Object.prototype.hasOwnProperty.call(s, i)) {
                            const t = s[i];
                            let a = this.convertDBMessageToPreviewItem(e, t[0]),
                              n = 0;
                            for (let s = 1; s < t.length; s++) {
                              const i = this.convertDBMessageToPreviewItem(
                                e,
                                t[s]
                              );
                              this.isSecondItemNewer(a, i) &&
                                ((n = s), (a = i));
                            }
                            this.onDeleteMessage(e, t[n]);
                          }
                      }
                      onDeleteConversation(e) {
                        e &&
                          (this.Logger.zsymb(
                            3,
                            11663,
                            30023,
                            "onDeleteConversation {}",
                            e
                          ),
                          this.data.delete(e) && Object(yt.e)(this.name, e),
                          this.deleteInDB(e));
                      }
                      onChangeDraft(e, t) {
                        let s = this.getPreviewByIDSync(e);
                        !e ||
                        !s ||
                        s.draft === t ||
                        (s.draft && t && s.draft.draftTime === t.draftTime)
                          ? this.Logger.zsymb(
                              3,
                              11663,
                              30024,
                              "onChangeDraft - reject {}",
                              !!s
                            )
                          : (this.Logger.zsymb(
                              3,
                              11663,
                              30025,
                              "onChangeDraft - call update {}",
                              !!s
                            ),
                            (s = Object(p.a)(
                              Object(p.a)({}, s),
                              {},
                              { draft: t }
                            )),
                            this.data.set(e, s),
                            this.signalRenderItem(this.name, e),
                            this.broadcastEvent(Et.b.DraftChanged));
                      }
                      getPreviewById(e) {
                        return new Promise((t, s) => {
                          if (this.data.has(e)) return t(this.data.get(e));
                          this.DBConvPreview.getById(e)
                            .then((s) => {
                              s ||
                                this.Logger.zsymb(
                                  3,
                                  11663,
                                  30026,
                                  "get item not exist with id {}",
                                  e
                                );
                              const i = Ha.entityToModel(s);
                              t(i || void 0);
                            })
                            .catch(s);
                        });
                      }
                      getPreviewByIDSync(e) {
                        return this.data.get(e);
                      }
                      getAllPreviews() {
                        return new Promise((e, t) => {
                          if (this.doneLoadDB)
                            return e(this.getAllPreviewsSync());
                          this.DBConvPreview.getAll()
                            .then((t) => {
                              const s = t.map((e) => Ha.entityToModel(e));
                              e(s);
                            })
                            .catch(t);
                        });
                      }
                      getAllPreviewsSync() {
                        return Array.from(this.data.values()) || [];
                      }
                      setPreview(e, t, s, i, a, n = 1, r = {}) {
                        const o = this.data.get(e);
                        this.Logger.zsymb(
                          3,
                          11663,
                          30027,
                          "call set preview {} {}",
                          e,
                          !!o
                        );
                        const c = {
                          convId: e,
                          msgId: r.msgId || "unset",
                          src: "ui",
                          dName: r.dName || "",
                          message: t,
                          messageType: "",
                          isGroup: e.startsWith(w.GROUPID_PREFIX),
                          messageTime: s,
                          fromUid: i,
                          toUid: a,
                          urgencyLevel: r.urgencyLevel,
                          properties: null,
                          verified: !0,
                          status: n,
                          computedMessage: t,
                          computedIcon: r.icon,
                        };
                        this.data.set(e, c),
                          this.signalRenderItem(this.name, e),
                          this.updateInDB(c);
                      }
                      async addPreviewToManager(e) {
                        if (!e) return !1;
                        const t = e.convId,
                          s = this.data.get(t);
                        let i = !1;
                        return (
                          s
                            ? this.isSecondItemNewer(s, e) &&
                              (this.data.set(t, e),
                              (i = !0),
                              s.verified
                                ? ((e.verified = !0), this.updateInDB(e))
                                : (i = await this.compareCacheWithDBAndUpdate(
                                    t,
                                    e
                                  )))
                            : (this.data.set(t, e),
                              (i = !0),
                              "db.preview" !== e.src &&
                                (i = await this.compareCacheWithDBAndUpdate(
                                  t,
                                  e
                                ))),
                          i
                        );
                      }
                      async deleteMessageInManager(e) {
                        if (!e) return !1;
                        const t = e.convId,
                          s = this.data.get(t);
                        if (
                          !s ||
                          (!pa.b.isSameMsg(e, s) &&
                            this.isSecondItemNewer(e, s))
                        )
                          return (
                            0 !== this.deleteQueue.length &&
                              this.deleteQueue.push(e),
                            !1
                          );
                        const i = async () => {
                          const e = await la.b.getPreviewMessage(t),
                            i = this.deleteQueue.find((t) => {
                              var s;
                              return (
                                t.msgId ===
                                (null === (s = e.previewMsg) || void 0 === s
                                  ? void 0
                                  : s.msgId)
                              );
                            });
                          if (i)
                            return (
                              this.data.set(t, i),
                              await this.deleteMessageInManager(i)
                            );
                          this.deleteQueue = [];
                          const a = this.data.get(t);
                          if (a && this.isSecondItemNewer(s, a)) return !1;
                          if (e.previewMsg) {
                            const s = this.convertDBMessageToPreviewItem(
                              "db.message",
                              e.previewMsg
                            );
                            return (
                              (s.verified = !0),
                              this.data.set(t, s),
                              this.updateInDB(s),
                              !0
                            );
                          }
                          return (
                            this.data.delete(t),
                            this.deleteInDB(t),
                            Object(yt.e)(this.name, t),
                            !1
                          );
                        };
                        if (s.verified) return await i();
                        {
                          const s = await this.DBConvPreview.getById(t),
                            a = s && Ha.entityToModel(s);
                          return a && this.isSecondItemNewer(e, a)
                            ? (this.data.set(t, a), !0)
                            : await i();
                        }
                      }
                      convertDBMessageToPreviewItem(e, t) {
                        let s = t.sendDttm || t.serverTime;
                        s = s ? s.toString() : "";
                        const i = t.fromUid || t.uidFrom,
                          a = t.toUid || t.idTo,
                          n = a && a.startsWith(w.GROUPID_PREFIX);
                        return {
                          convId: t.toUid,
                          msgId: t.msgId,
                          src: e,
                          dName: t.dName || "",
                          message: t.message,
                          messageType: t.msgType,
                          mentions: t.mentions,
                          isGroup: n,
                          messageTime: s,
                          fromUid: i,
                          properties: t.properties,
                          urgencyLevel: t.urgency,
                          verified: !1,
                          ttl: t.ttl,
                          status: t.status || 1,
                          substate: t.e2eeStatus,
                          cliMsgId: t.cliMsgId,
                          toUid: t.toUid,
                        };
                      }
                      isSecondItemNewer(e, t) {
                        return (
                          !e ||
                          ((t.msgId === e.msgId &&
                            t.messageTime === e.messageTime) ||
                          pa.b.isSameMsg(e, t)
                            ? (t.messageType === w.MSG_UNDO &&
                                e.messageType !== w.MSG_UNDO) ||
                              Ot.a.comparePreviewStt(t.status, e.status) > 0
                            : e.messageTime !== t.messageTime
                            ? t.messageTime > e.messageTime
                            : t.msgId > e.msgId)
                        );
                      }
                      compareCacheWithDBAndUpdate(e, t) {
                        return new Promise((s, i) => {
                          this.DBConvPreview.getById(e)
                            .then((i) => {
                              this.Logger.zsymb(
                                3,
                                11663,
                                30028,
                                "compareCacheWithDBAndUpdate {} {}",
                                e,
                                !!i
                              );
                              const a = Ha.entityToModel(i),
                                n = this.data.get(e);
                              if (JSON.stringify(n) !== JSON.stringify(t))
                                return s(!1);
                              (!a && n) ||
                              (a && n && this.isSecondItemNewer(a, n))
                                ? ((n.verified = !0), this.updateInDB(n))
                                : a && this.data.set(e, a),
                                s(!0);
                            })
                            .catch(i);
                        });
                      }
                      groupMessageByConvId(e) {
                        const t = {};
                        for (let s = 0; s < e.length; s++)
                          t[e[s].toUid]
                            ? t[e[s].toUid].push(e[s])
                            : (t[e[s].toUid] = [e[s]]);
                        return t;
                      }
                      broadcastEvent(e, t = "", s) {
                        this.dispatchEvent(new Et.a(e, t, s));
                      }
                      updateInDB(e) {
                        this.Logger.zsymb(
                          3,
                          11663,
                          30029,
                          "update in db {}",
                          e.msgId
                        );
                        try {
                          const t = Ha.modelToEntity(e);
                          this.DBConvPreview.addOrUpdate(t);
                        } catch (t) {
                          this.Logger.zsymb(
                            21,
                            11663,
                            30030,
                            "update in db got err{}",
                            t
                          );
                        }
                      }
                      deleteInDB(e) {
                        this.DBConvPreview.remove(e).catch((e) => {
                          this.Logger.zsymb(
                            18,
                            11663,
                            30031,
                            `[${this.name}] - deleteInDB got error ${e}`
                          );
                        });
                      }
                    })
                  ) || $a)
              ) || $a)
          ) || $a)
      );
      var Qa = s("rKwX"),
        Ya = s("SWKE");
      class Ja {
        constructor() {
          Object(i.a)(this, "cache", void 0), (this.cache = {});
        }
        localKey(e) {
          return "z_ml_" + e;
        }
        muteConversation(e, t) {
          const s = r.a.getInstance(),
            i = "z_ml_" + e;
          t
            ? t.constructor === Object
              ? s.setItemForCurrentUser(this.localKey(e), JSON.stringify(t))
              : s.setItemForCurrentUser(this.localKey(e), `${t}`)
            : s.removeItemForCurrentUser(i),
            (this.cache[e] = t || !1);
        }
        isMuted(e) {
          if (this.cache.hasOwnProperty(e)) return this.cache[e];
          let t,
            s = r.a.getInstance().getItemForCurrentUser(this.localKey(e));
          if (!s) return null;
          try {
            return (t = JSON.parse(s)), (this.cache[e] = t), t;
          } catch (i) {
            b.default.logCoreError(i);
          }
          return (this.cache[e] = !1), !1;
        }
        setMutedConversations(e) {
          let t = [];
          e.chatEntries &&
            e.chatEntries.length > 0 &&
            e.chatEntries.reduce((e, t) => (e.push(t), e), t),
            e.groupChatEntries &&
              e.groupChatEntries.length > 0 &&
              e.groupChatEntries.reduce(
                (e, t) => ((t.id = w.GROUPID_PREFIX + t.id), e.push(t), e),
                t
              );
          Ya.a.getInstance().cleanupLocalStorageMatchConditions((e) => {
            const t = r.a
              .getInstance()
              .getKeyNameForCurrentUser(this.localKey(""));
            return e.startsWith(t);
          }),
            (this.cache = {});
          for (let s = 0; s < t.length; s++)
            this.muteConversation(t[s].id, t[s]);
          return t;
        }
      }
      var Xa;
      Object(B.b)(me.f)(
        (Xa =
          Reflect.metadata(
            "design:type",
            Function
          )(
            (Xa =
              Reflect.metadata(
                "design:paramtypes",
                []
              )(
                (Xa = class extends re.b {
                  constructor() {
                    super(),
                      Object(i.a)(this, "name", void 0),
                      Object(i.a)(this, "key", void 0),
                      Object(i.a)(this, "didInit", void 0),
                      Object(i.a)(this, "_muteManager", void 0),
                      Object(i.a)(this, "userId", void 0),
                      Object(i.a)(this, "mapTimeout", void 0),
                      (this.name = me.e),
                      (this.key = "id"),
                      (this.didInit = !1),
                      (this.userId = ""),
                      (this.mapTimeout = {});
                  }
                  init(e) {
                    this.didInit || ((this.didInit = !0), (this.userId = e));
                  }
                  get muteManager() {
                    return (
                      (this._muteManager && "" !== this.userId) ||
                        (this.userId, (this._muteManager = new Ja())),
                      this._muteManager
                    );
                  }
                  getItem(e, t) {
                    return this.muteManager.isMuted(e.key);
                  }
                  getList(e, t) {
                    throw new Error("Method not implemented.");
                  }
                  onGetItemFailure(e) {}
                  onGetListFailure(e, t) {}
                  onMute(e, t) {
                    return new Promise((s, i) => {
                      this._clearTimeout(e);
                      let a = -1;
                      switch (t) {
                        case 1:
                          a = 3600;
                          break;
                        case 2:
                          a = 14400;
                          break;
                        case 3:
                          a = Math.round(this._getNowTo8Am() / 1e3);
                      }
                      b.default.logCoreInfo(
                        `[${this.name}] - onMute ${e} ${a}`
                      ),
                        Qa.a
                          .lock(e, a, !0)
                          .then((t) => {
                            this.muteManager.muteConversation(e, {
                              id: e,
                              startTime: t.startTime,
                              duration: t.duration,
                              systemTime: t.systemTime,
                              currentTime: t.currentTime,
                              muteMode: t.muteMode,
                            }),
                              s(!0);
                          })
                          .catch(i);
                    });
                  }
                  onUnMute(e, t = !0, s = !1) {
                    return new Promise((i, a) => {
                      this._clearTimeout(e),
                        b.default.logCoreInfo(
                          `[${this.name}] - onUnMute ${e} ${t} ${s}`
                        ),
                        Qa.a
                          .unlock(e, t, s)
                          .then((t) => {
                            this.muteManager.muteConversation(e, 0), i(!!t);
                          })
                          .catch(a);
                    });
                  }
                  onFetchMute(e) {
                    b.default.logCoreInfo(`[${this.name}] - onFetchMute`);
                    let t = this.muteManager.setMutedConversations(e);
                    return this.processFetchData(e), t;
                  }
                  onCtrMute(e, t) {
                    t
                      ? (this.doLock(t, !1),
                        this.muteManager.muteConversation(e, t),
                        this.muteChanged(e, !!t))
                      : this.onUnMute(e, !1).then((s) => {
                          this.muteChanged(e, !!t);
                        });
                  }
                  isMuted(e) {
                    return this.muteManager.isMuted(e);
                  }
                  processFetchData(e) {
                    try {
                      e.chatEntries &&
                        (e.chatEntries.forEach((e) => {
                          this.doLock(e, !0);
                        }),
                        e.groupChatEntries.forEach((e) => {
                          this.doLock(e, !0);
                        }));
                    } catch (t) {
                      b.default.logCoreError(t);
                    }
                  }
                  doLock(e, t = !0) {
                    if (
                      (this.mapTimeout.hasOwnProperty(e.id) && (t = !0),
                      this._clearTimeout(e.id),
                      -1 != e.duration)
                    ) {
                      b.default.log("setTimer", e);
                      let s = e.duration - (e.currentTime - e.systemTime);
                      s >= 0
                        ? (b.default.log("setTimer: lock1", e.id),
                          b.default.logCoreInfo(
                            "[Unmute timeout] setTimer: lock1",
                            e.id,
                            s
                          ),
                          (this.mapTimeout[e.id] = setTimeout(() => {
                            this.onUnMute(e.id, t, !0),
                              b.default.logCoreInfo(
                                "[Unmute timeout] setTimer: unlock1",
                                e.id
                              );
                          }, 1e3 * s)))
                        : (b.default.log("setTimer: unlock", s),
                          b.default.logCoreInfo(
                            "[Unmute timeout] setTimer: unlock",
                            e.id
                          ),
                          this.onUnMute(e.id, t));
                    }
                  }
                  _clearTimeout(e) {
                    this.mapTimeout.hasOwnProperty(e) &&
                      (clearTimeout(this.mapTimeout[e]),
                      delete this.mapTimeout[e]);
                  }
                  _getNowTo8Am() {
                    let e = new Date().getTime(),
                      t = new Date(e);
                    return (
                      t.setHours(8, 0, 0, 0),
                      t.getTime() <= e
                        ? t.getTime() + 864e5 - e
                        : t.getTime() - e
                    );
                  }
                  muteChanged(e, t) {
                    Object(yt.g)(this.name, e),
                      this.broadcastEvent(Et.b.MuteChanged, e, t);
                  }
                  broadcastEvent(e, t = "", s) {
                    this.dispatchEvent(new Et.a(e, t, s));
                  }
                })
              ) || Xa)
          ) || Xa)
      );
      var en,
        tn = s("kCOK"),
        sn = s("qvRd"),
        an = s("fBUP"),
        nn = s("gwig");
      const rn = "zpinc",
        on = "ver_pin",
        cn = 0,
        ln = 1,
        dn = 2;
      Object(B.b)(sn.b)(
        (en =
          Reflect.metadata(
            "design:type",
            Function
          )(
            (en =
              Reflect.metadata(
                "design:paramtypes",
                []
              )(
                (en = class extends re.b {
                  get Logger() {
                    return (
                      this._Logger ||
                        (this._Logger = a.ModuleContainer.resolve(
                          O.ZLoggerFactory
                        ).createZLogger("conversation", [this.name])),
                      this._Logger
                    );
                  }
                  constructor() {
                    super(),
                      Object(i.a)(this, "name", void 0),
                      Object(i.a)(this, "key", void 0),
                      Object(i.a)(this, "didInit", void 0),
                      Object(i.a)(this, "doneLoadDB", void 0),
                      Object(i.a)(this, "data", void 0),
                      Object(i.a)(this, "_Logger", void 0),
                      Object(i.a)(this, "reFetchCount", void 0),
                      Object(i.a)(this, "retryTimeout", void 0),
                      Object(i.a)(this, "refetchInterval", void 0),
                      Object(i.a)(this, "lastFetchTime", void 0),
                      Object(i.a)(this, "isDataLastest", void 0),
                      Object(i.a)(this, "requestingIds", void 0),
                      (this.name = sn.a),
                      (this.key = "convId"),
                      (this.didInit = !1),
                      (this.doneLoadDB = !1),
                      (this.data = new Map()),
                      (this.reFetchCount = 0),
                      (this.isDataLastest = !1),
                      (this.lastFetchTime = 0),
                      (this.requestingIds = new Map());
                  }
                  init() {
                    this.didInit ||
                      ((this.didInit = !0),
                      this._loadData(),
                      this._fetchPinnedConversations(),
                      this._addListener());
                  }
                  _loadData() {
                    const e = r.a.getInstance().getItemForCurrentUser(rn);
                    if (e && e.length)
                      try {
                        const s = JSON.parse(e);
                        Object.keys(s).map((e) => {
                          this._verifyPin(s[e].id) &&
                            this.data.set(s[e].id, {
                              id: s[e].id,
                              priority: +s[e].priority || Y.a.getTimeNow(),
                            });
                        });
                        try {
                          this.Logger.zsymb(
                            0,
                            10089,
                            3e4,
                            "pin conversations loaded from local",
                            JSON.stringify(Object.fromEntries(this.data))
                          );
                        } catch (t) {
                          this.Logger.zsymb(18, 10089, 30001, "stringify fail");
                        }
                        this.doneLoadDB = !0;
                        const i = this.getAllPinnedConversations();
                        i.length && this._broadcastEvent(Et.b.ChangePinConv, i);
                      } catch (s) {
                        0;
                      }
                  }
                  _addListener() {
                    D.default.subscribeEventFriend(
                      w.EventFriend.REMOVE_FRIEND,
                      (e) => {
                        this.Logger.zsymb(
                          0,
                          10089,
                          30002,
                          "remove friend - unpin",
                          e.userId
                        ),
                          this.updateListPin([e.userId], dn);
                      }
                    ),
                      this._setFetchInterval();
                  }
                  _setFetchInterval() {
                    this.refetchInterval && clearTimeout(this.refetchInterval),
                      (this.refetchInterval = setInterval(() => {
                        this._fetchPinnedConversations();
                      }, 864e5));
                  }
                  _broadcastEvent(e, t) {
                    this.dispatchEvent(new Et.e(e, t));
                  }
                  _newPinItem(e, t) {
                    return { id: e, priority: t };
                  }
                  _syncServer(e, t) {
                    return this._updatePinnedConversationsV2(e, t);
                  }
                  getLastFetchTime() {
                    return this.lastFetchTime;
                  }
                  isPinned(e) {
                    return this.data.has(e);
                  }
                  getPinTime(e) {
                    const t = this.data.get(e);
                    return t ? t.priority : 0;
                  }
                  async _checkAndSyncDataBeforeAction() {
                    if (!this.isDataLastest)
                      try {
                        return await this._fetchPinnedConversations(), !0;
                      } catch (e) {
                        return !1;
                      }
                    return !0;
                  }
                  pin(e) {
                    return (
                      this.Logger.zsymb(0, 10089, 30003, "client pin", e),
                      new Promise(async (t, s) => {
                        const i = await this._checkAndSyncDataBeforeAction();
                        if (!e || !e.length) return s(null);
                        if (i) {
                          if (
                            this.data.size + e.length >
                            I.default.limit_pin_messages
                          )
                            return s(null);
                          let i = [];
                          for (let t = 0; t < e.length; ++t)
                            this.isPinned(e[t]) || i.push(e[t]);
                          if (i.length > 0)
                            try {
                              const s = await this._syncServer(i, ln);
                              return this.updateListPin(e, ln), t(s);
                            } catch (a) {
                              return s(a);
                            }
                        }
                        return s(null);
                      })
                    );
                  }
                  pinLocal(e) {
                    this.updateListPin(e, ln);
                  }
                  unpin(e, t = !1) {
                    return (
                      this.Logger.zsymb(
                        0,
                        10089,
                        30004,
                        "client unpin",
                        e,
                        "force sync",
                        t
                      ),
                      new Promise(async (s, i) => {
                        if (!e || !e.length) return i(null);
                        if (await this._checkAndSyncDataBeforeAction()) {
                          let n = [];
                          for (let s = 0; s < e.length; ++s)
                            (this.isPinned(e[s]) || t) && n.push(e[s]);
                          if (n.length > 0)
                            try {
                              await this._syncServer(n, dn),
                                this.updateListPin(e, dn),
                                s(1);
                            } catch (a) {
                              i(a);
                            }
                        }
                        return i(null);
                      })
                    );
                  }
                  unpinLocal(e) {
                    this.Logger.zsymb(0, 10089, 30005, "unpin local", e),
                      this.updateListPin(e, dn);
                  }
                  getAllPinnedConversations() {
                    return Array.from(this.data.values());
                  }
                  getAllPinnedConversationsSync() {
                    return Array.from(this.data.values());
                  }
                  getTotalPinnedConversation() {
                    return (
                      this.data.size +
                      Array.from(this.requestingIds.values()).filter(
                        (e) => e === ln
                      ).length
                    );
                  }
                  _verifyPin(e) {
                    return (
                      this.Logger.zsymb(
                        0,
                        10089,
                        30006,
                        "verify conversation",
                        e,
                        D.default.isFriend(e),
                        !!ne.default.getGroupByIdSync(e),
                        e === I.default.sendToMeId
                      ),
                      D.default.isFriend(e) ||
                        !!ne.default.getGroupByIdSync(e) ||
                        e === I.default.sendToMeId
                    );
                  }
                  updateListPin(e, t) {
                    if (
                      (this.Logger.zsymb(
                        0,
                        10089,
                        30007,
                        "updateListPin",
                        e,
                        t
                      ),
                      !e || !e.length)
                    )
                      return;
                    const s = [];
                    switch (t) {
                      case ln:
                        let t = Y.a.getTimeNow();
                        for (let i = 0; i < e.length; i++)
                          if (this._verifyPin(e[i]) && !this.data.has(e[i])) {
                            ++t,
                              this.requestingIds.get(e[i]) &&
                                this.requestingIds.set(e[i], cn);
                            const a = this._newPinItem(e[i], t);
                            this.data.set(e[i], a),
                              s.push(a),
                              Object(yt.g)(this.name, e[i]);
                          }
                        break;
                      case dn:
                        for (let i = 0; i < e.length; i++)
                          if (this.data.has(e[i])) {
                            this.requestingIds.get(e[i]) &&
                              this.requestingIds.set(e[i], cn),
                              this.data.delete(e[i]);
                            const t = this._newPinItem(e[i], 0);
                            s.push(t), Object(yt.g)(this.name, e[i]);
                          }
                        break;
                      default:
                        return;
                    }
                    s.length && this._broadcastEvent(Et.b.ChangePinConv, s),
                      this._updateInDB();
                  }
                  _retryFetch(e) {
                    if (this.reFetchCount > 5) return;
                    let t = 0;
                    switch (e) {
                      case "ERR_NO_NETWORK":
                      case -69:
                        break;
                      case 212:
                        this.Logger.zsymb(
                          20,
                          10089,
                          30008,
                          "hasn't pinned conversation from server"
                        );
                        r.a.getInstance().setItemForCurrentUser(on, "0"),
                          this._sendToServer();
                        break;
                      case "ERR_CONNECTION_TIMED_OUT":
                      case 112:
                        t = 5e3 * this.reFetchCount;
                        break;
                      default:
                        t = 36e5;
                    }
                    this.Logger.zsymb(
                      21,
                      10089,
                      30009,
                      "Handle request error fail with error: {}, retry after time= {}",
                      e,
                      t
                    ),
                      this.retryTimeout ||
                        (t > 0 &&
                          (this.retryTimeout = setTimeout(() => {
                            this._fetchPinnedConversations(),
                              (this.retryTimeout = void 0);
                          }, t)));
                  }
                  _parseData(e) {
                    let t = [];
                    for (let s = 0; s < e.length; ++s)
                      "m1" === e[s] ||
                        (e[s].startsWith("g")
                          ? t.push(e[s])
                          : t.push(e[s].slice(1)));
                    return t;
                  }
                  _fetchPinnedConversations() {
                    return (
                      this.reFetchCount++,
                      this.Logger.zsymb(
                        0,
                        10089,
                        30010,
                        "_fetchPinnedConversations",
                        this.reFetchCount
                      ),
                      new Promise((e, t) => {
                        an.default
                          .getPinnedConversations()
                          .then(tn.a)
                          .then((t) => {
                            if (t && t.conversations) {
                              const e = r.a.getInstance();
                              (void 0 === t.version && null === t.version) ||
                                e.setItemForCurrentUser(on, t.version),
                                this._onFetchPin(
                                  this._parseData(t.conversations)
                                );
                            }
                            e(t);
                          })
                          .catch((e) => {
                            (this.isDataLastest = !1),
                              e &&
                                (e.error_code
                                  ? this._retryFetch(e.error_code)
                                  : e.code
                                  ? this._retryFetch(e.code)
                                  : this._retryFetch("UNKNOWN_ERROR")),
                              t(e);
                          });
                      })
                    );
                  }
                  _updatePinnedConversationsV2(e, t) {
                    return new Promise((s, i) => {
                      if (!I.default.enable_sync_pinned) return;
                      if (!nn.b.getStateNetwork())
                        return void i(
                          t === ln
                            ? jt.default.str("STR_ERR_NETWORK_PIN_CONVERSATION")
                            : jt.default.str(
                                "STR_ERR_NETWORK_UNPIN_CONVERSATION"
                              )
                        );
                      let a = [];
                      for (let n = 0; n < e.length; ++n)
                        e[n].startsWith("g") ||
                          e[n].startsWith("u") ||
                          (e[n] = "u" + e[n]),
                          a.includes(e[n]) ||
                            (this.requestingIds.has(e[n]) &&
                              this.requestingIds.get(e[n]) !== cn) ||
                            (a.push(e[n]), this.requestingIds.set(e[n], t));
                      a.length &&
                        an.default
                          .updatePinnedConversationsV2(a, t)
                          .then(tn.a)
                          .then(() => {
                            a.forEach((e) => {
                              this.requestingIds.set(e, cn);
                            }),
                              s(!0);
                          })
                          .catch((e) => {
                            a.forEach((e) => {
                              this.requestingIds.set(e, cn);
                            }),
                              this.Logger.zsymb(
                                20,
                                10089,
                                30011,
                                "Update sync pin conv v2 FAIL: " + e
                              );
                            let s = "";
                            if (e)
                              if (e.error_code)
                                if (160 === e.error_code)
                                  this._fetchPinnedConversations();
                                else
                                  s =
                                    jt.default.str("STR_ERR_PIN_CONVERSATION") +
                                    " (" +
                                    e.error_code +
                                    ")";
                              else
                                "ERR_NO_NETWORK" === e.code &&
                                  nn.b.getStateNetwork() == nn.a.DISCONNECT &&
                                  (s =
                                    t === ln
                                      ? jt.default.str(
                                          "STR_ERR_NETWORK_PIN_CONVERSATION"
                                        )
                                      : jt.default.str(
                                          "STR_ERR_NETWORK_UNPIN_CONVERSATION"
                                        ));
                            i(s);
                          });
                    });
                  }
                  _isRemoteDataChanged(e) {
                    const t = Array.from(this.data.values())
                      .sort((e, t) => t.priority - e.priority)
                      .map((e) => e.id);
                    if (e.length !== t.length) return !0;
                    let s = !1;
                    return (
                      e.forEach((e, i) => {
                        e !== t[i] && (s = !0);
                      }),
                      s
                    );
                  }
                  _onFetchPin(e) {
                    this.Logger.zsymb(0, 10089, 30012, "onFetchPin", e),
                      (this.isDataLastest = !0),
                      (this.lastFetchTime = Y.a.getTimeNow()),
                      (this.reFetchCount = 0);
                    let t = Y.a.getTimeNow();
                    this._setFetchInterval();
                    const s = [],
                      i = [];
                    for (let a = 0; a < e.length; a++)
                      this._verifyPin(e[a])
                        ? i.push(e[a])
                        : this.unpin([e[a]], !0);
                    if (this._isRemoteDataChanged(i)) {
                      for (const e of Array.from(this.data.values()))
                        i.find((t) => t === e.id) ||
                          (this.data.delete(e.id),
                          Object(yt.g)(this.name, e.id),
                          s.push({ id: e.id, priority: 0 }));
                      for (let e = 0; e < i.length; e++) {
                        const a = this._newPinItem(i[e], t),
                          n = this.isPinned(i[e]);
                        this.data.set(i[e], a),
                          n || Object(yt.g)(this.name, i[e]),
                          t--,
                          s.push(a);
                      }
                      this.Logger.zsymb(
                        0,
                        10089,
                        30013,
                        "[After Fetch]",
                        Array.from(this.data.values())
                      ),
                        s.length && this._broadcastEvent(Et.b.ChangePinConv, s),
                        this._updateInDB();
                    }
                  }
                  _sendToServer() {
                    this._syncServer(Array.from(this.data.keys()), ln);
                  }
                  getItem(e, t) {
                    return this.data.get(e.key);
                  }
                  getList(e, t) {
                    return Array.from(this.data.keys());
                  }
                  onGetItemFailure(e, t) {
                    this.Logger.zsymb(
                      18,
                      10089,
                      30014,
                      "onGetItemFailure - key:",
                      e,
                      " - error",
                      t
                    );
                  }
                  onGetListFailure(e, t) {
                    this.Logger.zsymb(
                      18,
                      10089,
                      30015,
                      "onGetItemFailure - key:",
                      e,
                      " - error",
                      t
                    );
                  }
                  _updateInDB() {
                    if (!this.data) return;
                    const e = r.a.getInstance();
                    this.data.size
                      ? e.setItemForCurrentUser(
                          rn,
                          JSON.stringify(Array.from(this.data.values()))
                        )
                      : e.removeItemForCurrentUser(rn);
                  }
                })
              ) || en)
          ) || en)
      );
      var hn,
        un = s("MnJw");
      Object(B.b)(un.a)(
        (hn =
          Reflect.metadata(
            "design:type",
            Function
          )(
            (hn =
              Reflect.metadata(
                "design:paramtypes",
                []
              )(
                (hn = class extends re.b {
                  constructor() {
                    super();
                  }
                  onUpdateListArchivedChat(e) {
                    this.dispatchEvent(
                      new Et.a(Et.b.UpdateListArchivedChat, e)
                    );
                  }
                  onOffArchivedChat(e) {
                    this.dispatchEvent(
                      new Et.a(Et.b.OnOffArchivedChat, "", { status: e })
                    );
                  }
                })
              ) || hn)
          ) || hn)
      );
      a.ModuleContainer.registerSingleton(Ki.b, Qi),
        a.ModuleContainer.registerSingleton(ra.a, aa),
        a.ModuleContainer.registerSingleton(Ki.a, Wi);
      var gn,
        pn = s("Xvw2"),
        mn = s("5uwv"),
        vn = s("lCn6"),
        fn = s("kg13"),
        bn = s("dJFb");
      const _n = 2,
        Sn = { userId: "", friendRequestType: _n, friendRequestSource: 85 };
      var yn;
      !(function (e) {
        (e.SUGGEST = "suggest"),
          (e.REQUEST = "request"),
          (e.UNREADREQ = "unread-req");
      })(yn || (yn = {}));
      Object(B.b)(pn.b)(
        (gn =
          Reflect.metadata(
            "design:type",
            Function
          )(
            (gn =
              Reflect.metadata(
                "design:paramtypes",
                []
              )(
                (gn = class extends re.b {
                  constructor() {
                    super(),
                      Object(i.a)(this, "sugguestList", void 0),
                      Object(i.a)(this, "requestList", void 0),
                      Object(i.a)(this, "unreadFRList", void 0),
                      Object(i.a)(this, "_ebFriendRequestSend", (e) => {
                        const t = this.unreadFRList.filter((t) => t !== e);
                        t.length !== this.unreadFRList.length &&
                          ($e.default.removeFriend(e),
                          b.default.logCoreError(
                            "[reddot-check] SEND_FRIEND_REQUEST: " +
                              JSON.stringify(e)
                          ),
                          (this.unreadFRList = t),
                          Object(yt.h)(this.name, yn.UNREADREQ));
                      }),
                      Object(i.a)(this, "_ebFriendFetch", (e) => {
                        for (let t in e)
                          if (e.hasOwnProperty(t)) {
                            const e = this.requestList.slice();
                            for (let s = 0; s < e.length; s++)
                              if (e[s] === t) {
                                e.splice(s, 1);
                                break;
                              }
                            e.length !== this.requestList.length &&
                              ((this.requestList = e),
                              Object(yt.h)(this.name, yn.REQUEST));
                          }
                      }),
                      Object(i.a)(this, "_ebFrReqFetch", (e) => {
                        b.default.log(
                          "friendNotificationAction: friend requests fetched",
                          e
                        );
                        const t = this.requestList.reduce(
                            (e, t) => (e[t] || (e[t] = !0), e),
                            {}
                          ),
                          s = this.requestList.slice();
                        for (let i of e) t[i.userId] || s.unshift(i);
                        (this.requestList = s),
                          Object(yt.h)(this.name, yn.REQUEST);
                      }),
                      Object(i.a)(this, "_ebFrReqRemove", (e) => {
                        b.default.log(
                          "friendNotificationAction: friend requests removed",
                          e
                        );
                        const t = this.requestList.filter(
                          (t) => -1 === e.indexOf(t)
                        );
                        t.length !== this.requestList.length &&
                          ((this.requestList = t),
                          Object(yt.h)(this.name, yn.REQUEST)),
                          this.onFriendListNotificationsChange({
                            action: "remove",
                            ids: e,
                          });
                      }),
                      Object(i.a)(this, "name", pn.a),
                      Object(i.a)(this, "data", new Map()),
                      Object(i.a)(this, "key", "userId"),
                      (this.sugguestList = []),
                      (this.requestList = []),
                      (this.unreadFRList = []),
                      this.listenEvents();
                  }
                  listenEvents() {
                    _.default.subscribe((e, t) => {
                      switch (e) {
                        case y.ChatBoxActions.SEND_FRIEND_REQUEST:
                          this._ebFriendRequestSend(t);
                          break;
                        case y.FetchActions.FRIENDS_FETCHED:
                          this._ebFriendFetch(t);
                          break;
                        case y.FetchActions.FRIEND_REQUESTS_FETCHED:
                          this._ebFrReqFetch(t);
                          break;
                        case y.FetchActions.FRIEND_REQUESTS_REMOVED:
                          this._ebFrReqRemove(t);
                      }
                    });
                  }
                  onAddFriend(e) {
                    fn.a.removeSuggest(e.userId),
                      this.onFriendListNotificationsChange({
                        action: "remove",
                        ids: [e.userId],
                      });
                  }
                  onReceiveFriendRequests(e) {
                    if (!e || e.length < 1) return;
                    for (let s = 0; s < e.length; s++) {
                      let t = e[s];
                      t && fn.a.removeSuggest(t.userId);
                    }
                    bn.d.setUnreadRequest(1);
                    for (let s = 0; s < e.length; s++)
                      e[s] && ze.p.addNewFriendItem(e[s].userId);
                    N.a.UnreadDataManager.updateUnreadCount(
                      w.FAKE_CONVERSATION_ID.FRIEND_CENTER,
                      bn.d.getUnreadRequest()
                    );
                    let t = e.map((e) => ({
                      dataInfo: Object(p.a)(
                        Object(p.a)({}, e),
                        {},
                        {
                          recommInfo: {
                            message: e.friendRequestMsg,
                            source: e.friendRequestSource,
                          },
                          recommType: _n,
                        }
                      ),
                      recommItemType: e.friendRequestType,
                    }));
                    fn.a.addRequest(t),
                      this.broadcastEvent(mn.b.ReceiveRequest, "", {
                        uids: e.map((e) => e.userId),
                      });
                  }
                  onRemoveSuggest(e, t, s) {
                    return fn.a.removeSuggestFriend(e, t, s).then((t) => {
                      this.broadcastEvent(mn.b.RemoveSuggest, e);
                    });
                  }
                  onPromoteFriends() {
                    N.a.UnreadDataManager.updateUnreadCount(
                      w.FAKE_CONVERSATION_ID.FRIEND_CENTER,
                      1
                    );
                  }
                  onFriendRequestFetched() {}
                  onFriendListNotificationsChange(e) {
                    if (!e.ids || !e.ids.length)
                      return void (
                        "clear" === e.action &&
                        ((this.unreadFRList = []),
                        Object(yt.h)(this.name, yn.UNREADREQ))
                      );
                    let t = this.unreadFRList;
                    if ("remove" === e.action)
                      t = t.filter((t) => -1 === e.ids.indexOf(t));
                    else if ("add" === e.action) {
                      const s = [];
                      for (let i of e.ids) -1 === t.indexOf(i) && s.push(i);
                      s.length && (t = t.concat(s));
                    }
                    t.length !== this.unreadFRList.length &&
                      ((this.unreadFRList = t),
                      Object(yt.h)(this.name, yn.UNREADREQ));
                  }
                  acceptFriendRequest(e, t = Ze.c) {
                    return new Promise((s, i) => {
                      const a = this.data.get(e);
                      if (!a)
                        return bs.a
                          .acceptAddFriend(e)
                          .then((i) => {
                            He.ModalManagerV2.openModal({
                              windowId: t,
                              name: w.ModalIdentitiesDefine.BLOCK_STORIES,
                              params: { userId: e, windowId: t },
                            }),
                              s(!0);
                          })
                          .catch(i);
                      let n;
                      if (
                        a.friendRequestType === w.FRIEND_REQUEST_TYPE_SUGGEST
                      ) {
                        if (a.requested)
                          return (n = 104097), Z.e.logAction(n), s(!1);
                        const r = jt.default.trans(
                          "STR_MSG_DEFAULT_REQ_ADD_FR",
                          D.default.getMiniProfileMe().zaloName
                        );
                        bs.a
                          .requestAddFriend(e, r, a.friendRequestSource)
                          .then(() => {
                            He.ModalManagerV2.openModal({
                              windowId: t,
                              name: w.ModalIdentitiesDefine.BLOCK_STORIES,
                              params: { userId: e, windowId: t },
                            }),
                              $e.default.removeFriend(e),
                              fn.a.removeSuggest(e);
                            const i = Object(p.a)(
                              Object(p.a)({}, a),
                              {},
                              { requested: !0 }
                            );
                            this.broadcastEvent(mn.b.SentFriendReq, e),
                              this.data.set(e, i),
                              this.onFriendListNotificationsChange({
                                action: "remove",
                                ids: [e],
                              }),
                              s(!0);
                          })
                          .catch((e) => {
                            this.handleFailureFriendRq(e), i(e);
                          }),
                          (n = 104096);
                      } else
                        bs.a
                          .acceptAddFriend(e)
                          .then(() => {
                            this.data.delete(e),
                              Object(yt.e)(this.name, e),
                              this.onFriendListNotificationsChange({
                                action: "remove",
                                ids: [e],
                              }),
                              this.broadcastEvent(mn.b.AcceptRequest, e),
                              vn.a.getUser(e).then((t) => {
                                _.default.send(y.FetchActions.FRIENDS_FETCHED, {
                                  [e]: Object(p.a)(
                                    Object(p.a)(
                                      {},
                                      b.default.reformatConversationFromFriend(
                                        t
                                      )
                                    ),
                                    {},
                                    { isFr: 1 }
                                  ),
                                });
                              }),
                              $e.default.getAcceptNewFriend(a),
                              He.ModalManagerV2.openModal({
                                windowId: t,
                                name: w.ModalIdentitiesDefine.BLOCK_STORIES,
                                params: { userId: e, windowId: t },
                              }),
                              s(!0);
                          })
                          .catch((e) => {
                            this.handleFailureFriendRq(e), i(e);
                          }),
                          (n = 104095);
                      n && Z.e.logAction(n);
                    });
                  }
                  async rejectFriendRequest(e) {
                    const t = this.data.get(e),
                      s = () => {
                        Dt.a.createSuccess(
                          jt.default.str("STR_TOAST_REJECT_REQUEST")
                        ),
                          $e.default.removeFriend(e),
                          fn.a.removeSuggest(e),
                          this.broadcastEvent(mn.b.RejectRequest, e);
                      },
                      i = (e) => {
                        b.default.logCoreError(e),
                          e &&
                            e.error_message &&
                            Dt.a.createError(e.error_message);
                      };
                    t && t.friendRequestSource
                      ? is.default
                          .removeRecommendedFriend(e, t.friendRequestSource)
                          .then(s)
                          .catch(i)
                      : bs.a.rejectRequestAddFriend(e).then(s).catch(i),
                      this.data.delete(e),
                      this.onFriendListNotificationsChange({
                        action: "remove",
                        ids: [e],
                      }),
                      Z.e.logAction(104094);
                  }
                  undoRequestFriend(e) {
                    e &&
                      bs.a.undoRequestAddFriend(e).catch((e) => {
                        e.error_message && Dt.a.createError(e.error_message);
                      });
                  }
                  clearUnreadFriendRequest() {
                    N.a.UnreadDataManager.updateUnreadCount(
                      w.FAKE_CONVERSATION_ID.FRIEND_CENTER,
                      0
                    ),
                      (this.unreadFRList = []),
                      Object(yt.h)(this.name, yn.UNREADREQ);
                  }
                  getAllFriendRequests() {
                    return new Promise((e, t) => {
                      const s = fn.a.getRecommendedFriendsV2(!1, !1);
                      if (!s) return e({});
                      e(this.filterFriendRequest(s));
                    });
                  }
                  getAllFriendRequestsSync() {
                    const e = fn.a.getRecommendedFriendsSync();
                    return e ? this.filterFriendRequest(e) : {};
                  }
                  init() {
                    $e.default.getFriends(null, !0).then((e) => {
                      if (e) {
                        const t = $e.default.getLastContactListOpenTime(),
                          s = e
                            .filter((e) => e && e.friendRequestFetchTime > t)
                            .map((e) => e.userId);
                        s.length &&
                          this.onFriendListNotificationsChange({
                            action: "add",
                            ids: s,
                          });
                      }
                    });
                  }
                  getItem(e) {
                    return Sn;
                  }
                  getList(e) {
                    return e.key === yn.UNREADREQ ? this.unreadFRList : [];
                  }
                  onGetItemFailure(e) {}
                  onGetListFailure(e) {}
                  handleFailureFriendRq(e) {
                    if ((b.default.logCoreError(e), e && e.error_message)) {
                      let t = e.error_message;
                      [224, 251].includes(e.error_code) &&
                        (t = jt.default.trans(
                          `STR_FRIEND_REQUEST_FAIL_${e.error_code}`,
                          ["" + I.default.limitFriends]
                        )),
                        Dt.a.createMessage(t, 3e3);
                    }
                  }
                  filterFriendRequest(e) {
                    const t = {};
                    for (let s in e)
                      if (e.hasOwnProperty(s)) {
                        let i = e[s];
                        i &&
                          i.dataInfo.recommType === _n &&
                          ((t[s] = i),
                          (t[s].friendRequestType = i.dataInfo.recommType));
                      }
                    return t;
                  }
                  broadcastEvent(e, t, s) {
                    this.dispatchEvent(new mn.a(e, t, s)),
                      this.dispatchEvent(
                        new mn.a(
                          mn.b.FriendCenterChange,
                          t,
                          Object(p.a)(Object(p.a)({}, s), {}, { act: e })
                        )
                      );
                  }
                })
              ) || gn)
          ) || gn)
      );
      var Cn = s("hd49");
      let In;
      !(function (e) {
        e.MessageDelivered = "MessageDelivered";
      })(In || (In = {}));
      class On extends Event {
        constructor(e, t, s) {
          super(e),
            Object(i.a)(this, "msgId", void 0),
            Object(i.a)(this, "payload", void 0),
            (this.msgId = t),
            (this.payload = s);
        }
      }
      var En,
        Tn = s("Y/Cm");
      Object(j.h)()(
        (En =
          Object(j.g)()(
            (En =
              Object(a.singleton)(Cn.a)(
                (En =
                  Object(a.injectable)()(
                    (En =
                      (function (e, t) {
                        return Object(a.inject)(O.ZLoggerFactory)(e, void 0, 0);
                      })(
                        (En =
                          Reflect.metadata(
                            "design:type",
                            Function
                          )(
                            (En =
                              Reflect.metadata("design:paramtypes", [
                                void 0 === O.ZLoggerFactory
                                  ? Object
                                  : O.ZLoggerFactory,
                              ])(
                                (En = class extends re.b {
                                  constructor(e) {
                                    super(),
                                      Object(i.a)(this, "logger", void 0),
                                      (this.logger = e.createZLogger("feat", [
                                        "message-service",
                                      ]));
                                  }
                                  onStart() {}
                                  onDispose() {}
                                  onPollingMessages(e, t) {
                                    return new Promise((s, i) => {
                                      if (!e || 0 === e.length) return s(!1);
                                      const a = t
                                          ? { userId: t }
                                          : { userId: e[0].toUid },
                                        n = [...e],
                                        r = () => {
                                          this.messagesDelivered(n);
                                        };
                                      Tn.a.preparse(n, a, r, r);
                                    });
                                  }
                                  loadMessage(e) {
                                    return Promise.resolve({});
                                  }
                                  loadMessagesBefore(e, t, s) {}
                                  loadMessagesAfter(e, t, s) {}
                                  loadLastMessage(e, t) {}
                                  messagesDelivered(e) {
                                    this.broadcastEvent(
                                      In.MessageDelivered,
                                      "",
                                      e
                                    );
                                  }
                                  broadcastEvent(e, t = "", s) {
                                    b.default.log([
                                      e,
                                      "- id: ",
                                      t,
                                      " - payload: ",
                                      null == s ? void 0 : s.length,
                                    ]),
                                      this.dispatchEvent(new On(e, t, s));
                                  }
                                })
                              ) || En)
                          ) || En)
                      ) || En)
                  ) || En)
              ) || En)
          ) || En)
      );
      const Rn = Object(a.define)("cloud-segment-repository"),
        Ln = Object(a.define)("cloud-segment-manager"),
        Mn = Object(a.define)("cloud-message-manager");
      class Fn {
        constructor(e) {
          this.entity = e;
        }
        get conversationId() {
          return this.entity.conversationId;
        }
        get cloudFirstSmsLocalId() {
          return this.entity.cloudFirstSmsLocalId;
        }
        get cloudSegmentCheck() {
          return this.entity.cloudSegmentCheck;
        }
        get hasMore() {
          return this.entity.hasMore;
        }
        get lastCloudVerifiedDttm() {
          return this.entity.lastCloudVerifiedDttm;
        }
        get lastDeletedMsgID() {
          return this.entity.lastDeletedMsgID;
        }
        get lastGetMaxRecentTs() {
          return this.entity.lastGetMaxRecentTs;
        }
        get maxCloudMsgId() {
          return this.entity.maxCloudMsgId;
        }
      }
      var wn,
        Dn = s("t3h5");
      let jn =
        a.ModuleContainer.injectable()(
          (wn =
            Reflect.metadata(
              "design:type",
              Function
            )(
              (wn =
                Reflect.metadata(
                  "design:paramtypes",
                  []
                )(
                  (wn = class {
                    constructor() {}
                    get(e) {
                      return Dn.a.getSegmentByConvId(e);
                    }
                  })
                ) || wn)
            ) || wn)
        ) || wn;
      var An,
        Nn = s("npvr"),
        Pn = s("D8Ji");
      let kn,
        Un =
          a.ModuleContainer.injectable()(
            (An =
              (function (e, t) {
                return a.ModuleContainer.inject(Rn)(e, void 0, 0);
              })(
                (An =
                  Reflect.metadata(
                    "design:type",
                    Function
                  )(
                    (An =
                      Reflect.metadata("design:paramtypes", [
                        void 0 === Rn ? Object : Rn,
                      ])(
                        (An = class {
                          constructor(e) {
                            this.segmentRepository = e;
                          }
                          get(e) {
                            return this.segmentRepository
                              .get(e)
                              .then((e) => e && new Fn(e))
                              .catch((e) => {});
                          }
                          async createOrExtendSegment(e, t) {
                            const s = await this.segmentRepository.get(e);
                            (s.cloudSegmentCheck = Pn.a.mergeNewSegment(
                              t.verifiedRange,
                              null == s ? void 0 : s.cloudSegmentCheck
                            )),
                              (s.maxCloudMsgId = Math.max(
                                s.maxCloudMsgId || 0,
                                t.verifiedRange[1]
                              )),
                              Dn.a.setSegmentCacheByConvId(e, s),
                              await Nn.b.updateSegmentDB(e, s);
                          }
                        })
                      ) || An)
                  ) || An)
              ) || An)
          ) || An;
      !(function (e) {
        (e[(e.STOP_RETRY = -69)] = "STOP_RETRY"),
          (e[(e.RETRY_LATER = -71)] = "RETRY_LATER"),
          (e[(e.FORCE_UPDATE_CONFIG = -72)] = "FORCE_UPDATE_CONFIG"),
          (e[(e.UNKNOWN_EXCEPTION = 112)] = "UNKNOWN_EXCEPTION"),
          (e[(e.PARAMS_INVALID = 114)] = "PARAMS_INVALID"),
          (e[(e.CLIENT_NOT_SUPPORT = 211)] = "CLIENT_NOT_SUPPORT"),
          (e[(e.LIMIT_GROUPS_PER_REQUEST = 300)] = "LIMIT_GROUPS_PER_REQUEST"),
          (e[(e.LIMIT_MSG_PER_GROUP = 301)] = "LIMIT_MSG_PER_GROUP"),
          (e[(e.LIMIT_TOTAL_SYNC_MSG_PER_GROUP = 303)] =
            "LIMIT_TOTAL_SYNC_MSG_PER_GROUP"),
          (e[(e.MISSING_PARAM = 111)] = "MISSING_PARAM"),
          (e[(e.GROUP_NOT_EXIST = 161)] = "GROUP_NOT_EXIST"),
          (e[(e.NOT_BELONG_TO_GROUP = 164)] = "NOT_BELONG_TO_GROUP"),
          (e[(e.IS_DIRTY_GROUP = 302)] = "IS_DIRTY_GROUP");
      })(kn || (kn = {}));
      class Bn extends Error {
        constructor(e, t, s) {
          super(s), (this.code = e), (this.data = t);
        }
      }
      var Gn;
      let zn =
        a.ModuleContainer.injectable()(
          (Gn =
            (function (e, t) {
              return a.ModuleContainer.inject(li.a)(e, void 0, 0);
            })(
              (Gn =
                Reflect.metadata(
                  "design:type",
                  Function
                )(
                  (Gn =
                    Reflect.metadata("design:paramtypes", [
                      void 0 === li.a ? Object : li.a,
                    ])(
                      (Gn = class {
                        constructor(e) {
                          this.config = e;
                        }
                        get settings() {
                          return this.config.get("cloud.auto_download");
                        }
                        async crawlMissingMessage(
                          e,
                          t = { nRetry: 0, count: 50 }
                        ) {
                          let s = e.conversationId;
                          s.startsWith("g") && (s = s.slice(1));
                          const i = `${s}_${e.requestMsgId}`;
                          let a = this.settings.limit.minMsgDttm,
                            n = this.settings.limit.maxMsgFirstSegment;
                          const r = {
                            groupId: s,
                            fromMsgId: e.requestMsgId,
                            globalMsgIds: e.globalMsgIds,
                            curTotalMsgs: e.curTotalMsgs,
                            tsJoinGroup: e.tsJoinGroup,
                            minMsgTs: a,
                            maxTotalSyncMsg: n,
                          };
                          return await an.default
                            .crawlMissingMessage(i, r, {
                              requestTimeout: this.settings.fetching.timeout,
                              count: t.count,
                              nRetry: t.nRetry,
                              usePostApi: !0,
                            })
                            .then((e) => Object(tn.a)(e))
                            .then((e) => {
                              try {
                                return JSON.parse(e);
                              } catch (t) {
                                throw {
                                  error_code: -1,
                                  error_message: "invalid response",
                                };
                              }
                            })
                            .then((e) => {
                              const t = e[s];
                              if (t.error > 0)
                                throw {
                                  error_code: t.error,
                                  error_message: "inner error",
                                };
                              return t;
                            })
                            .catch((e) => {
                              if ("number" == typeof e.error_code) {
                                let s = e.data;
                                try {
                                  s = JSON.parse(s);
                                } catch (t) {}
                                throw new Bn(e.error_code, s, e.error_message);
                              }
                              throw e;
                            });
                        }
                      })
                    ) || Gn)
                ) || Gn)
            ) || Gn)
        ) || Gn;
      var xn,
        Vn = s("EO3V"),
        qn = s("enz2");
      const Hn = {
        totalMsgCount: 0,
        fetchedMsgCount: 0,
        serverMsgCount: 0,
        newMsgCount: 0,
        phaseDone: !1,
        isFilteredByTimeJoin: !1,
        done: !0,
        tsJoinGroup: "0",
      };
      let Kn =
        a.ModuleContainer.injectable()(
          (xn =
            (function (e, t) {
              return a.ModuleContainer.injectToken(zn)(e, void 0, 0);
            })(
              (xn =
                (function (e, t) {
                  return a.ModuleContainer.inject(Ln)(e, void 0, 1);
                })(
                  (xn =
                    (function (e, t) {
                      return a.ModuleContainer.inject($i.c)(e, void 0, 2);
                    })(
                      (xn =
                        (function (e, t) {
                          return a.ModuleContainer.inject($i.b)(e, void 0, 3);
                        })(
                          (xn =
                            (function (e, t) {
                              return a.ModuleContainer.inject(O.ZLoggerFactory)(
                                e,
                                void 0,
                                4
                              );
                            })(
                              (xn =
                                Reflect.metadata(
                                  "design:type",
                                  Function
                                )(
                                  (xn =
                                    Reflect.metadata("design:paramtypes", [
                                      void 0 === zn ? Object : zn,
                                      void 0 === Ln ? Object : Ln,
                                      void 0 === $i.c ? Object : $i.c,
                                      void 0 === $i.b ? Object : $i.b,
                                      void 0 === O.ZLoggerFactory
                                        ? Object
                                        : O.ZLoggerFactory,
                                    ])(
                                      (xn = class {
                                        constructor(e, t, s, a, n) {
                                          (this.api = e),
                                            (this.segmentManager = t),
                                            (this.messageRepository = s),
                                            (this.messageManager = a),
                                            Object(i.a)(this, "logger", void 0),
                                            (this.logger = n.createZLogger(
                                              "cld-msg",
                                              ["manager"]
                                            ));
                                        }
                                        async crawlMissingMessage(e, t, s) {
                                          const i =
                                              await this.segmentManager.get(e),
                                            a = (() => {
                                              var e;
                                              let t =
                                                s.minMsgId &&
                                                Number.parseInt(s.minMsgId);
                                              return (
                                                i &&
                                                  i.lastDeletedMsgID &&
                                                  (t = t
                                                    ? Math.max(
                                                        i.lastDeletedMsgID,
                                                        t
                                                      )
                                                    : i.lastDeletedMsgID),
                                                null === (e = t) || void 0 === e
                                                  ? void 0
                                                  : e.toString()
                                              );
                                            })(),
                                            n = "0" !== t,
                                            r = n ? s.count + 1 : s.count;
                                          if (n && t <= a) return Hn;
                                          const o = await this.messageManager
                                              .findPrevMessagesFromMsgId(e, {
                                                maxMsgId:
                                                  "0" !== t ? t : void 0,
                                                minMsgId: a,
                                                limit: r,
                                              })
                                              .then((e) =>
                                                e.map((e) => e.entity)
                                              ),
                                            c = new Set();
                                          o.forEach((e) => {
                                            try {
                                              const t = Number.parseInt(
                                                e.msgId
                                              );
                                              Number.isInteger(t) &&
                                                c.add(t.toString());
                                            } catch (t) {}
                                          });
                                          const l = Array.from(c.values()),
                                            d =
                                              await this.api.crawlMissingMessage(
                                                {
                                                  conversationId: e,
                                                  requestMsgId: t,
                                                  globalMsgIds: l,
                                                  curTotalMsgs: s.curTotalMsgs,
                                                  tsJoinGroup: s.tsJoinGroup,
                                                },
                                                {
                                                  nRetry: s.nRetry,
                                                  count: s.count,
                                                }
                                              );
                                          if (
                                            0 === d.groupMsgs.length &&
                                            "0" === d.maxMsgId
                                          )
                                            return Hn;
                                          let h = Vn.a.checkDupMessageFromCloud(
                                            e,
                                            d.groupMsgs
                                          );
                                          a &&
                                            a > "0" &&
                                            (h = h.filter((e) => e.msgId > a));
                                          const u = [...o, ...h];
                                          if (0 === u.length) return Hn;
                                          const g = Number.parseInt(
                                            d.lastMsgId,
                                            10
                                          );
                                          let m = Number.parseInt(t);
                                          const v = Vn.a.findMinMaxGroupMsg(
                                              u,
                                              m,
                                              g,
                                              null == i
                                                ? void 0
                                                : i.lastDeletedMsgID
                                            ),
                                            {
                                              groupMsgsToView: f,
                                              groupMsgsAddDb: b,
                                              groupMsgsSearch: _,
                                            } = qn.a.findMsgsAddDb(
                                              t,
                                              h,
                                              [],
                                              o,
                                              Object(p.a)(
                                                {
                                                  apiType: 2,
                                                  conversationId: e,
                                                },
                                                v
                                              )
                                            );
                                          b.forEach((e) => {
                                            e.src = w.MSG_SRC.AUTO_LOADER;
                                          }),
                                            await this.messageRepository.saveMessages(
                                              b
                                            ),
                                            await qn.a.updateSearchV3(_, e);
                                          const S = !!d.isFilteredByPhase,
                                            y = d.maxMsgId;
                                          v.minMsgId &&
                                            v.maxMsgId &&
                                            (await this.segmentManager.createOrExtendSegment(
                                              e,
                                              {
                                                verifiedRange: [
                                                  v.minMsgId,
                                                  v.maxMsgId,
                                                ],
                                              }
                                            ));
                                          let C = "0";
                                          Number.isInteger(
                                            Number.parseInt(d.tsJoinGroup)
                                          )
                                            ? (C = d.tsJoinGroup)
                                            : this.logger.zsymb(
                                                18,
                                                9884,
                                                3e4,
                                                () => [
                                                  "api res invalid ts join group",
                                                  {
                                                    tsJoinGroup: d.tsJoinGroup,
                                                  },
                                                ]
                                              );
                                          const I = !!d.isFilteredByTimeJoin,
                                            O = {
                                              totalMsgCount: f.length,
                                              fetchedMsgCount: b.length,
                                              serverMsgCount: h.length,
                                              newMsgCount: b.length,
                                              phaseDone: S,
                                              isFilteredByTimeJoin: I,
                                              done: !(S || (!I && d.hasMore)),
                                              minMsgId: a,
                                              maxMsgId: y.toString(),
                                              tsJoinGroup: C,
                                            };
                                          return (
                                            this.logger.zsymb(
                                              3,
                                              9884,
                                              30001,
                                              "[auto-dl-msg] crawl result",
                                              O
                                            ),
                                            O
                                          );
                                        }
                                      })
                                    ) || xn)
                                ) || xn)
                            ) || xn)
                        ) || xn)
                    ) || xn)
                ) || xn)
            ) || xn)
        ) || xn;
      a.ModuleContainer.registerSingleton(Rn, jn),
        a.ModuleContainer.registerSingleton(Ln, Un),
        a.ModuleContainer.registerSingleton(Mn, Kn);
      var $n,
        Wn = s("KP/S"),
        Zn = s("wiGx");
      const Qn = {
        screen: Zn.a.Hidden,
        error: Wn.c.NO_ERROR,
        progress: 0,
        numOfSyncedConv: 0,
        popupVisible: !1,
        startSyncTime: 0,
        closing: !1,
        syncingConversation: null,
      };
      Object(B.b)(Zn.b)(
        ($n = class {
          constructor() {
            Object(i.a)(this, "state", Object(p.a)({}, Qn)),
              Object(i.a)(this, "name", "sync-message-ui"),
              Object(i.a)(this, "key", "window_id");
          }
          showPopup() {
            this.setState((e) => {
              e.popupVisible = !0;
            });
          }
          setSyncingConversation(e) {
            this.setState((t) => {
              t.syncingConversation = e;
            });
          }
          hidePopup() {
            this.setState((e) => {
              e.popupVisible = !1;
            });
          }
          hideAllUI() {
            this.setState((e) => {
              (e.screen = Zn.a.Hidden), (e.closing = !1);
            });
          }
          showError(e) {
            this.setState((t) => {
              (t.error = e),
                (t.screen = Zn.a.Error),
                (t.syncingConversation = null);
            });
          }
          showSuggestNewSync(e) {
            this.setState((t) => {
              (t.screen = Zn.a.SuggestNewSync), (t.popupVisible = e);
            });
          }
          showSuggestResume() {
            this.setState((e) => {
              (e.screen = Zn.a.SuggestResume), (e.popupVisible = !1);
            });
          }
          showSyncGuide() {
            this.setState((e) => {
              (e.screen = Zn.a.SyncGuide), (e.popupVisible = !0);
            });
          }
          showWaitForBackup() {
            this.setState((e) => {
              e.screen = Zn.a.WaitForBackup;
            });
          }
          showDownloadingBackup() {
            this.setState((e) => {
              (e.screen = Zn.a.DownloadingBackup), (e.progress = 0);
            });
          }
          showDecryptingBackup() {
            this.setState((e) => {
              (e.screen = Zn.a.DecryptingBackup), (e.progress = 0);
            });
          }
          showInProgress() {
            this.setState((e) => {
              (e.screen = Zn.a.SyncInProgress), (e.progress = 0);
            });
          }
          showCloseNotice() {
            this.setState((e) => {
              e.closing = !0;
            });
          }
          showSuccessMessage() {
            this.setState((e) => {
              (e.screen = Zn.a.SyncSuccess), (e.syncingConversation = null);
            });
          }
          showWaitForNetwork() {
            this.setState((e) => {
              e.screen = Zn.a.WaitForNetwork;
            });
          }
          setProgress(e) {
            this.setState((t) => {
              t.progress = e;
            });
          }
          setNumOfSyncedConv(e) {
            this.setState((t) => {
              t.numOfSyncedConv = e;
            });
          }
          resetStartSyncTime() {
            this.setState((e) => {
              e.startSyncTime = Date.now();
            });
          }
          clearError() {
            this.setState((e) => {
              e.error = Wn.c.NO_ERROR;
            });
          }
          getStartSyncTime() {
            return this.state.startSyncTime;
          }
          getCurrentError() {
            return this.state.error;
          }
          getCurrentScreen() {
            return this.state.screen;
          }
          getPopupVisible() {
            return this.state.popupVisible;
          }
          init() {}
          getItem() {
            return this.state;
          }
          getList() {
            return [];
          }
          onGetItemFailure() {}
          onGetListFailure() {}
          setState(e) {
            const t = rt()(this.state, e);
            this.state !== t &&
              ((this.state = t), Object(yt.g)(this.name, "current"));
          }
        })
      );
      var Yn = s("PJMN"),
        Jn = s.n(Yn);
      class Xn {
        constructor(e, t, s) {
          Object(i.a)(this, "_issuedAt", void 0),
            Object(i.a)(this, "_ttl", void 0),
            Object(i.a)(this, "_publicKey", void 0),
            Object(i.a)(this, "_privateKey", void 0),
            (this._publicKey = e),
            (this._privateKey = t),
            (this._ttl = s),
            (this._issuedAt = Date.now());
        }
        get valid() {
          return Date.now() - this._issuedAt < this._ttl;
        }
        get publicKey() {
          return this._publicKey;
        }
        get privateKey() {
          return this._privateKey;
        }
      }
      const er = Object(a.define)("sync-message-key-generator");
      var tr;
      let sr =
        a.ModuleContainer.injectable()(
          (tr = class {
            generate() {
              return this.generateKey();
            }
            decryptKey(e, t, s) {
              return Jn.a
                .privateDecrypt(
                  {
                    key: s.privateKey,
                    padding: Jn.a.constants.RSA_PKCS1_PADDING,
                  },
                  Buffer.from(e, "base64")
                )
                .toString(t);
            }
            generateKey() {
              const e = Jn.a.generateKeyPairSync("rsa", {
                  modulusLength: 2048,
                  publicKeyEncoding: { type: "spki", format: "der" },
                  privateKeyEncoding: { type: "pkcs1", format: "pem" },
                }),
                t = e.publicKey.toString("base64"),
                s = e.privateKey,
                i = I.default.cross_setting.timeoutKey * w.ONE_HOUR_MS;
              return new Xn(t, s, i);
            }
          })
        ) || tr;
      a.ModuleContainer.registerSingleton(er, sr);
      var ir = s("NLsH");
      const ar = Object(a.define)("ui-helper");
      a.ModuleContainer.register(
        ar,
        class {
          async showUserConfirm(e = {}) {
            return new Promise((t) => {
              let s = e.message;
              "string" == typeof s && (s = jt.default.trans(s)),
                ze.p.dispatch({
                  type: y.PopupActions.TOGGLE_CONFIRM,
                  payload: {
                    headerText: jt.default.trans(
                      e.header || "STR_ZALO_CONFIRM"
                    ),
                    callback: (e, s) => {
                      const i = !!s && s.dontAskAgain;
                      t([e, i]);
                    },
                    buttons: {
                      confirm: e.confirm && jt.default.trans(e.confirm),
                      cancel: e.cancel && jt.default.trans(e.cancel),
                      type: e.primaryButtonType || "primary",
                    },
                    message: s,
                    usePrimaryForConfirm: !1,
                    width: e.width || 450,
                    options: e.remember
                      ? [{ title: e.remember, key: "dontAskAgain" }]
                      : [],
                  },
                });
            });
          }
          async showUserConfirmV2(e = {}) {
            return new Promise((t) => {
              At.a.openConfirm({
                windowId: e.windowId || Ze.c,
                name: w.MODAL_CONFIRM.confirmIdentities,
                params: {
                  title: jt.default.str(e.header || "STR_CONFIRM"),
                  message: jt.default.str(e.message || ""),
                  okText: jt.default.str(e.confirm || "STR_OK"),
                  cancelText: jt.default.str(e.cancel || "STR_CANCEL"),
                  okType: e.primaryButtonType,
                  width: e.width,
                  onOk: () => {
                    t(!0);
                  },
                  onCancel: () => {
                    t(!1);
                  },
                },
              });
            });
          }
          closeUserCOnfrimV2(e) {
            At.a.isVisible({
              windowId: (null == e ? void 0 : e.windowId) || Ze.c,
              name: w.MODAL_CONFIRM.confirmIdentities,
            }) &&
              At.a.closeConfirm({
                windowId: (null == e ? void 0 : e.windowId) || Ze.c,
                name: w.MODAL_CONFIRM.confirmIdentities,
              });
          }
        }
      );
      var nr = s("cPHW");
      const rr = Object(a.define)("sync-message-service");
      var or = s("WvT7");
      class cr {
        constructor() {
          Object(i.a)(this, "interpreter", void 0);
        }
        create(e) {
          this.interpreter = new or.Interpreter(this.createMachine(e), e);
        }
        get status() {
          var e;
          return (
            (null === (e = this.interpreter) || void 0 === e
              ? void 0
              : e.status) || or.InterpreterStatus.NotStarted
          );
        }
        start() {
          var e;
          null === (e = this.interpreter) || void 0 === e || e.start();
        }
        stop() {
          var e;
          null === (e = this.interpreter) || void 0 === e || e.stop();
        }
        send(e) {
          return this.interpreter.send(e);
        }
        onChange(e) {
          this.interpreter.onChange(e);
        }
        onTransition(e) {
          this.interpreter.onTransition(e);
        }
        onStop(e) {
          this.interpreter.onStop(e);
        }
        onDone(e) {
          this.interpreter.onDone(e);
        }
      }
      var lr = s("lgMn"),
        dr = s("FQFD"),
        hr = s("+Mel");
      let ur;
      !(function (e) {
        (e[(e.RESTORE_CONVERSATIONS = 0)] = "RESTORE_CONVERSATIONS"),
          (e[(e.RESTORE_MESSAGES = 1)] = "RESTORE_MESSAGES"),
          (e[(e.UPDATE_MESSAGES_CACHE = 2)] = "UPDATE_MESSAGES_CACHE");
      })(ur || (ur = {}));
      const gr = Object(a.define)("sync-message-storage");
      class pr {
        constructor() {
          Object(i.a)(this, "key", "");
        }
        load() {
          if ("" !== this.key)
            throw new Error("SyncStorage already initialized");
          this.key = "sync_cross_state";
        }
        read(e, t) {
          const s = r.a.getInstance();
          e = `${this.key}_${e}`;
          const i = s.getItemForCurrentUser(e);
          if (i) {
            const a = JSON.parse(i);
            if (a.version === t) return a.value;
            s.removeItemForCurrentUser(e);
          }
          return null;
        }
        write(e, t, s) {
          const i = r.a.getInstance();
          if (null !== s)
            return (
              (e = `${this.key}_${e}`),
              void i.setItemForCurrentUser(
                e,
                JSON.stringify({ version: t, value: s })
              )
            );
          this.remove(e);
        }
        remove(e) {
          const t = r.a.getInstance();
          (e = `${this.key}_${e}`), t.removeItemForCurrentUser(e);
        }
      }
      class mr {
        constructor(e) {
          (this.adapter = e), Object(i.a)(this, "_state", void 0);
        }
        get step() {
          if (!this._state) throw new Error("SyncStateStore not initialized");
          return this._state.step;
        }
        get isStarted() {
          return !!this._state && this._state.started;
        }
        get isSyncing() {
          return !!this._state && this._state.isSyncing;
        }
        set isSyncing(e) {
          if (!this._state) throw new Error("SyncStateStore not initialized");
          (this._state = Object(p.a)(
            Object(p.a)({}, this._state),
            {},
            { isSyncing: e }
          )),
            this.save();
        }
        get checkpoint() {
          if (!this._state) throw new Error("SyncStateStore not initialized");
          if (!this._state.checkpoint)
            throw new Error("Reset checkpoint before using");
          return this._state.checkpoint;
        }
        set checkpoint(e) {
          if (!this._state) throw new Error("SyncStateStore not initialized");
          if (!e) throw new Error("checkpoint should not be null");
          (this._state = Object(p.a)(
            Object(p.a)({}, this._state),
            {},
            { checkpoint: e }
          )),
            this.save();
        }
        load() {
          this._state = this.adapter.read("sync-state", 1);
        }
        resetCheckpoint(e, t, s) {
          if (!this._state) throw new Error("SyncStateStore not initialized");
          if (0 === e)
            this._state = Object(p.a)(
              Object(p.a)({}, this._state),
              {},
              {
                checkpoint: {
                  format: 0,
                  syncedConversations: 0,
                  updatedConversation: 0,
                  importedMessages: 0,
                  syncedMessages: 0,
                  minSeq: t,
                  maxSeq: s,
                  currentSeq: Number.MAX_SAFE_INTEGER,
                },
              }
            );
          else {
            if (1 !== e) throw new Error("checkpoint.format must be 0 or 1");
            this._state = Object(p.a)(
              Object(p.a)({}, this._state),
              {},
              {
                checkpoint: {
                  format: 1,
                  syncedConversations: 0,
                  updatedConversation: 0,
                  importedMessages: 0,
                  syncedMessages: 0,
                  minSeq: t,
                  maxSeq: s,
                  currentSeq: {},
                  priorities: [],
                  syncingConversation: null,
                },
              }
            );
          }
        }
        nextStep() {
          if (!this._state) throw new Error("SyncStateStore not initialized");
          const e = this._state.step + 1;
          if (e > ur.UPDATE_MESSAGES_CACHE)
            throw new Error("already at the last step");
          (this._state = Object(p.a)(
            Object(p.a)({}, this._state),
            {},
            { step: e }
          )),
            this.save();
        }
        reset() {
          (this._state = {
            step: ur.RESTORE_CONVERSATIONS,
            started: !0,
            isSyncing: !1,
          }),
            this.save();
        }
        clear() {
          (this._state = null), this.adapter.remove("sync-state");
        }
        save() {
          this._state
            ? this.adapter.write("sync-state", 1, this._state)
            : this.adapter.remove("sync-state");
        }
      }
      class vr {
        constructor(e) {
          (this.adapter = e), Object(i.a)(this, "_backup", void 0);
        }
        load() {
          this._backup = this.adapter.read("backup", 1);
        }
        get() {
          if (void 0 === this._backup)
            throw new Error("BackupStore not initialized");
          return this._backup;
        }
        save(e) {
          return (
            (this._backup = e), this.adapter.write("backup", 1, this._backup), e
          );
        }
        clear() {
          (this._backup = null), this.adapter.remove("backup");
        }
      }
      class fr {
        constructor(e) {
          (this.adapter = e), Object(i.a)(this, "_value", void 0);
        }
        load() {
          this._value = this.adapter.read("src", 1);
        }
        get() {
          if (void 0 === this._value)
            throw new Error("SyncSourceStore not initialized");
          return this._value;
        }
        save(e) {
          (this._value = e), this.adapter.write("src", 1, this._value);
        }
        clear() {
          (this._value = null), this.adapter.remove("src");
        }
      }
      a.ModuleContainer.registerSingleton(
        gr,
        class {
          constructor() {
            Object(i.a)(this, "_adapter", void 0),
              Object(i.a)(this, "_syncStateStore", void 0),
              Object(i.a)(this, "_syncSourceStore", void 0),
              Object(i.a)(this, "_backupStore", void 0),
              (this._adapter = new pr()),
              (this._syncStateStore = new mr(this._adapter)),
              (this._syncSourceStore = new fr(this._adapter)),
              (this._backupStore = new vr(this._adapter));
          }
          load(e) {
            this.migrate(),
              this._adapter.load(),
              this._syncSourceStore.load(),
              this._syncStateStore.load(),
              this._backupStore.load();
          }
          clear() {
            this._syncSourceStore.clear(),
              this._syncStateStore.clear(),
              this._backupStore.clear();
          }
          get syncState() {
            return this._syncStateStore;
          }
          get backup() {
            return this._backupStore;
          }
          get syncSource() {
            return this._syncSourceStore;
          }
          migrate() {}
        }
      );
      var br,
        _r = s("6D/Z");
      const Sr = Object(a.define)("sync-message-metrics");
      let yr =
        Object(a.injectable)()(
          (br =
            (function (e, t) {
              return Object(a.inject)(O.ZLoggerFactory)(e, void 0, 0);
            })(
              (br =
                Reflect.metadata(
                  "design:type",
                  Function
                )(
                  (br =
                    Reflect.metadata("design:paramtypes", [
                      void 0 === O.ZLoggerFactory ? Object : O.ZLoggerFactory,
                    ])(
                      (br = class {
                        constructor(e) {
                          Object(i.a)(this, "startTime", -1),
                            Object(i.a)(this, "lastMilestone", -1),
                            Object(i.a)(this, "lastSyncSource", Wn.i.MANUAL),
                            Object(i.a)(this, "logger", void 0),
                            (this.logger = e.createZLogger("msg-sync", [
                              "metrics",
                            ]));
                        }
                        get storage() {
                          return a.ModuleContainer.resolve(gr);
                        }
                        get uiState() {
                          return a.ModuleContainer.resolve(_r.b);
                        }
                        get setting() {
                          return a.ModuleContainer.resolve(dr.a);
                        }
                        setLastSyncSource(e) {
                          this.lastSyncSource = e;
                        }
                        getLastSyncSource() {
                          return this.lastSyncSource;
                        }
                        onCheckSyncSuggestion(e) {
                          switch (e) {
                            case Wn.i.FIRST_TIME_LOGIN:
                              break;
                            case Wn.i.OVERFLOW:
                              this.actionLog(2090208);
                          }
                        }
                        onShowSyncSuggestion() {
                          switch (this.storage.syncSource.get()) {
                            case Wn.i.FIRST_TIME_LOGIN:
                              this.actionLog(2090101);
                              break;
                            case Wn.i.OVERFLOW:
                            case Wn.i.E2EE_MISSING_MESSAGE:
                              this.actionLog(2090201);
                          }
                        }
                        onShowErrorModal() {
                          this.uiState.getCurrentError() ===
                            Wn.c.USER_DONT_CONFIRM && this.actionLog(2090801);
                        }
                        onShowErrorBanner(e) {
                          const t = this.storage.backup.get(),
                            s = this.getSyncDuration(),
                            i = JSON.stringify({
                              format: (null == t ? void 0 : t.format) || void 0,
                              src: this.lastSyncSource,
                              import:
                                this.storage.syncState.checkpoint
                                  .importedMessages,
                              transfer:
                                (null == t
                                  ? void 0
                                  : t.numberOfMessagesCount) || void 0,
                            });
                          Zt.default.increaseFailed(
                            Wn.e.GENERAL,
                            0,
                            s,
                            e,
                            Date.now(),
                            [i]
                          ),
                            this.logger.zsymb(
                              0,
                              11477,
                              3e4,
                              `onShowErrorBanner ${e} ${i}`
                            ),
                            e === Wn.c.USER_DONT_CONFIRM &&
                              this.actionLog(2090903);
                        }
                        onCloseBanner() {
                          const e = this.uiState.getCurrentError(),
                            t = this.uiState.getPopupVisible(),
                            s = this.uiState.getCurrentScreen();
                          if (!t) {
                            if ((this.actionLog(2090301), s === _r.a.SyncGuide))
                              this.actionLog(2090701);
                            e !== Wn.c.NO_ERROR &&
                              (t || this.actionLog(2090402),
                              e === Wn.c.USER_DONT_CONFIRM &&
                                this.actionLog(2090901));
                          }
                        }
                        onClosePopup() {
                          const e = this.uiState.getCurrentError();
                          this.uiState.getCurrentScreen() === _r.a.SyncGuide &&
                            this.actionLog(2090601),
                            e === Wn.c.USER_DONT_CONFIRM &&
                              this.actionLog(2090803),
                            e !== Wn.c.NO_ERROR && this.actionLog(2091406);
                        }
                        onCloseSyncSuggestion() {
                          switch (this.storage.syncSource.get()) {
                            case Wn.i.FIRST_TIME_LOGIN:
                              this.actionLog(2090101);
                              break;
                            case Wn.i.OVERFLOW:
                            case Wn.i.E2EE_MISSING_MESSAGE:
                              this.actionLog(2090203);
                          }
                        }
                        clickResend() {
                          this.actionLog(2090602);
                        }
                        clickCacnelInCloseSyncSuggestionConfirmModal() {
                          switch (this.storage.syncSource.get()) {
                            case Wn.i.FIRST_TIME_LOGIN:
                              break;
                            case Wn.i.OVERFLOW:
                              this.actionLog(2090206);
                          }
                        }
                        clickConfirmSync() {
                          switch (this.storage.syncSource.get()) {
                            case Wn.i.MANUAL:
                              this.setting.value().dontSuggest
                                ? this.actionLog(2091001)
                                : this.actionLog(2091002);
                              break;
                            case Wn.i.SETTING:
                              this.setting.value().dontSuggest
                                ? this.actionLog(2090502)
                                : this.actionLog(2090501);
                              break;
                            case Wn.i.FIRST_TIME_LOGIN:
                              this.actionLog(2090102);
                              break;
                            case Wn.i.OVERFLOW:
                            case Wn.i.E2EE_MISSING_MESSAGE:
                              this.actionLog(2090202);
                          }
                        }
                        clickRejectSuggestion() {
                          this.actionLog(2090103);
                        }
                        clickContinueInRejectSuggestionConfirmModal() {
                          switch (this.storage.syncSource.get()) {
                            case Wn.i.FIRST_TIME_LOGIN:
                              break;
                            case Wn.i.OVERFLOW:
                              this.setting.value().dontSuggest
                                ? this.actionLog(2090205)
                                : this.actionLog(2090204);
                          }
                        }
                        clickCancelInRejectSuggestionConfirmModal() {}
                        clickCancelSync() {
                          switch (this.uiState.getCurrentScreen()) {
                            case _r.a.SyncGuide:
                              this.actionLog(2090304);
                              break;
                            case _r.a.WaitForBackup:
                              this.actionLog(2090305);
                          }
                        }
                        clickCancelInCancelSyncConfirmModal() {
                          this.actionLog(2090302);
                        }
                        clickConfirmCancelSyncConfirmModal() {
                          this.uiState.getCurrentScreen() === _r.a.SyncGuide &&
                            this.actionLog(2090311),
                            this.actionLog(2090303);
                        }
                        clickRetrySync() {
                          const e = this.uiState.getCurrentError(),
                            t = this.uiState.getPopupVisible();
                          e !== Wn.c.NO_ERROR &&
                            (this.actionLog(2090401),
                            t && this.actionLog(2091407),
                            e === Wn.c.USER_DONT_CONFIRM &&
                              (t
                                ? this.actionLog(2090802)
                                : this.actionLog(2090902)));
                        }
                        clickViewGuide() {
                          this.actionLog(2090702);
                        }
                        resetSyncStartTime() {
                          (this.startTime = Vt.a.now()),
                            (this.lastMilestone = Vt.a.now());
                        }
                        onSyncSuccess(e, t, s) {
                          this.actionLog(2091101);
                          const i = this.getSyncDuration(),
                            a = JSON.stringify({
                              format: e,
                              src: this.lastSyncSource,
                              import: t,
                              transfer: s,
                            });
                          Zt.default.increaseSuccess(Wn.e.GENERAL, 0, i, [a]),
                            this.logger.zsymb(
                              0,
                              11477,
                              30001,
                              `onSyncSuccess ${a}`
                            );
                        }
                        onReqBackupSuccess(e) {
                          const t = this.getMilestoneDuration(!0);
                          Zt.default.increaseSuccess(Wn.e.REQ_BACKUP, 0, t, [
                            JSON.stringify({ format: e }),
                          ]);
                        }
                        onReqBackupFailure(e, t) {
                          Zt.default.increaseFailed(
                            Wn.e.REQ_BACKUP,
                            e,
                            this.getMilestoneDuration(),
                            t,
                            Date.now()
                          );
                        }
                        onDownloadBackupSuccess() {
                          const e = this.getMilestoneDuration(!0);
                          Zt.default.increaseSuccess(
                            Wn.e.DOWNLOAD_BACKUP,
                            0,
                            e
                          );
                        }
                        onDownloadBackupFailure(e, t) {
                          Zt.default.increaseFailed(
                            Wn.e.DOWNLOAD_BACKUP,
                            e,
                            this.getMilestoneDuration(),
                            t,
                            Date.now()
                          );
                        }
                        onDecryptBackupSuccess() {
                          const e = this.getMilestoneDuration(!0);
                          Zt.default.increaseSuccess(Wn.e.DECRYPT_BACKUP, 0, e);
                        }
                        onDecryptBackupFailure(e) {
                          const t = this.getMilestoneDuration();
                          Zt.default.increaseFailed(
                            Wn.e.DECRYPT_BACKUP,
                            0,
                            t,
                            e,
                            Date.now()
                          );
                        }
                        onRestoreDataSuccess() {
                          const e = this.getMilestoneDuration(!0);
                          Zt.default.increaseSuccess(Wn.e.RESTORE_TASK, 0, e);
                        }
                        onRestoreDataFailure(e) {
                          const t = this.getMilestoneDuration();
                          Zt.default.increaseFailed(
                            Wn.e.RESTORE_TASK,
                            Wn.f.SELF_DEFINE,
                            t,
                            e,
                            Date.now()
                          );
                        }
                        clickConfirmCancelSyncConfirmModalFromCounterModal() {
                          this.uiState.getCurrentScreen() === _r.a.SyncGuide &&
                            this.actionLog(2090311),
                            this.actionLog(2090303);
                        }
                        onErrorTimeoutWaitingMobileConfirm() {
                          this.actionLog(2090312);
                        }
                        clickCloseSynGuidePopup() {
                          this.actionLog(2090601);
                        }
                        onShowSyncGuidePopup() {
                          this.actionLog(2090604);
                        }
                        onConfirmSyncFromMobile() {
                          this.actionLog(2090605);
                        }
                        onRejectSyncFromMobile() {
                          this.actionLog(2090606);
                        }
                        onErrorPopupWaitingMobileConfirm(e) {
                          if (this.uiState.getPopupVisible())
                            switch ((this.actionLog(2091401), e)) {
                              case Wn.c.NO_NETWORK:
                                this.actionLog(2091402);
                                break;
                              case Wn.c.USER_DONT_CONFIRM:
                                this.actionLog(2091403);
                                break;
                              case Wn.c.BUSY_RESTORING:
                                this.actionLog(2091404);
                                break;
                              case Wn.c.CLIENT_NOT_SUPPORT:
                                this.actionLog(2091405);
                            }
                        }
                        receiveOverqueueMsgSignal() {
                          this.actionLog(2090210);
                        }
                        onShowSyncSuggestionWithoutResume() {
                          this.actionLog(2090209);
                        }
                        actionLog(e) {
                          Z.e.logAction(e);
                        }
                        getSyncDuration() {
                          return this.startTime > 0
                            ? Vt.a.now() - this.startTime
                            : 0;
                        }
                        getMilestoneDuration(e = !1) {
                          const t =
                            this.lastMilestone > 0
                              ? Vt.a.now() - this.lastMilestone
                              : 0;
                          return e && (this.lastMilestone = Vt.a.now()), t;
                        }
                      })
                    ) || br)
                ) || br)
            ) || br)
        ) || br;
      function Cr(e) {
        const t = { retryCount: -1, canRetry: 0 !== e.maxRetry };
        return Object(or.createMachine)({
          context: t,
          initial: "running",
          states: {
            running: {
              entry: or.actions.assign({ retryCount: (e) => e.retryCount + 1 }),
              invoke: {
                src: (t) => e.action(t.retryCount),
                onError: [
                  {
                    cond: (t, s) =>
                      !(
                        !t.canRetry ||
                        ("function" == typeof e.canRetryError &&
                          !e.canRetryError(s.data))
                      ),
                    target: "retry",
                  },
                  {
                    actions: (e, t) => {
                      e.error = t.data;
                    },
                    target: "failure",
                  },
                ],
                onDone: { target: "final" },
              },
            },
            retry: {
              invoke: {
                src: () => (t) => {
                  const s = e.autoRetry || 0;
                  if (s > 0) {
                    const e = setTimeout(() => {
                      t({ type: "RETRY" });
                    }, s);
                    return () => clearTimeout(e);
                  }
                  return () => {};
                },
              },
              on: {
                RETRY: {
                  actions: or.actions.assign({
                    canRetry: (t) =>
                      -1 === e.maxRetry || t.retryCount < e.maxRetry,
                  }),
                  target: "running",
                },
                ABORT: { target: "final" },
              },
            },
            failure: {
              type: "final",
              data: (e) => ({ success: !1, error: e.error }),
            },
            final: { type: "final", data: { success: !0 } },
          },
        });
      }
      a.ModuleContainer.registerSingleton(Sr, yr);
      var Ir = s("ttnr");
      function Or(e, t, s, i) {
        return Object(or.createMachine)({
          strict: !0,
          context: {},
          initial: "running",
          states: {
            running: {
              initial: "prepare",
              states: {
                prepare: {
                  entry: () => {
                    e.zsymb(3, 11491, 3e4, "prepare");
                  },
                  invoke: {
                    src: async () => t.prepareNewSync(),
                    onDone: "request_backup",
                    onError: {
                      actions: () => {
                        Zt.default.increaseFailed(98102, 0, 0, 0, Date.now()),
                          s.showError(Wn.c.PREPARE_NEW_SYNC_FAILED);
                      },
                      target: "failure",
                    },
                  },
                },
                request_backup: {
                  entry: () => {
                    N.a.SyncMessageController.setRequestBackupTimeout(!1),
                      e.zsymb(3, 11491, 30001, "send_request"),
                      s.clearError(),
                      s.showSyncGuide();
                  },
                  invoke: {
                    id: "request_backup_api",
                    src: Cr({
                      action: async (e) => t.request(e),
                      maxRetry: 2,
                      autoRetry: 5e3,
                      canRetryError: (e) =>
                        e.code === w.NetWorkError.NO_NETWORK
                          ? (i.onReqBackupFailure(
                              Wn.f.SELF_DEFINE,
                              Wn.g.NO_NET
                            ),
                            !1)
                          : 211 === e.error_code || -69 === e.error_code
                          ? (i.onReqBackupFailure(Wn.f.EXTERNAL, e.error_code),
                            !1)
                          : (i.onReqBackupFailure(
                              Wn.f.EXTERNAL,
                              e.error_code || -1
                            ),
                            !0),
                    }),
                    onDone: [
                      {
                        cond: (e, t) => t.data.success,
                        target: "wait_for_user_confirm",
                      },
                      {
                        cond: (e, t) => {
                          var s;
                          return (
                            (null === (s = t.data.error) || void 0 === s
                              ? void 0
                              : s.code) === w.NetWorkError.NO_NETWORK
                          );
                        },
                        target: "#wait_for_network",
                      },
                      {
                        actions: (e, t) => {
                          var a;
                          211 ===
                          (null === (a = t.data.error) || void 0 === a
                            ? void 0
                            : a.error_code)
                            ? (s.showError(Wn.c.CLIENT_NOT_SUPPORT),
                              i.onErrorPopupWaitingMobileConfirm(
                                Wn.c.CLIENT_NOT_SUPPORT
                              ))
                            : s.showError(Wn.c.REQUEST_BACKUP_FAILED);
                        },
                        target: "failure",
                      },
                    ],
                    onError: {
                      actions: () => {
                        s.showError(Wn.c.REQUEST_BACKUP_FAILED);
                      },
                      target: "failure",
                    },
                  },
                  on: {
                    SUCCESS: { target: "wait_for_user_confirm" },
                    ERR_TIMEOUT: {
                      actions: () => {
                        s.showError(Wn.c.BACKUP_TIMEOUT),
                          Ir.a.isEnableUXConfirmTransferRevamp() &&
                            N.a.SyncMessageController.closeCancelSyncInSuggestingPopup();
                      },
                      target: "failure",
                    },
                    ERROR: {
                      actions: () => {
                        s.showError(Wn.c.REQUEST_BACKUP_FAILED),
                          Ir.a.isEnableUXConfirmTransferRevamp() &&
                            N.a.SyncMessageController.closeCancelSyncInSuggestingPopup();
                      },
                      target: "failure",
                    },
                    ERR_CLIENT_NOT_SUPPORT: {
                      actions: () => {
                        s.showError(Wn.c.CLIENT_NOT_SUPPORT),
                          i.onErrorPopupWaitingMobileConfirm(
                            Wn.c.CLIENT_NOT_SUPPORT
                          ),
                          Ir.a.isEnableUXConfirmTransferRevamp() &&
                            N.a.SyncMessageController.closeCancelSyncInSuggestingPopup();
                      },
                      target: "failure",
                    },
                    USER_CONFIRM: {
                      actions: () => {
                        e.zsymb(3, 11491, 30002, "user_confirm"),
                          s.hidePopup(),
                          Ir.a.isEnableUXConfirmTransferRevamp() &&
                            N.a.SyncMessageController.closeCancelSyncInSuggestingPopup();
                      },
                      target: "wait_for_backup",
                    },
                    USER_REJECT: {
                      actions: () => {
                        s.showError(Wn.c.USER_REJECT_BACKUP),
                          s.hidePopup(),
                          Ir.a.isEnableUXConfirmTransferRevamp() &&
                            N.a.SyncMessageController.closeCancelSyncInSuggestingPopup();
                      },
                      target: "failure",
                    },
                    ERR_BACKUP_FAIL: {
                      actions: () => {
                        s.showError(Wn.c.BACKUP_FAILED),
                          Ir.a.isEnableUXConfirmTransferRevamp() &&
                            N.a.SyncMessageController.closeCancelSyncInSuggestingPopup();
                      },
                      target: "failure",
                    },
                  },
                },
                wait_for_user_confirm: {
                  entry: () => {
                    e.zsymb(3, 11491, 30003, "wait_for_user_confirm"),
                      s.clearError(),
                      s.showSyncGuide(),
                      i.onShowSyncGuidePopup();
                  },
                  on: {
                    USER_CONFIRM: {
                      actions: () => {
                        e.zsymb(3, 11491, 30004, "user_confirm"),
                          s.hidePopup(),
                          i.onConfirmSyncFromMobile(),
                          Ir.a.isEnableUXConfirmTransferRevamp() &&
                            N.a.SyncMessageController.closeCancelSyncInSuggestingPopup();
                      },
                      target: "wait_for_backup",
                    },
                    USER_REJECT: {
                      actions: () => {
                        s.showError(Wn.c.USER_REJECT_BACKUP),
                          s.hidePopup(),
                          i.onRejectSyncFromMobile(),
                          Ir.a.isEnableUXConfirmTransferRevamp() &&
                            N.a.SyncMessageController.closeCancelSyncInSuggestingPopup();
                      },
                      target: "failure",
                    },
                    ERR_TIMEOUT: {
                      actions: () => {
                        i.onReqBackupFailure(
                          Wn.f.SELF_DEFINE,
                          Wn.g.CONFIRM_TIMEOUT
                        ),
                          i.onErrorTimeoutWaitingMobileConfirm(),
                          i.onErrorPopupWaitingMobileConfirm(
                            Wn.c.USER_DONT_CONFIRM
                          ),
                          s.showError(Wn.c.USER_DONT_CONFIRM),
                          Ir.a.isEnableUXConfirmTransferRevamp() &&
                            N.a.SyncMessageController.closeCancelSyncInSuggestingPopup();
                      },
                      target: "failure",
                    },
                    ERR_INVALID_BACKUP: {
                      actions: () => {
                        s.showError(Wn.c.REQUEST_BACKUP_FAILED),
                          Ir.a.isEnableUXConfirmTransferRevamp() &&
                            N.a.SyncMessageController.closeCancelSyncInSuggestingPopup();
                      },
                      target: "failure",
                    },
                    ERR_BUSY_RESTORING: {
                      actions: () => {
                        i.onReqBackupFailure(
                          Wn.f.SELF_DEFINE,
                          Wn.g.BUSY_RESTORING
                        ),
                          s.showError(Wn.c.BUSY_RESTORING),
                          i.onErrorPopupWaitingMobileConfirm(
                            Wn.c.BUSY_RESTORING
                          ),
                          Ir.a.isEnableUXConfirmTransferRevamp() &&
                            N.a.SyncMessageController.closeCancelSyncInSuggestingPopup();
                      },
                      target: "failure",
                    },
                    ERR_BACKUP_FAIL: {
                      actions: () => {
                        i.onReqBackupFailure(
                          Wn.f.SELF_DEFINE,
                          Wn.g.BACKUP_FAILED
                        ),
                          s.showError(Wn.c.BACKUP_FAILED),
                          Ir.a.isEnableUXConfirmTransferRevamp() &&
                            N.a.SyncMessageController.closeCancelSyncInSuggestingPopup();
                      },
                      target: "failure",
                    },
                  },
                },
                wait_for_backup: {
                  entry: () => {
                    e.zsymb(3, 11491, 30005, "wait_for_backup"),
                      N.a.SyncMessageController.setRequestBackupTimeout(!0),
                      s.showWaitForBackup();
                  },
                  on: {
                    SUCCESS: { target: "download_backup" },
                    ERR_TIMEOUT: {
                      actions: () => {
                        i.onReqBackupFailure(
                          Wn.f.SELF_DEFINE,
                          Wn.g.BACKUP_TIMEOUT
                        ),
                          s.showError(Wn.c.BACKUP_TIMEOUT);
                      },
                      target: "failure",
                    },
                    ERR_BACKUP_FAIL: {
                      actions: () => {
                        s.showError(Wn.c.BACKUP_FAILED);
                      },
                      target: "failure",
                    },
                    INVALID_BACKUP_INFO: {
                      actions: () => {
                        i.onReqBackupFailure(
                          Wn.f.SELF_DEFINE,
                          Wn.g.INVALID_BACKUP
                        ),
                          s.showError(Wn.c.INVALID_BACKUP_INFO);
                      },
                      target: "failure",
                    },
                    INVALID_BACKUP_ENCRYPT_FORMAT: {
                      actions: () => {
                        i.onReqBackupFailure(
                          Wn.f.SELF_DEFINE,
                          Wn.g.INVALID_BACKUP
                        ),
                          s.showError(Wn.c.INVALID_BACKUP_ENCRYPT_FORMAT);
                      },
                      target: "failure",
                    },
                  },
                },
                download_backup: {
                  entry: () => {
                    e.zsymb(3, 11491, 30006, "download_backup"),
                      N.a.SyncMessageController.clearRequestBackupTimeout(),
                      s.showDownloadingBackup();
                  },
                  invoke: {
                    strict: !0,
                    src: Cr({
                      action: async (e) => t.download(e),
                      maxRetry: 2,
                      autoRetry: 5e3,
                      canRetryError: (e) => {
                        if (e.code === w.NetWorkError.NO_NETWORK)
                          return (
                            i.onDownloadBackupFailure(
                              Wn.f.SELF_DEFINE,
                              Wn.g.NO_NET
                            ),
                            !1
                          );
                        if (211 === e.error_code || -69 === e.error_code)
                          return (
                            i.onDownloadBackupFailure(
                              Wn.f.EXTERNAL,
                              e.error_code
                            ),
                            !1
                          );
                        const t = e.name || "";
                        if ("string" == typeof t && t.includes("ENOSPC"))
                          return (
                            i.onDownloadBackupFailure(
                              Wn.f.SELF_DEFINE,
                              Wn.b.ENOSPC
                            ),
                            !1
                          );
                        const s = e.code || e.error_code,
                          a = s ? Wn.f.EXTERNAL : Wn.f.SELF_DEFINE;
                        return (
                          i.onDownloadBackupFailure(a, s || Wn.b.UNKNOW_ERR), !0
                        );
                      },
                    }),
                    onDone: [
                      {
                        cond: (e, t) => t.data.success,
                        actions: () => {
                          i.onDownloadBackupSuccess();
                        },
                        target: "decrypt_backup",
                      },
                      {
                        cond: (e, t) => {
                          var s;
                          return (
                            (null === (s = t.data.error) || void 0 === s
                              ? void 0
                              : s.code) === w.NetWorkError.NO_NETWORK
                          );
                        },
                        target: "#wait_for_network",
                      },
                      {
                        actions: (e, t) => {
                          var a;
                          i.onDownloadBackupFailure(
                            Wn.f.SELF_DEFINE,
                            Wn.b.DOWNLOAD_BACKUP_ERR
                          );
                          const n =
                            (null === (a = t.data.error) || void 0 === a
                              ? void 0
                              : a.name) || "Error";
                          "string" == typeof n && n.includes("ENOSPC")
                            ? s.showError(Wn.c.LOW_STORAGE)
                            : s.showError(Wn.c.DOWNLOAD_FAILED);
                        },
                        target: "failure",
                      },
                    ],
                    onError: {
                      actions: () => {
                        s.showError(Wn.c.DOWNLOAD_FAILED);
                      },
                      target: "failure",
                    },
                  },
                },
                decrypt_backup: {
                  entry: () => {
                    e.zsymb(3, 11491, 30007, "decrypt_backup"),
                      s.showDecryptingBackup();
                  },
                  invoke: {
                    src: async () => t.decrypt(),
                    onDone: {
                      actions: () => {
                        i.onDecryptBackupSuccess();
                      },
                      target: "#success",
                    },
                    onError: {
                      actions: (t, a) => {
                        const n = a.data;
                        e.zsymb(18, 11491, 30008, () => [
                          "decrypt_backup error",
                          { error: n },
                        ]),
                          i.onDecryptBackupFailure(n.error_code),
                          s.showError(Wn.c.DECRYPT_FAILED);
                      },
                      target: "failure",
                    },
                  },
                },
                failure: {
                  on: {
                    RETRY_SYNC: { target: "prepare" },
                    START_SYNC: { target: "prepare" },
                    USER_CONFIRM: {
                      actions: () => {
                        e.zsymb(0, 11491, 30009, "user_confirm"),
                          s.clearError(),
                          s.hidePopup();
                      },
                      target: "wait_for_backup",
                    },
                    SUCCESS: {
                      actions: () => {
                        e.zsymb(0, 11491, 30010, "received success event"),
                          s.clearError(),
                          s.hidePopup();
                      },
                      target: "download_backup",
                    },
                  },
                },
                hist: { history: "shallow", type: "history" },
              },
            },
            success: { id: "success", type: "final" },
            wait_for_network: {
              id: "wait_for_network",
              entry: () => {
                e.zsymb(3, 11491, 30011, "wait_for_network"),
                  s.showWaitForNetwork(),
                  i.onErrorPopupWaitingMobileConfirm(Wn.c.NO_NETWORK);
              },
              on: {
                START_SYNC: { target: "running.prepare" },
                ONLINE: { target: "running.hist" },
                RETRY_SYNC: { target: "running.hist" },
              },
            },
          },
        });
      }
      var Er,
        Tr = s("VBs7");
      function Rr(e, t, s, i) {
        return Object(or.createMachine)(
          {
            context: { canRetry: !1 },
            initial: "running",
            states: {
              running: {
                entry: () => {
                  e.zsymb(3, 9931, 3e4, "restoring"), s.setProgress(0);
                },
                invoke: {
                  id: "restore_backup",
                  src: Cr({
                    action: async (e) => t.restore(e),
                    maxRetry: 5,
                    autoRetry: 2e3,
                    canRetryError: (e) => "WorkerInterrupted" === e.name,
                  }),
                  onDone: [
                    { cond: (e, t) => t.data.success, target: "cleanup" },
                    {
                      actions: (e) => {
                        s.showError(Wn.c.SYNC_FAILED);
                      },
                      target: "failure",
                    },
                  ],
                  onError: {
                    actions: (e) => {
                      s.showError(Wn.c.SYNC_FAILED);
                    },
                    target: "failure",
                  },
                },
              },
              cleanup: {
                entry: () => {
                  e.zsymb(3, 9931, 30001, "cleanup");
                },
                invoke: {
                  src: async () => {
                    t.clean();
                  },
                  onDone: "success",
                  onError: "success",
                },
              },
              wait_for_network: {
                entry: () => {
                  e.zsymb(3, 9931, 30002, "wait_for_network"),
                    s.showWaitForNetwork();
                },
                on: {
                  START_SYNC: {
                    actions: () => {
                      N.a.SyncMessageController.restartSync();
                    },
                  },
                  ONLINE: { target: "running" },
                },
              },
              failure: {
                entry: [
                  () => {
                    e.zsymb(3, 9931, 30003, "failure");
                  },
                  "signalDone",
                ],
                on: {
                  START_SYNC: {
                    actions: () => {
                      N.a.SyncMessageController.restartSync();
                    },
                  },
                  RETRY_SYNC: [
                    { target: "running", cond: (e) => e.canRetry },
                    {
                      actions: () => {
                        e.zsymb(3, 9931, 30004, "restart sync"),
                          N.a.SyncMessageController.restartSync();
                      },
                    },
                  ],
                },
              },
              success: {
                entry: [
                  () => {
                    e.zsymb(3, 9931, 30005, "success"),
                      s.showSuccessMessage(),
                      N.a.SyncMessageController.onSyncSuccess(),
                      N.a.SyncMessageController.setAutoCloseSuccessTimeout();
                  },
                  "signalDone",
                ],
                on: {
                  START_SYNC: {
                    actions: () => {
                      N.a.SyncMessageController.restartSync();
                    },
                  },
                  AUTO_CLOSE: { target: "done", actions: () => s.hideAllUI() },
                },
              },
              done: { type: "final" },
            },
          },
          {
            actions: {
              signalDone: () => {
                i.emit({ topic: Tr.a.Done });
              },
            },
          }
        );
      }
      let Lr =
        Object(a.injectable)()(
          (Er =
            (function (e, t) {
              return Object(a.inject)(O.ZLoggerFactory)(e, void 0, 0);
            })(
              (Er =
                (function (e, t) {
                  return Object(a.inject)(rr)(e, void 0, 1);
                })(
                  (Er =
                    (function (e, t) {
                      return Object(a.inject)(gr)(e, void 0, 2);
                    })(
                      (Er =
                        (function (e, t) {
                          return Object(a.inject)(_r.b)(e, void 0, 3);
                        })(
                          (Er =
                            (function (e, t) {
                              return Object(a.inject)(Sr)(e, void 0, 4);
                            })(
                              (Er =
                                (function (e, t) {
                                  return Object(a.inject)(lr.b)(e, void 0, 5);
                                })(
                                  (Er =
                                    Reflect.metadata(
                                      "design:type",
                                      Function
                                    )(
                                      (Er =
                                        Reflect.metadata("design:paramtypes", [
                                          void 0 === O.ZLoggerFactory
                                            ? Object
                                            : O.ZLoggerFactory,
                                          void 0 === rr ? Object : rr,
                                          void 0 === gr ? Object : gr,
                                          void 0 === _r.b ? Object : _r.b,
                                          void 0 === Sr ? Object : Sr,
                                          void 0 === lr.b ? Object : lr.b,
                                        ])(
                                          (Er = class extends cr {
                                            constructor(e, t, s, i, a, n) {
                                              super(),
                                                (this.loggerFactory = e),
                                                (this.service = t),
                                                (this.storage = s),
                                                (this.ui = i),
                                                (this.metrics = a),
                                                (this.zmq = n);
                                            }
                                            createMachine() {
                                              return (
                                                (e =
                                                  this.loggerFactory.createZLogger(
                                                    "msg-sync",
                                                    ["state"]
                                                  )),
                                                (t = this.metrics),
                                                (s = this.service),
                                                (i = this.storage),
                                                (a = this.ui),
                                                (n = this.zmq),
                                                Object(or.createMachine)({
                                                  strict: !0,
                                                  id: "message-sync",
                                                  context: {},
                                                  initial: "idle",
                                                  states: {
                                                    idle: {
                                                      entry: () =>
                                                        e.zsymb(
                                                          3,
                                                          11078,
                                                          3e4,
                                                          "idle"
                                                        ),
                                                      on: {
                                                        SUGGEST_NEW_SYNC:
                                                          "suggest_new_sync",
                                                        SUGGEST_RESUME:
                                                          "suggest_resume",
                                                        START_SYNC: {
                                                          actions: () => {
                                                            t.clickConfirmSync();
                                                          },
                                                          target: "run",
                                                        },
                                                      },
                                                    },
                                                    suggest_new_sync: {
                                                      entry: (s, n) => {
                                                        e.zsymb(
                                                          0,
                                                          11078,
                                                          30001,
                                                          () => [
                                                            "suggest_new_sync",
                                                            {
                                                              src: Object(Wn.n)(
                                                                n.src
                                                              ),
                                                            },
                                                          ]
                                                        ),
                                                          i.syncSource.save(
                                                            n.src
                                                          ),
                                                          t.onShowSyncSuggestion(),
                                                          a.showSuggestNewSync(
                                                            n.shouldShowSyncGuide
                                                          );
                                                      },
                                                      on: {
                                                        START_SYNC: {
                                                          actions: () => {
                                                            t.clickConfirmSync();
                                                          },
                                                          target: "run",
                                                        },
                                                        CLOSE_SUGGEST: {
                                                          actions: () =>
                                                            a.hideAllUI(),
                                                          target: "idle",
                                                        },
                                                      },
                                                    },
                                                    suggest_resume: {
                                                      entry: () => {
                                                        e.zsymb(
                                                          3,
                                                          11078,
                                                          30002,
                                                          "suggest_resume"
                                                        ),
                                                          a.showSuggestResume();
                                                      },
                                                      on: {
                                                        START_SYNC: "run",
                                                        RESUME_SYNC:
                                                          "#restore_backup",
                                                        CLOSE_SUGGEST: {
                                                          actions: () =>
                                                            a.hideAllUI(),
                                                          target: "idle",
                                                        },
                                                      },
                                                    },
                                                    run: {
                                                      initial: "request_backup",
                                                      states: {
                                                        request_backup: {
                                                          entry: () =>
                                                            e.zsymb(
                                                              3,
                                                              11078,
                                                              30003,
                                                              "request_backup"
                                                            ),
                                                          invoke: {
                                                            id: "request_backup",
                                                            src: Or(e, s, a, t),
                                                            onDone:
                                                              "restore_backup",
                                                          },
                                                          on: {
                                                            SUCCESS: {
                                                              actions: Object(
                                                                or.forwardTo
                                                              )(
                                                                "request_backup"
                                                              ),
                                                            },
                                                            USER_REJECT: {
                                                              actions: Object(
                                                                or.forwardTo
                                                              )(
                                                                "request_backup"
                                                              ),
                                                            },
                                                            USER_CONFIRM: {
                                                              actions: Object(
                                                                or.forwardTo
                                                              )(
                                                                "request_backup"
                                                              ),
                                                            },
                                                            RETRY_SYNC: {
                                                              actions: Object(
                                                                or.forwardTo
                                                              )(
                                                                "request_backup"
                                                              ),
                                                            },
                                                            ERR_INVALID_BACKUP:
                                                              {
                                                                actions: Object(
                                                                  or.forwardTo
                                                                )(
                                                                  "request_backup"
                                                                ),
                                                              },
                                                            ERR_BACKUP_FAIL: {
                                                              actions: Object(
                                                                or.forwardTo
                                                              )(
                                                                "request_backup"
                                                              ),
                                                            },
                                                            ERR_BUSY_RESTORING:
                                                              {
                                                                actions: Object(
                                                                  or.forwardTo
                                                                )(
                                                                  "request_backup"
                                                                ),
                                                              },
                                                            ERR_TIMEOUT: {
                                                              actions: Object(
                                                                or.forwardTo
                                                              )(
                                                                "request_backup"
                                                              ),
                                                            },
                                                            START_SYNC: {
                                                              actions: [
                                                                Object(
                                                                  or.forwardTo
                                                                )(
                                                                  "request_backup"
                                                                ),
                                                                () => {
                                                                  t.clickConfirmSync();
                                                                },
                                                              ],
                                                            },
                                                          },
                                                        },
                                                        restore_backup: {
                                                          id: "restore_backup",
                                                          entry: () => {
                                                            a.showInProgress(),
                                                              a.setProgress(0);
                                                          },
                                                          invoke: {
                                                            id: "restore_backup_machine",
                                                            src: Rr(e, s, a, n),
                                                            onDone: "done",
                                                          },
                                                          on: {
                                                            RESTART_SYNC: {
                                                              actions: () => {
                                                                t.clickConfirmSync();
                                                              },
                                                              target:
                                                                "request_backup",
                                                            },
                                                            START_SYNC: {
                                                              actions: Object(
                                                                or.forwardTo
                                                              )(
                                                                "restore_backup_machine"
                                                              ),
                                                            },
                                                            RETRY_SYNC: {
                                                              actions: Object(
                                                                or.forwardTo
                                                              )(
                                                                "restore_backup_machine"
                                                              ),
                                                            },
                                                            AUTO_CLOSE: {
                                                              actions: Object(
                                                                or.forwardTo
                                                              )(
                                                                "restore_backup_machine"
                                                              ),
                                                            },
                                                          },
                                                        },
                                                        done: { type: "final" },
                                                      },
                                                      onDone: "idle",
                                                    },
                                                  },
                                                  on: {
                                                    CANCEL: {
                                                      target: "idle",
                                                      actions: () =>
                                                        a.hideAllUI(),
                                                    },
                                                    RESET: {
                                                      target: "idle",
                                                      actions: () =>
                                                        a.hideAllUI(),
                                                    },
                                                  },
                                                })
                                              );
                                              var e, t, s, i, a, n;
                                            }
                                            canSuggestNewSync() {
                                              var e;
                                              const t =
                                                null ===
                                                  (e = this.interpreter) ||
                                                void 0 === e
                                                  ? void 0
                                                  : e.state;
                                              if (!t) return !1;
                                              if (t.matches("idle")) return !0;
                                              let s;
                                              return (
                                                t.children.request_backup &&
                                                  (s =
                                                    t.children.request_backup.getSnapshot()),
                                                t.children
                                                  .restore_backup_machine &&
                                                  (s =
                                                    t.children.restore_backup_machine.getSnapshot()),
                                                !s ||
                                                  s.matches("success") ||
                                                  s.matches("failure") ||
                                                  s.matches("running.failure")
                                              );
                                            }
                                            canStartNewSync() {
                                              var e;
                                              const t =
                                                null ===
                                                  (e = this.interpreter) ||
                                                void 0 === e
                                                  ? void 0
                                                  : e.state;
                                              return (
                                                !!t &&
                                                (!!(
                                                  t.matches("idle") ||
                                                  t.matches(
                                                    "suggest_new_sync"
                                                  ) ||
                                                  t.matches("suggest_resume")
                                                ) ||
                                                  this.canSuggestNewSync())
                                              );
                                            }
                                          })
                                        ) || Er)
                                    ) || Er)
                                ) || Er)
                            ) || Er)
                        ) || Er)
                    ) || Er)
                ) || Er)
            ) || Er)
        ) || Er;
      var Mr,
        Fr = s("fg6f"),
        wr = s("qKtC"),
        Dr = s("RxLg");
      Object(j.h)()(
        (Mr =
          Object(j.e)()(
            (Mr =
              Object(j.g)()(
                (Mr =
                  Object(a.singleton)(nr.a)(
                    (Mr =
                      Object(a.injectable)()(
                        (Mr =
                          (function (e, t) {
                            return Object(a.inject)(li.a)(e, void 0, 0);
                          })(
                            (Mr =
                              (function (e, t) {
                                return Object(a.inject)(O.ZLoggerFactory)(
                                  e,
                                  void 0,
                                  1
                                );
                              })(
                                (Mr =
                                  (function (e, t) {
                                    return Object(a.inject)(dr.a)(e, void 0, 2);
                                  })(
                                    (Mr =
                                      (function (e, t) {
                                        return Object(a.inject)(rr)(
                                          e,
                                          void 0,
                                          3
                                        );
                                      })(
                                        (Mr =
                                          (function (e, t) {
                                            return Object(a.inject)(_r.b)(
                                              e,
                                              void 0,
                                              4
                                            );
                                          })(
                                            (Mr =
                                              (function (e, t) {
                                                return Object(a.inject)(gr)(
                                                  e,
                                                  void 0,
                                                  5
                                                );
                                              })(
                                                (Mr =
                                                  (function (e, t) {
                                                    return Object(a.inject)(ar)(
                                                      e,
                                                      void 0,
                                                      6
                                                    );
                                                  })(
                                                    (Mr =
                                                      (function (e, t) {
                                                        return Object(a.inject)(
                                                          Sr
                                                        )(e, void 0, 7);
                                                      })(
                                                        (Mr =
                                                          (function (e, t) {
                                                            return Object(
                                                              a.inject
                                                            )(wr.a)(
                                                              e,
                                                              void 0,
                                                              8
                                                            );
                                                          })(
                                                            (Mr =
                                                              Reflect.metadata(
                                                                "design:type",
                                                                Function
                                                              )(
                                                                (Mr =
                                                                  Reflect.metadata(
                                                                    "design:paramtypes",
                                                                    [
                                                                      void 0 ===
                                                                      li.a
                                                                        ? Object
                                                                        : li.a,
                                                                      void 0 ===
                                                                      O.ZLoggerFactory
                                                                        ? Object
                                                                        : O.ZLoggerFactory,
                                                                      void 0 ===
                                                                      dr.a
                                                                        ? Object
                                                                        : dr.a,
                                                                      void 0 ===
                                                                      rr
                                                                        ? Object
                                                                        : rr,
                                                                      void 0 ===
                                                                      _r.b
                                                                        ? Object
                                                                        : _r.b,
                                                                      void 0 ===
                                                                      gr
                                                                        ? Object
                                                                        : gr,
                                                                      void 0 ===
                                                                      ar
                                                                        ? Object
                                                                        : ar,
                                                                      void 0 ===
                                                                      Sr
                                                                        ? Object
                                                                        : Sr,
                                                                      void 0 ===
                                                                      wr.a
                                                                        ? Object
                                                                        : wr.a,
                                                                    ]
                                                                  )(
                                                                    (Mr = class extends (
                                                                      re.b
                                                                    ) {
                                                                      constructor(
                                                                        e,
                                                                        t,
                                                                        s,
                                                                        n,
                                                                        r,
                                                                        o,
                                                                        c,
                                                                        l,
                                                                        d
                                                                      ) {
                                                                        super(),
                                                                          Object(
                                                                            i.a
                                                                          )(
                                                                            this,
                                                                            "initialized",
                                                                            !1
                                                                          ),
                                                                          Object(
                                                                            i.a
                                                                          )(
                                                                            this,
                                                                            "currentUserId",
                                                                            ""
                                                                          ),
                                                                          Object(
                                                                            i.a
                                                                          )(
                                                                            this,
                                                                            "currentUserUIN",
                                                                            ""
                                                                          ),
                                                                          Object(
                                                                            i.a
                                                                          )(
                                                                            this,
                                                                            "requestedSuggestSync",
                                                                            null
                                                                          ),
                                                                          Object(
                                                                            i.a
                                                                          )(
                                                                            this,
                                                                            "requestBackupTimeout",
                                                                            null
                                                                          ),
                                                                          Object(
                                                                            i.a
                                                                          )(
                                                                            this,
                                                                            "autoCloseSuccessTimeout",
                                                                            null
                                                                          ),
                                                                          Object(
                                                                            i.a
                                                                          )(
                                                                            this,
                                                                            "logger",
                                                                            void 0
                                                                          ),
                                                                          Object(
                                                                            i.a
                                                                          )(
                                                                            this,
                                                                            "config",
                                                                            void 0
                                                                          ),
                                                                          Object(
                                                                            i.a
                                                                          )(
                                                                            this,
                                                                            "setting",
                                                                            void 0
                                                                          ),
                                                                          Object(
                                                                            i.a
                                                                          )(
                                                                            this,
                                                                            "service",
                                                                            void 0
                                                                          ),
                                                                          Object(
                                                                            i.a
                                                                          )(
                                                                            this,
                                                                            "storage",
                                                                            void 0
                                                                          ),
                                                                          Object(
                                                                            i.a
                                                                          )(
                                                                            this,
                                                                            "machine",
                                                                            void 0
                                                                          ),
                                                                          Object(
                                                                            i.a
                                                                          )(
                                                                            this,
                                                                            "ui",
                                                                            void 0
                                                                          ),
                                                                          Object(
                                                                            i.a
                                                                          )(
                                                                            this,
                                                                            "helper",
                                                                            void 0
                                                                          ),
                                                                          Object(
                                                                            i.a
                                                                          )(
                                                                            this,
                                                                            "entriesTransferManager",
                                                                            void 0
                                                                          ),
                                                                          Object(
                                                                            i.a
                                                                          )(
                                                                            this,
                                                                            "metricts",
                                                                            void 0
                                                                          ),
                                                                          Object(
                                                                            i.a
                                                                          )(
                                                                            this,
                                                                            "suggestSync",
                                                                            async (
                                                                              e,
                                                                              t = !0,
                                                                              s = !1
                                                                            ) => {
                                                                              this
                                                                                .initialized
                                                                                ? (this.machine.send(
                                                                                    {
                                                                                      type: "SUGGEST_NEW_SYNC",
                                                                                      src: e,
                                                                                      shouldShowSyncGuide:
                                                                                        t,
                                                                                    }
                                                                                  ),
                                                                                  s ||
                                                                                    this.metricts.onShowSyncSuggestionWithoutResume())
                                                                                : this.logger.zsymb(
                                                                                    18,
                                                                                    11470,
                                                                                    30011,
                                                                                    "suggest sync but not ready"
                                                                                  );
                                                                            }
                                                                          ),
                                                                          Object(
                                                                            i.a
                                                                          )(
                                                                            this,
                                                                            "suggestResume",
                                                                            async () => {
                                                                              this
                                                                                .initialized
                                                                                ? this.machine.send(
                                                                                    "SUGGEST_RESUME"
                                                                                  )
                                                                                : this.logger.zsymb(
                                                                                    18,
                                                                                    11470,
                                                                                    30012,
                                                                                    "suggest resume but not ready"
                                                                                  );
                                                                            }
                                                                          ),
                                                                          Object(
                                                                            i.a
                                                                          )(
                                                                            this,
                                                                            "sync",
                                                                            async (
                                                                              e
                                                                            ) => {
                                                                              "number" ==
                                                                              typeof e
                                                                                ? this.storage.syncSource.save(
                                                                                    e
                                                                                  )
                                                                                : (e =
                                                                                    this.storage.syncSource.get() ||
                                                                                    Wn
                                                                                      .i
                                                                                      .MANUAL),
                                                                                this.metricts.setLastSyncSource(
                                                                                  e
                                                                                ),
                                                                                this.metricts.resetSyncStartTime(),
                                                                                this.logger.zsymb(
                                                                                  0,
                                                                                  11470,
                                                                                  30013,
                                                                                  "start new sync"
                                                                                ),
                                                                                e ===
                                                                                  Wn
                                                                                    .i
                                                                                    .FIRST_TIME_LOGIN &&
                                                                                  (this.setting.setMaxSeq(
                                                                                    0
                                                                                  ),
                                                                                  this.setting.setMinSeq(
                                                                                    0
                                                                                  )),
                                                                                this.machine.send(
                                                                                  "START_SYNC"
                                                                                ),
                                                                                this.setting.value()
                                                                                  .showSharedWorkerWhenSync &&
                                                                                  this.showSharedWorker();
                                                                            }
                                                                          ),
                                                                          Object(
                                                                            i.a
                                                                          )(
                                                                            this,
                                                                            "resume",
                                                                            async () => {
                                                                              this.logger.zsymb(
                                                                                0,
                                                                                11470,
                                                                                30014,
                                                                                "resume last sync"
                                                                              );
                                                                              const e =
                                                                                this.storage.backup.get();
                                                                              if (
                                                                                (this.storage.syncSource.save(
                                                                                  Wn
                                                                                    .i
                                                                                    .RESUME
                                                                                ),
                                                                                this.metricts.setLastSyncSource(
                                                                                  Wn
                                                                                    .i
                                                                                    .RESUME
                                                                                ),
                                                                                this.metricts.resetSyncStartTime(),
                                                                                e &&
                                                                                  this
                                                                                    .storage
                                                                                    .syncState
                                                                                    .isSyncing)
                                                                              ) {
                                                                                const t =
                                                                                  this.service.getBackupFolderPath(
                                                                                    e
                                                                                  );
                                                                                t !==
                                                                                  e.outputPath &&
                                                                                  ((e.outputPath =
                                                                                    t),
                                                                                  this.storage.backup.save(
                                                                                    e
                                                                                  ),
                                                                                  this.logger.zsymb(
                                                                                    0,
                                                                                    11470,
                                                                                    30015,
                                                                                    "backup output changed over the last session"
                                                                                  )),
                                                                                  this.machine.send(
                                                                                    "RESUME_SYNC"
                                                                                  );
                                                                              } else
                                                                                this.machine.send(
                                                                                  "START_SYNC"
                                                                                );
                                                                              this.setting.value()
                                                                                .showSharedWorkerWhenSync &&
                                                                                this.showSharedWorker();
                                                                            }
                                                                          ),
                                                                          Object(
                                                                            i.a
                                                                          )(
                                                                            this,
                                                                            "cancel",
                                                                            async (
                                                                              e
                                                                            ) => {
                                                                              if (
                                                                                (this.metricts.onCloseBanner(),
                                                                                this.metricts.clickCancelSync(),
                                                                                this.setting.value()
                                                                                  .dontConfirmCancel)
                                                                              )
                                                                                return (
                                                                                  this.logger.zsymb(
                                                                                    0,
                                                                                    11470,
                                                                                    30016,
                                                                                    "cancel sync"
                                                                                  ),
                                                                                  this.machine.send(
                                                                                    "CANCEL"
                                                                                  ),
                                                                                  void (await this.service.clean())
                                                                                );
                                                                              let t,
                                                                                s,
                                                                                i;
                                                                              this.logger.zsymb(
                                                                                0,
                                                                                11470,
                                                                                30017,
                                                                                "prompt cancel sync"
                                                                              ),
                                                                                e
                                                                                  ? ((t =
                                                                                      "STR_CONFIRM_SKIP_SYNC_DB_MSG_TITLE"),
                                                                                    (s =
                                                                                      "STR_CONFIRM_SKIP_SYNC_DB_MSG_TEXT"),
                                                                                    (i =
                                                                                      "STR_CONFIRM_SKIP_SYNC_DB_MSG_CONFIRM"))
                                                                                  : ((t =
                                                                                      "STR_SETTING_MSG_SYNC_POPUP_HEADER"),
                                                                                    (s =
                                                                                      "STR_SETTING_MSG_SYNC_POPUP_BODY"),
                                                                                    (i =
                                                                                      "STR_SETTING_MSG_SYNC_POPUP_OK"));
                                                                              const [
                                                                                a,
                                                                                n,
                                                                              ] =
                                                                                await this.helper.showUserConfirm(
                                                                                  {
                                                                                    header:
                                                                                      t,
                                                                                    message:
                                                                                      s,
                                                                                    confirm:
                                                                                      i,
                                                                                    cancel:
                                                                                      "STR_SETTING_MSG_SYNC_POPUP_CANCEL",
                                                                                    remember:
                                                                                      "STR_SETTING_MSG_SYNC_POPUP_DONTASK",
                                                                                    primaryButtonType:
                                                                                      "secondary-danger",
                                                                                  }
                                                                                );
                                                                              a
                                                                                ? (this.metricts.clickConfirmCancelSyncConfirmModal(),
                                                                                  this.logger.zsymb(
                                                                                    0,
                                                                                    11470,
                                                                                    30018,
                                                                                    () => [
                                                                                      "user confirm cancel sync",
                                                                                      {
                                                                                        dontAskAgain:
                                                                                          n,
                                                                                      },
                                                                                    ]
                                                                                  ),
                                                                                  n &&
                                                                                    this.setting.setDontConfirmCancel(
                                                                                      n
                                                                                    ),
                                                                                  this.machine.send(
                                                                                    "CANCEL"
                                                                                  ),
                                                                                  await this.service.clean())
                                                                                : this.metricts.clickCancelInCancelSyncConfirmModal();
                                                                            }
                                                                          ),
                                                                          Object(
                                                                            i.a
                                                                          )(
                                                                            this,
                                                                            "confirmCancelSyncInSuggestingPopup",
                                                                            async () => {
                                                                              this.metricts.clickCloseSynGuidePopup();
                                                                              (await this.helper.showUserConfirmV2(
                                                                                {
                                                                                  header:
                                                                                    "STR_CONFIRM_SYNC_DB_CONFRIM_STOP_TITLE",
                                                                                  message:
                                                                                    "STR_CONFIRM_SYNC_DB_CONFRIM_STOP_DES",
                                                                                  confirm:
                                                                                    "STR_CONFIRM_SYNC_DB_CONFRIM_STOP_BTN_OKE",
                                                                                  cancel:
                                                                                    "STR_CONFIRM_SYNC_DB_CONFRIM_STOP_BTN_CANCEL",
                                                                                  primaryButtonType:
                                                                                    "secondary-danger",
                                                                                  width: 410,
                                                                                }
                                                                              )) &&
                                                                                (this.metricts.clickConfirmCancelSyncConfirmModalFromCounterModal(),
                                                                                this.machine.send(
                                                                                  "CANCEL"
                                                                                ),
                                                                                await this.service.clean());
                                                                            }
                                                                          ),
                                                                          Object(
                                                                            i.a
                                                                          )(
                                                                            this,
                                                                            "closeCancelSyncInSuggestingPopup",
                                                                            async () => {
                                                                              this.helper.closeUserCOnfrimV2();
                                                                            }
                                                                          ),
                                                                          Object(
                                                                            i.a
                                                                          )(
                                                                            this,
                                                                            "reset",
                                                                            () => {
                                                                              this.machine.send(
                                                                                "RESET"
                                                                              ),
                                                                                this.metricts.onCloseBanner(),
                                                                                this.ui.clearError(),
                                                                                this.clearAutoCloseSuccessTimeout(),
                                                                                this.clearRequestBackupTimeout(),
                                                                                this.service.clean();
                                                                            }
                                                                          ),
                                                                          Object(
                                                                            i.a
                                                                          )(
                                                                            this,
                                                                            "pause",
                                                                            async () => {
                                                                              throw new Error(
                                                                                "Method not implemented."
                                                                              );
                                                                            }
                                                                          ),
                                                                          Object(
                                                                            i.a
                                                                          )(
                                                                            this,
                                                                            "retry",
                                                                            async () => {
                                                                              this.metricts.clickRetrySync(),
                                                                                this.logger.zsymb(
                                                                                  0,
                                                                                  11470,
                                                                                  30019,
                                                                                  "retry sync"
                                                                                ),
                                                                                this.machine.send(
                                                                                  "RETRY_SYNC"
                                                                                );
                                                                            }
                                                                          ),
                                                                          Object(
                                                                            i.a
                                                                          )(
                                                                            this,
                                                                            "showSuggestPopup",
                                                                            () => {
                                                                              this.ui.showPopup();
                                                                            }
                                                                          ),
                                                                          Object(
                                                                            i.a
                                                                          )(
                                                                            this,
                                                                            "closeSuggestPopup",
                                                                            () => {
                                                                              this.metricts.onClosePopup(),
                                                                                this.ui.hidePopup();
                                                                            }
                                                                          ),
                                                                          Object(
                                                                            i.a
                                                                          )(
                                                                            this,
                                                                            "rejectSuggest",
                                                                            async () => {
                                                                              this.metricts.onCloseBanner(),
                                                                                this.logger.zsymb(
                                                                                  0,
                                                                                  11470,
                                                                                  30020,
                                                                                  "prompt user reject suggest sync"
                                                                                );
                                                                              const [
                                                                                e,
                                                                                t,
                                                                              ] =
                                                                                await this.helper.showUserConfirm(
                                                                                  {
                                                                                    header:
                                                                                      "STR_SETTING_MSG_SYNC_POPUP_HEADER_START",
                                                                                    message:
                                                                                      "STR_SETTING_MSG_SYNC_POPUP_BODY_START",
                                                                                    confirm:
                                                                                      "STR_SETTING_MSG_SYNC_POPUP_OK_START",
                                                                                    cancel:
                                                                                      "STR_SETTING_MSG_SYNC_POPUP_CANCEL_START",
                                                                                    remember:
                                                                                      "STR_SETTING_MSG_SYNC_POPUP_DONTSHOW",
                                                                                    primaryButtonType:
                                                                                      "primary",
                                                                                  }
                                                                                );
                                                                              e
                                                                                ? (this.logger.zsymb(
                                                                                    0,
                                                                                    11470,
                                                                                    30021,
                                                                                    "user confirm reject suggest sync"
                                                                                  ),
                                                                                  t &&
                                                                                    (this.logger.zsymb(
                                                                                      0,
                                                                                      11470,
                                                                                      30022,
                                                                                      "user check dont suggest again"
                                                                                    ),
                                                                                    this.setting.setDontSuggest(
                                                                                      !0
                                                                                    )),
                                                                                  this.metricts.clickContinueInRejectSuggestionConfirmModal(),
                                                                                  this.machine.send(
                                                                                    "CLOSE_SUGGEST"
                                                                                  ),
                                                                                  this.storage.syncSource.clear())
                                                                                : (this.metricts.clickCacnelInCloseSyncSuggestionConfirmModal(),
                                                                                  this.ui.hidePopup(),
                                                                                  this.logger.zsymb(
                                                                                    0,
                                                                                    11470,
                                                                                    30023,
                                                                                    "user cancel"
                                                                                  ));
                                                                            }
                                                                          ),
                                                                          Object(
                                                                            i.a
                                                                          )(
                                                                            this,
                                                                            "hideProgress",
                                                                            async () => {
                                                                              this.setting.value()
                                                                                .hideProgress ||
                                                                                this.setting.toggleHideProgress(),
                                                                                this.helper.showUserConfirm(
                                                                                  {
                                                                                    width: 353,
                                                                                    header:
                                                                                      "STR_SETTING_MSG_SYNC_NOTICE_HEADER",
                                                                                    confirm:
                                                                                      "STR_SETTING_MSG_SYNC_NOTICE_OK",
                                                                                    primaryButtonType:
                                                                                      "neutral",
                                                                                    message:
                                                                                      Ge.a.createElement(
                                                                                        "span",
                                                                                        null,
                                                                                        Ge.a.createElement(
                                                                                          Ve.a,
                                                                                          {
                                                                                            textKey:
                                                                                              "STR_HIDE_DB_TOAST",
                                                                                            tagName:
                                                                                              "div",
                                                                                          }
                                                                                        ),
                                                                                        Ge.a.createElement(
                                                                                          "i",
                                                                                          {
                                                                                            className:
                                                                                              "fa fa-tab-setting internal-icon",
                                                                                          }
                                                                                        ),
                                                                                        Ge.a.createElement(
                                                                                          Ve.a,
                                                                                          {
                                                                                            textKey:
                                                                                              "STR_SETTING_MSG_SYNC_NOTICE_BODY_BOLD",
                                                                                            style:
                                                                                              {
                                                                                                fontWeight: 500,
                                                                                              },
                                                                                          }
                                                                                        )
                                                                                      ),
                                                                                  }
                                                                                );
                                                                            }
                                                                          ),
                                                                          Object(
                                                                            i.a
                                                                          )(
                                                                            this,
                                                                            "setRequestBackupTimeout",
                                                                            (
                                                                              e
                                                                            ) => {
                                                                              this.ui.resetStartSyncTime(),
                                                                                this.clearRequestBackupTimeout(),
                                                                                (this.requestBackupTimeout =
                                                                                  setTimeout(
                                                                                    () => {
                                                                                      this.logger.zsymb(
                                                                                        0,
                                                                                        11470,
                                                                                        30024,
                                                                                        "request backup timeout"
                                                                                      ),
                                                                                        this.machine.send(
                                                                                          "ERR_TIMEOUT"
                                                                                        );
                                                                                    },
                                                                                    this.service.getRequestBackupTimeout(
                                                                                      e
                                                                                    )
                                                                                  ));
                                                                            }
                                                                          ),
                                                                          Object(
                                                                            i.a
                                                                          )(
                                                                            this,
                                                                            "clearRequestBackupTimeout",
                                                                            () => {
                                                                              this
                                                                                .requestBackupTimeout &&
                                                                                (clearTimeout(
                                                                                  this
                                                                                    .requestBackupTimeout
                                                                                ),
                                                                                (this.requestBackupTimeout =
                                                                                  null));
                                                                            }
                                                                          ),
                                                                          Object(
                                                                            i.a
                                                                          )(
                                                                            this,
                                                                            "setAutoCloseSuccessTimeout",
                                                                            () => {
                                                                              this.autoCloseSuccessTimeout =
                                                                                setTimeout(
                                                                                  () => {
                                                                                    this.logger.zsymb(
                                                                                      0,
                                                                                      11470,
                                                                                      30025,
                                                                                      "auto close success timeout"
                                                                                    ),
                                                                                      this.machine.send(
                                                                                        "AUTO_CLOSE"
                                                                                      );
                                                                                  },
                                                                                  1e4
                                                                                );
                                                                            }
                                                                          ),
                                                                          Object(
                                                                            i.a
                                                                          )(
                                                                            this,
                                                                            "clearAutoCloseSuccessTimeout",
                                                                            () => {
                                                                              this
                                                                                .autoCloseSuccessTimeout &&
                                                                                (clearTimeout(
                                                                                  this
                                                                                    .autoCloseSuccessTimeout
                                                                                ),
                                                                                (this.autoCloseSuccessTimeout =
                                                                                  null));
                                                                            }
                                                                          ),
                                                                          Object(
                                                                            i.a
                                                                          )(
                                                                            this,
                                                                            "resendRequest",
                                                                            async () =>
                                                                              this.service.request(
                                                                                0,
                                                                                1
                                                                              )
                                                                          ),
                                                                          Object(
                                                                            i.a
                                                                          )(
                                                                            this,
                                                                            "handleCtrlEvents",
                                                                            (
                                                                              e
                                                                            ) => {
                                                                              const t =
                                                                                this
                                                                                  .service
                                                                                  .session;
                                                                              if (
                                                                                !t
                                                                              )
                                                                                return (
                                                                                  this.logger.zsymb(
                                                                                    18,
                                                                                    11470,
                                                                                    30026,
                                                                                    "received control event but no session"
                                                                                  ),
                                                                                  void this.metricts.onReqBackupFailure(
                                                                                    Wn
                                                                                      .f
                                                                                      .SELF_DEFINE,
                                                                                    Wn
                                                                                      .g
                                                                                      .NO_SESSION
                                                                                  )
                                                                                );
                                                                              for (const a of e) {
                                                                                if (
                                                                                  hr.a.isUserConfirm(
                                                                                    t,
                                                                                    a
                                                                                  )
                                                                                )
                                                                                  return void this.machine.send(
                                                                                    {
                                                                                      type: "USER_CONFIRM",
                                                                                    }
                                                                                  );
                                                                                if (
                                                                                  hr.a.isUserReject(
                                                                                    t,
                                                                                    a
                                                                                  )
                                                                                )
                                                                                  return void this.machine.send(
                                                                                    {
                                                                                      type: "USER_REJECT",
                                                                                    }
                                                                                  );
                                                                                if (
                                                                                  hr.a.isBackupSuccess(
                                                                                    t,
                                                                                    a
                                                                                  )
                                                                                ) {
                                                                                  var s;
                                                                                  let e;
                                                                                  try {
                                                                                    e =
                                                                                      JSON.parse(
                                                                                        a
                                                                                          .data
                                                                                          .db_info
                                                                                      );
                                                                                  } catch (i) {
                                                                                    return (
                                                                                      this.logger.zsymb(
                                                                                        18,
                                                                                        11470,
                                                                                        30027,
                                                                                        () => [
                                                                                          "parse db info fail",
                                                                                          {
                                                                                            error:
                                                                                              i.message,
                                                                                          },
                                                                                        ]
                                                                                      ),
                                                                                      this.metricts.onReqBackupFailure(
                                                                                        Wn
                                                                                          .f
                                                                                          .SELF_DEFINE,
                                                                                        Wn
                                                                                          .g
                                                                                          .CANT_PASE_DB_INFO
                                                                                      ),
                                                                                      void this.machine.send(
                                                                                        "ERR_INVALID_BACKUP"
                                                                                      )
                                                                                    );
                                                                                  }
                                                                                  let t = 0,
                                                                                    n = 0;
                                                                                  try {
                                                                                    e.backup_db &&
                                                                                      ((t =
                                                                                        e
                                                                                          .backup_db
                                                                                          .msg_thread),
                                                                                      (n =
                                                                                        e
                                                                                          .backup_db
                                                                                          .msg_total)),
                                                                                      e.origin_db &&
                                                                                        ((t =
                                                                                          e
                                                                                            .origin_db
                                                                                            .msg_thread),
                                                                                        (n =
                                                                                          e
                                                                                            .origin_db
                                                                                            .msg_total));
                                                                                  } catch (i) {
                                                                                    return (
                                                                                      this.logger.zsymb(
                                                                                        18,
                                                                                        11470,
                                                                                        30028,
                                                                                        () => [
                                                                                          "parse db info fail",
                                                                                          {
                                                                                            error:
                                                                                              i.message,
                                                                                          },
                                                                                        ]
                                                                                      ),
                                                                                      this.metricts.onReqBackupFailure(
                                                                                        Wn
                                                                                          .f
                                                                                          .SELF_DEFINE,
                                                                                        Wn
                                                                                          .g
                                                                                          .CANT_PASE_DB_INFO
                                                                                      ),
                                                                                      void this.machine.send(
                                                                                        "ERR_INVALID_BACKUP"
                                                                                      )
                                                                                    );
                                                                                  }
                                                                                  const r =
                                                                                    null !=
                                                                                    (s =
                                                                                      e.db_format)
                                                                                      ? s
                                                                                      : 0;
                                                                                  this.metricts.onReqBackupSuccess(
                                                                                    r
                                                                                  );
                                                                                  const o =
                                                                                    this.storage.syncSource.get();
                                                                                  this.metricts.setLastSyncSource(
                                                                                    o
                                                                                  ),
                                                                                    this.storage.backup.save(
                                                                                      {
                                                                                        rawUid:
                                                                                          a
                                                                                            .data
                                                                                            .uid,
                                                                                        userId:
                                                                                          this
                                                                                            .currentUserId,
                                                                                        uin: this
                                                                                          .currentUserUIN,
                                                                                        fromSeqId:
                                                                                          a
                                                                                            .data
                                                                                            .from_seq_id,
                                                                                        isFull:
                                                                                          !!a
                                                                                            .data
                                                                                            .is_full_transfer,
                                                                                        name: a
                                                                                          .data
                                                                                          .file_name,
                                                                                        url: a
                                                                                          .data
                                                                                          .url,
                                                                                        checksum:
                                                                                          a
                                                                                            .data
                                                                                            .checksum_code ||
                                                                                          a
                                                                                            .data
                                                                                            .checksum ||
                                                                                          "",
                                                                                        publicKey:
                                                                                          a
                                                                                            .data
                                                                                            .public_key,
                                                                                        encryptedKey:
                                                                                          a
                                                                                            .data
                                                                                            .encrypted_key,
                                                                                        privateKey:
                                                                                          "",
                                                                                        format:
                                                                                          r,
                                                                                        inputPath:
                                                                                          "",
                                                                                        outputPath:
                                                                                          "",
                                                                                        numberOfConversationsCount:
                                                                                          t,
                                                                                        numberOfMessagesCount:
                                                                                          n,
                                                                                        conversations:
                                                                                          [],
                                                                                      }
                                                                                    );
                                                                                  const c =
                                                                                    this.setting.value();
                                                                                  return (
                                                                                    this.storage.syncState.resetCheckpoint(
                                                                                      r,
                                                                                      c.minSeq,
                                                                                      c.maxSeq
                                                                                    ),
                                                                                    this.logger.zsymb(
                                                                                      0,
                                                                                      11470,
                                                                                      30029,
                                                                                      () => [
                                                                                        "received backup",
                                                                                        {
                                                                                          format:
                                                                                            r,
                                                                                          msgCount:
                                                                                            n,
                                                                                          threadCount:
                                                                                            t,
                                                                                        },
                                                                                      ]
                                                                                    ),
                                                                                    void this.machine.send(
                                                                                      "SUCCESS"
                                                                                    )
                                                                                  );
                                                                                }
                                                                                if (
                                                                                  hr.a.isBackupFail(
                                                                                    t,
                                                                                    a
                                                                                  )
                                                                                )
                                                                                  return void this.machine.send(
                                                                                    "ERR_BACKUP_FAIL"
                                                                                  );
                                                                                if (
                                                                                  hr.a.isMobileRestoring(
                                                                                    t,
                                                                                    a
                                                                                  )
                                                                                )
                                                                                  return void this.machine.send(
                                                                                    "ERR_BUSY_RESTORING"
                                                                                  );
                                                                                Zt.default.increaseFailed(
                                                                                  Wn
                                                                                    .e
                                                                                    .REQ_BACKUP,
                                                                                  0,
                                                                                  0,
                                                                                  Wn
                                                                                    .g
                                                                                    .UNKNOWN_EVENT,
                                                                                  Date.now()
                                                                                ),
                                                                                  this.logger.zsymb(
                                                                                    18,
                                                                                    11470,
                                                                                    30030,
                                                                                    () => [
                                                                                      "unknown control event",
                                                                                      {
                                                                                        event:
                                                                                          a,
                                                                                      },
                                                                                    ]
                                                                                  );
                                                                              }
                                                                            }
                                                                          ),
                                                                          (this.machine =
                                                                            a.ModuleContainer.resolveToken(
                                                                              Lr
                                                                            )),
                                                                          (this.logger =
                                                                            t.createZLogger(
                                                                              "msg-sync",
                                                                              [
                                                                                "controller",
                                                                              ]
                                                                            )),
                                                                          (this.config =
                                                                            e),
                                                                          (this.service =
                                                                            n),
                                                                          (this.setting =
                                                                            s),
                                                                          (this.storage =
                                                                            o),
                                                                          (this.ui =
                                                                            r),
                                                                          (this.helper =
                                                                            c),
                                                                          (this.metricts =
                                                                            l),
                                                                          (this.entriesTransferManager =
                                                                            d);
                                                                      }
                                                                      isEnable() {
                                                                        const e =
                                                                            this.config.get(
                                                                              "cross_setting.offFeature"
                                                                            ),
                                                                          t =
                                                                            this.config.get(
                                                                              "cross_setting.enable"
                                                                            );
                                                                        return (
                                                                          !e &&
                                                                          t
                                                                        );
                                                                      }
                                                                      isEnableBySrc(
                                                                        e
                                                                      ) {
                                                                        if (
                                                                          (this.metricts.onCheckSyncSuggestion(
                                                                            e
                                                                          ),
                                                                          !this.isEnable())
                                                                        )
                                                                          return !1;
                                                                        switch (
                                                                          e
                                                                        ) {
                                                                          case Wn
                                                                            .i
                                                                            .FIRST_TIME_LOGIN:
                                                                            return this.config.get(
                                                                              "cross_setting.enableFirstTimeUse"
                                                                            );
                                                                          case Wn
                                                                            .i
                                                                            .MANUAL:
                                                                            return this.config.get(
                                                                              "cross_setting.enableManual"
                                                                            );
                                                                          case Wn
                                                                            .i
                                                                            .OVERFLOW:
                                                                            return this.config.get(
                                                                              "cross_setting.enableOverQueue"
                                                                            );
                                                                          case Wn
                                                                            .i
                                                                            .E2EE_MISSING_MESSAGE:
                                                                            return this.config.get(
                                                                              "notify_missing_e2ee_message.enable"
                                                                            );
                                                                        }
                                                                        return !0;
                                                                      }
                                                                      isEnableResume() {
                                                                        return (
                                                                          !!this.isEnable() &&
                                                                          this.config.get(
                                                                            "cross_setting.enableResume"
                                                                          )
                                                                        );
                                                                      }
                                                                      canSync(
                                                                        e
                                                                      ) {
                                                                        return this.isEnableBySrc(
                                                                          e
                                                                        )
                                                                          ? this.machine.canStartNewSync()
                                                                            ? Wn
                                                                                .a
                                                                                .OK
                                                                            : Wn
                                                                                .a
                                                                                .INVALID_STATE
                                                                          : Wn.a
                                                                              .DISABLED;
                                                                      }
                                                                      onStart() {
                                                                        if (
                                                                          this.isEnable()
                                                                        ) {
                                                                          this.logger.zsymb(
                                                                            0,
                                                                            11470,
                                                                            30001,
                                                                            "initialize"
                                                                          );
                                                                          try {
                                                                            this.machine.create(),
                                                                              this.machine.start();
                                                                          } catch (e) {
                                                                            return void this.logger.zsymb(
                                                                              18,
                                                                              11470,
                                                                              30002,
                                                                              () => [
                                                                                "start error",
                                                                                {
                                                                                  error:
                                                                                    e,
                                                                                },
                                                                              ]
                                                                            );
                                                                          }
                                                                          _.default.subscribe(
                                                                            (
                                                                              e,
                                                                              t
                                                                            ) => {
                                                                              if (
                                                                                e ===
                                                                                y
                                                                                  .FetchActions
                                                                                  .CHECK_OVERFLOW_QUEUE_BY_FLAG
                                                                              ) {
                                                                                const e =
                                                                                  t.queueId;
                                                                                if (
                                                                                  !e
                                                                                )
                                                                                  return;
                                                                                if (
                                                                                  (this.metricts.receiveOverqueueMsgSignal(),
                                                                                  this.setting.value()
                                                                                    .dontSuggest)
                                                                                )
                                                                                  return void this.logger.zsymb(
                                                                                    3,
                                                                                    11470,
                                                                                    30003,
                                                                                    "queue is full, but user has already disable sync suggestion"
                                                                                  );
                                                                                if (
                                                                                  !this.isEnableBySrc(
                                                                                    Wn
                                                                                      .i
                                                                                      .OVERFLOW
                                                                                  )
                                                                                )
                                                                                  return void this.logger.zsymb(
                                                                                    0,
                                                                                    11470,
                                                                                    30004,
                                                                                    "sync when overflow is not enable"
                                                                                  );
                                                                                const s =
                                                                                    this.config.get(
                                                                                      "cross_setting.timeBetweenSync"
                                                                                    ) ||
                                                                                    0,
                                                                                  i =
                                                                                    this.setting.value()
                                                                                      .lastSync;
                                                                                if (
                                                                                  s >
                                                                                    0 &&
                                                                                  i >
                                                                                    0
                                                                                ) {
                                                                                  const e =
                                                                                    i +
                                                                                    60 *
                                                                                      s *
                                                                                      1e3;
                                                                                  if (
                                                                                    e >
                                                                                    Date.now()
                                                                                  )
                                                                                    return void this.logger.zsymb(
                                                                                      0,
                                                                                      11470,
                                                                                      30005,
                                                                                      `queue is full, but user has already sync in time. next sync: ${new Date(
                                                                                        e
                                                                                      ).toLocaleString()}`
                                                                                    );
                                                                                }
                                                                                const a =
                                                                                  this.config.get(
                                                                                    "msg_sync.overflow_queue"
                                                                                  );
                                                                                if (
                                                                                  a
                                                                                ) {
                                                                                  if (
                                                                                    a.some(
                                                                                      (
                                                                                        t
                                                                                      ) =>
                                                                                        e ==
                                                                                        t
                                                                                    )
                                                                                  )
                                                                                    return void this.suggestSync(
                                                                                      Wn
                                                                                        .i
                                                                                        .OVERFLOW,
                                                                                      !1
                                                                                    );
                                                                                } else
                                                                                  this.logger.zsymb(
                                                                                    0,
                                                                                    11470,
                                                                                    30006,
                                                                                    "queue evict is not set"
                                                                                  );
                                                                              }
                                                                            }
                                                                          ),
                                                                            this.entriesTransferManager.addEventListener(
                                                                              Dr
                                                                                .a
                                                                                .NotifyE2eeConvChangeDevice,
                                                                              (
                                                                                e
                                                                              ) => {
                                                                                if (
                                                                                  e.type ===
                                                                                  Dr
                                                                                    .a
                                                                                    .NotifyE2eeConvChangeDevice
                                                                                ) {
                                                                                  if (
                                                                                    this.setting.value()
                                                                                      .dontSuggest
                                                                                  )
                                                                                    return void this.logger.zsymb(
                                                                                      3,
                                                                                      11470,
                                                                                      30007,
                                                                                      "Change device and has e2ee convs, but user has already disable sync suggestion"
                                                                                    );
                                                                                  if (
                                                                                    !this.isEnableBySrc(
                                                                                      Wn
                                                                                        .i
                                                                                        .E2EE_MISSING_MESSAGE
                                                                                    )
                                                                                  )
                                                                                    return void this.logger.zsymb(
                                                                                      0,
                                                                                      11470,
                                                                                      30008,
                                                                                      "Sync when change device and has e2ee convs is not enable"
                                                                                    );
                                                                                  const e =
                                                                                      this.config.get(
                                                                                        "cross_setting.timeBetweenSync"
                                                                                      ) ||
                                                                                      0,
                                                                                    t =
                                                                                      this.setting.value()
                                                                                        .lastSync;
                                                                                  if (
                                                                                    e >
                                                                                      0 &&
                                                                                    t >
                                                                                      0
                                                                                  ) {
                                                                                    const s =
                                                                                      t +
                                                                                      60 *
                                                                                        e *
                                                                                        1e3;
                                                                                    if (
                                                                                      s >
                                                                                      Date.now()
                                                                                    )
                                                                                      return void this.logger.zsymb(
                                                                                        0,
                                                                                        11470,
                                                                                        30009,
                                                                                        `Change device and has e2ee convs, but user has already sync in time. next sync: ${new Date(
                                                                                          s
                                                                                        ).toLocaleString()}`
                                                                                      );
                                                                                  }
                                                                                  this.entriesTransferManager.getSyncSource() ===
                                                                                    Wn
                                                                                      .i
                                                                                      .E2EE_MISSING_MESSAGE &&
                                                                                    (this.logger.zsymb(
                                                                                      0,
                                                                                      11470,
                                                                                      30010,
                                                                                      "Suggest sync by [NotifyE2eeConvChangeDevice] event"
                                                                                    ),
                                                                                    this.suggestSync(
                                                                                      Wn
                                                                                        .i
                                                                                        .E2EE_MISSING_MESSAGE,
                                                                                      !1
                                                                                    ));
                                                                                }
                                                                              }
                                                                            ),
                                                                            (this.initialized =
                                                                              !0),
                                                                            "" !==
                                                                              this
                                                                                .currentUserId &&
                                                                              setTimeout(
                                                                                this.checkSuggestWhenReady.bind(
                                                                                  this
                                                                                ),
                                                                                1e3
                                                                              );
                                                                        } else
                                                                          this.logger.zsymb(
                                                                            0,
                                                                            11470,
                                                                            3e4,
                                                                            "feature is not enable"
                                                                          );
                                                                      }
                                                                      onAuthenticated(
                                                                        e
                                                                      ) {
                                                                        this.storage.load(
                                                                          e.getSession()
                                                                            .userId
                                                                        ),
                                                                          this.setting.load(
                                                                            e.getSession()
                                                                              .userId
                                                                          ),
                                                                          (this.currentUserId =
                                                                            e.getSession().userId),
                                                                          (this.currentUserUIN =
                                                                            e.getSession()
                                                                              .UIN ||
                                                                            ""),
                                                                          setTimeout(
                                                                            () => {
                                                                              qt.a.triggerIndex();
                                                                            },
                                                                            5e3
                                                                          ),
                                                                          this
                                                                            .initialized &&
                                                                            setTimeout(
                                                                              this.checkSuggestWhenReady.bind(
                                                                                this
                                                                              ),
                                                                              1e3
                                                                            );
                                                                      }
                                                                      onDispose() {
                                                                        this.service.abortRestore(),
                                                                          this
                                                                            .machine
                                                                            .status ===
                                                                            or
                                                                              .InterpreterStatus
                                                                              .Running &&
                                                                            this.machine.stop();
                                                                      }
                                                                      onSyncSuccess() {
                                                                        this.dispatchEvent(
                                                                          new hr.c()
                                                                        );
                                                                      }
                                                                      async restartSync() {
                                                                        this.metricts.resetSyncStartTime(),
                                                                          this.machine.send(
                                                                            "RESTART_SYNC"
                                                                          );
                                                                      }
                                                                      currentSyncSource() {
                                                                        return this.storage.syncSource.get();
                                                                      }
                                                                      getCurrentSyncScreenState() {
                                                                        return this.ui.getCurrentScreen();
                                                                      }
                                                                      async checkSuggestWhenReady() {
                                                                        this.logger.zsymb(
                                                                          0,
                                                                          11470,
                                                                          30031,
                                                                          "checking for sync suggestion"
                                                                        ),
                                                                          this.setting.value()
                                                                            .dontSuggest
                                                                            ? this.logger.zsymb(
                                                                                0,
                                                                                11470,
                                                                                30032,
                                                                                "user don't want to suggest sync"
                                                                              )
                                                                            : (await this.checkForSuggestFirstLogin().catch(
                                                                                (
                                                                                  e
                                                                                ) => (
                                                                                  this.logger.zsymb(
                                                                                    18,
                                                                                    11470,
                                                                                    30033,
                                                                                    () => [
                                                                                      "checkForSuggestFirstLogin failed",
                                                                                      e,
                                                                                    ]
                                                                                  ),
                                                                                  !1
                                                                                )
                                                                              )) ||
                                                                              (await this.checkLastStateForSuggestResumeOrNewSync().catch(
                                                                                (
                                                                                  e
                                                                                ) => (
                                                                                  this.logger.zsymb(
                                                                                    18,
                                                                                    11470,
                                                                                    30034,
                                                                                    () => [
                                                                                      "checkLastStateForSuggestResumeOrNewSync failed",
                                                                                      e,
                                                                                    ]
                                                                                  ),
                                                                                  !1
                                                                                )
                                                                              )) ||
                                                                              (await this.checkPendingRequestSync().catch(
                                                                                (
                                                                                  e
                                                                                ) => (
                                                                                  this.logger.zsymb(
                                                                                    18,
                                                                                    11470,
                                                                                    30035,
                                                                                    () => [
                                                                                      "checkPendingRequestSync failed",
                                                                                      e,
                                                                                    ]
                                                                                  ),
                                                                                  !1
                                                                                )
                                                                              )) ||
                                                                              (await this.checkStateForSuggestSyncFromOtherEntries().catch(
                                                                                (
                                                                                  e
                                                                                ) => (
                                                                                  this.logger.zsymb(
                                                                                    18,
                                                                                    11470,
                                                                                    30036,
                                                                                    () => [
                                                                                      "checkStateForSuggestSyncFromOtherEntries failed",
                                                                                      e,
                                                                                    ]
                                                                                  ),
                                                                                  !1
                                                                                )
                                                                              )) ||
                                                                              this.logger.zsymb(
                                                                                3,
                                                                                11470,
                                                                                30037,
                                                                                "no sync suggestion"
                                                                              );
                                                                      }
                                                                      async checkForSuggestFirstLogin() {
                                                                        const e =
                                                                          r.a.getInstance();
                                                                        let t =
                                                                          e.getItem(
                                                                            "z_needSyncMsg"
                                                                          );
                                                                        if (
                                                                          t &&
                                                                          JSON.parse(
                                                                            t
                                                                          )
                                                                        ) {
                                                                          if (
                                                                            (e.removeItem(
                                                                              "z_needSyncMsg"
                                                                            ),
                                                                            this.isEnableBySrc(
                                                                              Wn
                                                                                .i
                                                                                .FIRST_TIME_LOGIN
                                                                            ) &&
                                                                              !Fr.i
                                                                                .GetManager()
                                                                                .isEnabledFeature())
                                                                          )
                                                                            return (
                                                                              this.suggestSync(
                                                                                Wn
                                                                                  .i
                                                                                  .FIRST_TIME_LOGIN
                                                                              ),
                                                                              !0
                                                                            );
                                                                          this.logger.zsymb(
                                                                            0,
                                                                            11470,
                                                                            30038,
                                                                            "first login sync is disabled"
                                                                          );
                                                                        }
                                                                        return !1;
                                                                      }
                                                                      showSharedWorker() {
                                                                        ir.ipcRenderer.send(
                                                                          "show-shared-worker"
                                                                        );
                                                                      }
                                                                      async checkPendingRequestSync() {
                                                                        if (
                                                                          !this
                                                                            .initialized
                                                                        )
                                                                          return (
                                                                            this.logger.zsymb(
                                                                              18,
                                                                              11470,
                                                                              30039,
                                                                              "check pending request sync but not ready"
                                                                            ),
                                                                            !1
                                                                          );
                                                                        if (
                                                                          this
                                                                            .requestedSuggestSync
                                                                        ) {
                                                                          const e =
                                                                            this
                                                                              .requestedSuggestSync;
                                                                          if (
                                                                            ((this.requestedSuggestSync =
                                                                              null),
                                                                            this.isEnableBySrc(
                                                                              e
                                                                            ))
                                                                          )
                                                                            return (
                                                                              this.suggestSync(
                                                                                e
                                                                              ),
                                                                              !0
                                                                            );
                                                                          this.logger.zsymb(
                                                                            0,
                                                                            11470,
                                                                            30040,
                                                                            `${e} sync is disabled`
                                                                          );
                                                                        }
                                                                        return !1;
                                                                      }
                                                                      async checkLastStateForSuggestResumeOrNewSync() {
                                                                        if (
                                                                          this
                                                                            .storage
                                                                            .syncState
                                                                            .isStarted
                                                                        )
                                                                          return (
                                                                            this.isEnableResume()
                                                                              ? this.suggestResume()
                                                                              : (this.logger.zsymb(
                                                                                  0,
                                                                                  11470,
                                                                                  30041,
                                                                                  "resume sync is disabled"
                                                                                ),
                                                                                this.storage.clear()),
                                                                            !0
                                                                          );
                                                                        const e =
                                                                          this.storage.syncSource.get();
                                                                        return (
                                                                          "number" ==
                                                                            typeof e &&
                                                                          ((this.requestedSuggestSync =
                                                                            null),
                                                                          this.isEnableBySrc(
                                                                            e
                                                                          )
                                                                            ? this.suggestSync(
                                                                                e,
                                                                                !1,
                                                                                !0
                                                                              )
                                                                            : (this.logger.zsymb(
                                                                                0,
                                                                                11470,
                                                                                30042,
                                                                                `${e} sync is disabled`
                                                                              ),
                                                                              this.storage.clear()),
                                                                          !0)
                                                                        );
                                                                      }
                                                                      async checkStateForSuggestSyncFromOtherEntries() {
                                                                        if (
                                                                          this
                                                                            .storage
                                                                            .syncState
                                                                            .isStarted
                                                                        )
                                                                          return (
                                                                            this.isEnableResume()
                                                                              ? this.suggestResume()
                                                                              : (this.logger.zsymb(
                                                                                  0,
                                                                                  11470,
                                                                                  30043,
                                                                                  "resume sync is disabled"
                                                                                ),
                                                                                this.storage.clear()),
                                                                            !0
                                                                          );
                                                                        const e =
                                                                          this.entriesTransferManager.getSyncSource();
                                                                        return (
                                                                          "number" ==
                                                                            typeof e &&
                                                                          ((this.requestedSuggestSync =
                                                                            null),
                                                                          this.isEnableBySrc(
                                                                            e
                                                                          )
                                                                            ? (this.logger.zsymb(
                                                                                0,
                                                                                11470,
                                                                                30044,
                                                                                "Suggest sync with cached entry transfer before"
                                                                              ),
                                                                              this.suggestSync(
                                                                                e,
                                                                                !1
                                                                              ))
                                                                            : (this.logger.zsymb(
                                                                                0,
                                                                                11470,
                                                                                30045,
                                                                                `${e} sync is disabled`
                                                                              ),
                                                                              this.storage.clear()),
                                                                          !0)
                                                                        );
                                                                      }
                                                                    })
                                                                  ) || Mr)
                                                              ) || Mr)
                                                          ) || Mr)
                                                      ) || Mr)
                                                  ) || Mr)
                                              ) || Mr)
                                          ) || Mr)
                                      ) || Mr)
                                  ) || Mr)
                              ) || Mr)
                          ) || Mr)
                      ) || Mr)
                  ) || Mr)
              ) || Mr)
          ) || Mr)
      );
      var jr = s("JprO"),
        Ar = s("3jnX"),
        Nr = s("nhJq");
      class Pr {
        constructor(e, t, s) {
          Object(i.a)(this, "hostName", void 0),
            Object(i.a)(this, "key", void 0),
            Object(i.a)(this, "keyDecryptor", void 0),
            (this.hostName = e),
            (this.key = t),
            (this.keyDecryptor = s);
        }
        get publicKey() {
          return this.key.publicKey;
        }
        isSame(e) {
          return this.hostName === e.hostName && this.key === e.key;
        }
        decryptKey(e, t) {
          return this.keyDecryptor(e, t, this.key);
        }
        static create(e, t) {
          return new Pr(e, t.generate(), t.decryptKey.bind(t));
        }
      }
      class kr extends Ar.b {
        constructor(e) {
          super({ type: "DECRYPT_BACKUP", params: e });
        }
      }
      class Ur extends Ar.b {
        constructor(e, t) {
          super({ type: "RESTORE_MESSAGES", params: e, checkpoint: t }),
            Object(i.a)(this, "handleEventBusMessage", (e, t) => {
              if ("SELECT_CONVERSATION" === e) {
                const e = t.userId;
                this.params.meta.viewingConversation !== e &&
                  this.changeParams({
                    meta: Object(p.a)(
                      Object(p.a)({}, this.params.meta),
                      {},
                      { viewingConversation: e }
                    ),
                  });
              }
            });
        }
        run() {
          return (
            this.startListenEventBus(),
            this.addEventListenerOnce(Ar.c.Finalized, () => {
              this.stopListenEventBus();
            }),
            super.run()
          );
        }
        startListenEventBus() {
          this.stopListenEventBus(),
            _.default.subscribe(this.handleEventBusMessage);
        }
        stopListenEventBus() {
          _.default.unsubscribe(this.handleEventBusMessage);
        }
      }
      class Br extends Ar.b {
        constructor(e) {
          super({ type: "RESTORE_CONVERSATIONS", params: e });
        }
      }
      var Gr,
        zr = s("qUG6"),
        xr = s("6Sr9"),
        Vr = s("1erv");
      const qr = window.electronAPI.getPath("userData"),
        Hr = z.a.join(qr, "blob");
      Object(a.injectable)()(
        (Gr =
          Object(a.singleton)(rr)(
            (Gr =
              Object(xr.e)()(
                (Gr =
                  Object(xr.d)()(
                    (Gr =
                      (function (e, t) {
                        return Object(a.inject)(gr)(e, void 0, 0);
                      })(
                        (Gr =
                          (function (e, t) {
                            return Object(a.inject)(dr.a)(e, void 0, 1);
                          })(
                            (Gr =
                              (function (e, t) {
                                return Object(a.inject)(_r.b)(e, void 0, 2);
                              })(
                                (Gr =
                                  (function (e, t) {
                                    return Object(a.inject)(er)(e, void 0, 3);
                                  })(
                                    (Gr =
                                      (function (e, t) {
                                        return Object(a.inject)(
                                          O.ZLoggerFactory
                                        )(e, void 0, 4);
                                      })(
                                        (Gr =
                                          (function (e, t) {
                                            return Object(a.inject)(Sr)(
                                              e,
                                              void 0,
                                              5
                                            );
                                          })(
                                            (Gr =
                                              Reflect.metadata(
                                                "design:type",
                                                Function
                                              )(
                                                (Gr =
                                                  Reflect.metadata(
                                                    "design:paramtypes",
                                                    [
                                                      void 0 === gr
                                                        ? Object
                                                        : gr,
                                                      void 0 === dr.a
                                                        ? Object
                                                        : dr.a,
                                                      void 0 === _r.b
                                                        ? Object
                                                        : _r.b,
                                                      void 0 === er
                                                        ? Object
                                                        : er,
                                                      void 0 ===
                                                      O.ZLoggerFactory
                                                        ? Object
                                                        : O.ZLoggerFactory,
                                                      void 0 === Sr
                                                        ? Object
                                                        : Sr,
                                                    ]
                                                  )(
                                                    (Gr = class {
                                                      constructor(
                                                        e,
                                                        t,
                                                        a,
                                                        n,
                                                        r,
                                                        o
                                                      ) {
                                                        Object(i.a)(
                                                          this,
                                                          "session",
                                                          void 0
                                                        ),
                                                          Object(i.a)(
                                                            this,
                                                            "hostName",
                                                            void 0
                                                          ),
                                                          Object(i.a)(
                                                            this,
                                                            "keyGenerator",
                                                            void 0
                                                          ),
                                                          Object(i.a)(
                                                            this,
                                                            "storage",
                                                            void 0
                                                          ),
                                                          Object(i.a)(
                                                            this,
                                                            "setting",
                                                            void 0
                                                          ),
                                                          Object(i.a)(
                                                            this,
                                                            "ui",
                                                            void 0
                                                          ),
                                                          Object(i.a)(
                                                            this,
                                                            "logger",
                                                            void 0
                                                          ),
                                                          Object(i.a)(
                                                            this,
                                                            "_currentTask",
                                                            null
                                                          ),
                                                          Object(i.a)(
                                                            this,
                                                            "metricts",
                                                            void 0
                                                          ),
                                                          (this.logger =
                                                            r.createZLogger(
                                                              "msg-sync",
                                                              ["service"]
                                                            )),
                                                          (this.storage = e),
                                                          (this.setting = t),
                                                          (this.ui = a),
                                                          (this.keyGenerator =
                                                            n),
                                                          (this.hostName =
                                                            s(
                                                              "jle/"
                                                            ).hostname()),
                                                          (this.session = null),
                                                          (this.metricts = o);
                                                      }
                                                      get currentSession() {
                                                        return (
                                                          this.session ||
                                                            (this.session =
                                                              this.newSession()),
                                                          this.session
                                                        );
                                                      }
                                                      onSessionExpired() {
                                                        this.logger.zsymb(
                                                          0,
                                                          11469,
                                                          3e4,
                                                          "onSessionExpired"
                                                        ),
                                                          this.cleanUrgent();
                                                      }
                                                      onDispose() {
                                                        this.logger.zsymb(
                                                          0,
                                                          11469,
                                                          30001,
                                                          "onDispose"
                                                        ),
                                                          Mt.g.isRememberMe() ||
                                                            this.cleanUrgent();
                                                      }
                                                      async prepareNewSync() {
                                                        const e = Date.now();
                                                        await this.abortRestore();
                                                        const t = Date.now();
                                                        this.logger.zsymb(
                                                          0,
                                                          11469,
                                                          30002,
                                                          `[prepareNewSync] -> [abortRestore] execute in ${new Date(
                                                            t - e
                                                          ).getSeconds()}`
                                                        );
                                                        const s = Date.now();
                                                        await this.cleanupTempFiles();
                                                        const i = Date.now();
                                                        this.logger.zsymb(
                                                          0,
                                                          11469,
                                                          30003,
                                                          `[prepareNewSync] -> [cleanupTempFiles] execute in ${new Date(
                                                            i - s
                                                          ).getSeconds()}`
                                                        ),
                                                          (this.session = null),
                                                          this.storage.syncState.reset();
                                                        const a =
                                                          this.setting.value();
                                                        this.storage.syncState.resetCheckpoint(
                                                          0,
                                                          a.minSeq,
                                                          a.maxSeq
                                                        );
                                                        const n = Date.now();
                                                        this.logger.zsymb(
                                                          0,
                                                          11469,
                                                          30004,
                                                          `[prepareNewSync] execute in ${new Date(
                                                            n - e
                                                          ).getSeconds()}`
                                                        );
                                                      }
                                                      request(e = 0, t = 0) {
                                                        const s =
                                                            this.currentSession
                                                              .publicKey,
                                                          i =
                                                            this.setting.value(),
                                                          a = i.maxSeq,
                                                          n = i.minSeq,
                                                          r = ya.a.newReq();
                                                        return (
                                                          this.logger.zsymb(
                                                            0,
                                                            11469,
                                                            30006,
                                                            () => [
                                                              "sent request backup",
                                                              {
                                                                id: r,
                                                                max: a,
                                                                min: n,
                                                                retry: e,
                                                                resend: t,
                                                                key: s,
                                                              },
                                                            ]
                                                          ),
                                                          an.default
                                                            .pullMobileMsg(
                                                              s,
                                                              a,
                                                              r,
                                                              t,
                                                              n
                                                            )
                                                            .then(tn.a)
                                                            .catch((s) => {
                                                              throw (
                                                                (this.logger.zsymb(
                                                                  0,
                                                                  11469,
                                                                  30007,
                                                                  () => [
                                                                    "failed to send request backup",
                                                                    {
                                                                      id: r,
                                                                      max: a,
                                                                      min: n,
                                                                      retry: e,
                                                                      resend: t,
                                                                      error: s,
                                                                    },
                                                                  ]
                                                                ),
                                                                e > 0 &&
                                                                  (this.session =
                                                                    null),
                                                                s)
                                                              );
                                                            })
                                                        );
                                                      }
                                                      async clean() {
                                                        this.logger.zsymb(
                                                          0,
                                                          11469,
                                                          30008,
                                                          "abort current task"
                                                        ),
                                                          await this.abortRestore(),
                                                          this.logger.zsymb(
                                                            0,
                                                            11469,
                                                            30009,
                                                            "clean storage"
                                                          ),
                                                          await this.cleanupTempFiles(),
                                                          this.storage.clear(),
                                                          this.logger.zsymb(
                                                            0,
                                                            11469,
                                                            30010,
                                                            "clean session"
                                                          ),
                                                          (this.session = null),
                                                          this.logger.zsymb(
                                                            0,
                                                            11469,
                                                            30011,
                                                            "cleanup done"
                                                          );
                                                      }
                                                      async download(e = 0) {
                                                        this.logger.zsymb(
                                                          0,
                                                          11469,
                                                          30012,
                                                          () => [
                                                            "downloading backup",
                                                            { retry: e },
                                                          ]
                                                        );
                                                        const t =
                                                          this.storage.backup.get();
                                                        if (!t)
                                                          return (
                                                            this.metricts.onDownloadBackupFailure(
                                                              Wn.f.SELF_DEFINE,
                                                              Wn.b
                                                                .BACKUP_NOT_FOUND
                                                            ),
                                                            Promise.reject(
                                                              "No backup found"
                                                            )
                                                          );
                                                        const s = (e, t) => {
                                                          t.progress > 0 &&
                                                            this.ui.setProgress(
                                                              t.progress
                                                            );
                                                        };
                                                        ir.ipcRenderer.on(
                                                          "UPDATE_CHANNEL_CROSS_DB",
                                                          s
                                                        ),
                                                          await jr.a.run({
                                                            type: jr.a.constants
                                                              .DownloadType
                                                              .File,
                                                            data: {
                                                              fileName: t.name,
                                                              url: t.url,
                                                              checksum:
                                                                t.checksum,
                                                            },
                                                            options: {
                                                              saveDir: Hr,
                                                              caching: !0,
                                                              duplicate: !1,
                                                              srcAction:
                                                                jr.a.constants
                                                                  .srcAction
                                                                  .Dev,
                                                              showProgress: {
                                                                taskBar: !1,
                                                                progressBar: !0,
                                                                progressChannel:
                                                                  "UPDATE_CHANNEL_CROSS_DB",
                                                                progressChannelId:
                                                                  t.checksum,
                                                              },
                                                              noiseDownload: !1,
                                                              timeOut: 1e4,
                                                              cookies: !0,
                                                            },
                                                          }),
                                                          ir.ipcRenderer.removeListener(
                                                            "UPDATE_CHANNEL_CROSS_DB",
                                                            s
                                                          ),
                                                          this.ui.setProgress(
                                                            100
                                                          );
                                                        const i = z.a.join(
                                                          Hr,
                                                          t.name
                                                        );
                                                        (t.inputPath = i),
                                                          this.storage.backup.save(
                                                            t
                                                          );
                                                      }
                                                      async decrypt() {
                                                        const e =
                                                          this.storage.backup.get();
                                                        if (!e)
                                                          return Promise.reject(
                                                            "no backup found"
                                                          );
                                                        if (
                                                          0 ===
                                                          e.numberOfMessagesCount
                                                        )
                                                          return;
                                                        const t = e.format
                                                            ? "hex"
                                                            : "base64",
                                                          s = e.encryptedKey,
                                                          i =
                                                            this.currentSession.decryptKey(
                                                              s,
                                                              t
                                                            ),
                                                          a =
                                                            this.getBackupFolderPath(
                                                              e
                                                            );
                                                        (e.outputPath = a),
                                                          (e.privateKey = i),
                                                          this.storage.backup.save(
                                                            e
                                                          );
                                                        const n = new kr({
                                                          inputPath:
                                                            e.inputPath,
                                                          outputPath:
                                                            e.outputPath,
                                                          privateKey:
                                                            e.privateKey,
                                                          format:
                                                            1 === e.format
                                                              ? 1
                                                              : 0,
                                                          numberOfConversationsCount:
                                                            e.numberOfConversationsCount,
                                                        });
                                                        (this._currentTask = n),
                                                          await n.run();
                                                      }
                                                      async restore(e) {
                                                        this.logger.zsymb(
                                                          0,
                                                          11469,
                                                          30014,
                                                          () => [
                                                            "restoring backup",
                                                            { retry: e },
                                                          ]
                                                        );
                                                        const t =
                                                          this.storage.backup.get();
                                                        if (
                                                          !t ||
                                                          0 ===
                                                            t.numberOfMessagesCount
                                                        )
                                                          return void this.ui.setNumOfSyncedConv(
                                                            0
                                                          );
                                                        const s =
                                                          this.storage.syncState
                                                            .step;
                                                        if (
                                                          (s <=
                                                            ur.RESTORE_CONVERSATIONS &&
                                                            ((this.storage.syncState.isSyncing =
                                                              !0),
                                                            await this._restoreConversations().catch(
                                                              (e) => {
                                                                throw (
                                                                  (this.logger.zsymb(
                                                                    18,
                                                                    11469,
                                                                    30015,
                                                                    () => [
                                                                      "restore conversations failed",
                                                                      {
                                                                        error:
                                                                          e,
                                                                      },
                                                                    ]
                                                                  ),
                                                                  this.metricts.onRestoreDataFailure(
                                                                    Wn.h
                                                                      .RESTORE_CONV_ERR
                                                                  ),
                                                                  e)
                                                                );
                                                              }
                                                            ),
                                                            this.storage.syncState.nextStep()),
                                                          s <=
                                                            ur.RESTORE_MESSAGES &&
                                                            (await this.restoreMessages().catch(
                                                              (e) => {
                                                                throw (
                                                                  (this.logger.zsymb(
                                                                    18,
                                                                    11469,
                                                                    30016,
                                                                    () => [
                                                                      "restore messages failed",
                                                                      {
                                                                        error:
                                                                          e,
                                                                      },
                                                                    ]
                                                                  ),
                                                                  this.metricts.onRestoreDataFailure(
                                                                    Wn.h
                                                                      .RESTORE_MSGS_ERR
                                                                  ),
                                                                  e)
                                                                );
                                                              }
                                                            ),
                                                            this.storage.syncState.nextStep()),
                                                          s <=
                                                            ur.UPDATE_MESSAGES_CACHE)
                                                        )
                                                          return (
                                                            this.setting.setLastSync(
                                                              Date.now()
                                                            ),
                                                            this.metricts.onRestoreDataSuccess(),
                                                            void this.metricts.onSyncSuccess(
                                                              t.format,
                                                              this.storage
                                                                .syncState
                                                                .checkpoint
                                                                .importedMessages,
                                                              t.numberOfMessagesCount
                                                            )
                                                          );
                                                        throw new Error(
                                                          "unknown step"
                                                        );
                                                      }
                                                      getBackupFolderPath(e) {
                                                        const t =
                                                          window.electronAPI.getPath(
                                                            "userData"
                                                          );
                                                        return z.a.join(
                                                          t,
                                                          "blob",
                                                          e.name + "_tmp"
                                                        );
                                                      }
                                                      async restoreMessages() {
                                                        this.logger.zsymb(
                                                          0,
                                                          11469,
                                                          30017,
                                                          "restore messages"
                                                        );
                                                        const e =
                                                            this.storage.backup.get(),
                                                          t =
                                                            a.ModuleContainer.resolve(
                                                              Ct.SidebarController
                                                            ),
                                                          s = new Ur(
                                                            {
                                                              backupPath:
                                                                e.outputPath,
                                                              plainUserId:
                                                                e.rawUid,
                                                              noiseUserId:
                                                                e.userId,
                                                              password: e.uin,
                                                              format: e.format,
                                                              conversations:
                                                                e.conversations,
                                                              meta: {
                                                                queueIndexSearch: false,
                                                                viewingConversation:
                                                                  t.getSelectedId(),
                                                                cachedRanges:
                                                                  {},
                                                                numberOfMessages:
                                                                  e.numberOfMessagesCount,
                                                                numberOfConversations:
                                                                  e.numberOfConversationsCount,
                                                              },
                                                            },
                                                            this.storage.syncState.checkpoint
                                                          );
                                                        return (
                                                          s.addEventListener(
                                                            Ar.c.Progress,
                                                            (e) => {
                                                              e.progress > 0 &&
                                                                this.ui.setProgress(
                                                                  e.progress
                                                                );
                                                              const t =
                                                                e.checkpoint;
                                                              t &&
                                                                (this.storage.syncState.checkpoint =
                                                                  t);
                                                            }
                                                          ),
                                                          s.addEventListenerOnce(
                                                            Ar.c.Completed,
                                                            () => {
                                                              if (0 == e.format)
                                                                this.ui.setNumOfSyncedConv(
                                                                  e.numberOfConversationsCount
                                                                );
                                                              else {
                                                                const t =
                                                                    e.numberOfConversationsCount,
                                                                  s =
                                                                    this.storage
                                                                      .syncState
                                                                      .checkpoint
                                                                      .updatedConversation;
                                                                this.ui.setNumOfSyncedConv(
                                                                  s
                                                                ),
                                                                  this.logger.zsymb(
                                                                    0,
                                                                    11469,
                                                                    30018,
                                                                    "completed sync",
                                                                    s,
                                                                    t
                                                                  );
                                                              }
                                                              this.setting.setMinSeq(
                                                                this.storage
                                                                  .syncState
                                                                  .checkpoint
                                                                  .minSeq
                                                              ),
                                                                this.setting.setMaxSeq(
                                                                  this.storage
                                                                    .syncState
                                                                    .checkpoint
                                                                    .maxSeq
                                                                );
                                                            }
                                                          ),
                                                          (this._currentTask =
                                                            s),
                                                          s.run()
                                                        );
                                                      }
                                                      async _restoreConversations() {
                                                        this.logger.zsymb(
                                                          0,
                                                          11469,
                                                          30019,
                                                          "restore conversations"
                                                        );
                                                        let e =
                                                          this.storage.backup.get();
                                                        const t = new Br({
                                                          backupPath:
                                                            e.outputPath,
                                                          format: e.format,
                                                          plainUserId: e.rawUid,
                                                          noiseUserId: e.userId,
                                                          password: e.uin,
                                                          shouldUseNewMediaDBFlowConfig:
                                                            Object(Vr.a)(),
                                                        });
                                                        this._currentTask = t;
                                                        const s = await t.run(),
                                                          i = (
                                                            await this._validateConversations(
                                                              s
                                                            )
                                                          ).filter(
                                                            (e) =>
                                                              !e.shouldIgnore
                                                          ),
                                                          a = i.filter(
                                                            (e) => !e.isExist
                                                          ),
                                                          n = i.filter(
                                                            (e) =>
                                                              !!e.lastMessage
                                                          );
                                                        if (
                                                          (a.length > 0 &&
                                                            (await this._createNewImportConversations(
                                                              a
                                                            ).catch((e) => {
                                                              this.logger.zsymb(
                                                                18,
                                                                11469,
                                                                30020,
                                                                () => [
                                                                  "create new import conversations failed. but continue",
                                                                  { error: e },
                                                                ]
                                                              );
                                                            })),
                                                          n.length > 0)
                                                        ) {
                                                          const e = n.map(
                                                            (e) => e.lastMessage
                                                          );
                                                          this._updatePreviewOfConversations(
                                                            e
                                                          );
                                                        }
                                                        e =
                                                          this.storage.backup.save(
                                                            Object(p.a)(
                                                              Object(p.a)(
                                                                {},
                                                                e
                                                              ),
                                                              {},
                                                              {
                                                                conversations:
                                                                  i.map(
                                                                    (e) => ({
                                                                      plainId:
                                                                        e.plainId,
                                                                      noiseId:
                                                                        e.noiseId,
                                                                      isGroup:
                                                                        e.isGroup,
                                                                      hasPreviewMsg:
                                                                        !!e.lastMessage,
                                                                      shouldIgnore:
                                                                        e.shouldIgnore,
                                                                    })
                                                                  ),
                                                              }
                                                            )
                                                          );
                                                        const r =
                                                          this.storage.syncState
                                                            .checkpoint;
                                                        if (1 === r.format) {
                                                          const e = Object(p.a)(
                                                            {},
                                                            r
                                                          );
                                                          let t = i
                                                            .filter(
                                                              (e) =>
                                                                !!e.lastMessage
                                                            )
                                                            .sort(
                                                              (e, t) =>
                                                                t.lastMessage
                                                                  .localDttm -
                                                                e.lastMessage
                                                                  .localDttm
                                                            )
                                                            .map(
                                                              (e) => e.plainId
                                                            );
                                                          (t = t.concat(
                                                            i
                                                              .filter(
                                                                (e) =>
                                                                  !e.lastMessage
                                                              )
                                                              .map(
                                                                (e) => e.plainId
                                                              )
                                                          )),
                                                            (e.priorities = t),
                                                            (e.currentSeq = {}),
                                                            (this.storage.syncState.checkpoint =
                                                              e);
                                                        }
                                                      }
                                                      _updatePreviewOfConversations(
                                                        e
                                                      ) {
                                                        new zr.a(e).run();
                                                      }
                                                      async _createNewImportConversations(
                                                        e
                                                      ) {
                                                        const t =
                                                          a.ModuleContainer.resolve(
                                                            me.b
                                                          );
                                                        await Promise.all(
                                                          e.map((e) => {
                                                            var s, i;
                                                            t.addIfNotExistsConv(
                                                              e.noiseId,
                                                              e.isGroup,
                                                              null ===
                                                                (s =
                                                                  e.lastMessage) ||
                                                                void 0 === s
                                                                ? void 0
                                                                : s.msgId,
                                                              null ===
                                                                (i =
                                                                  e.lastMessage) ||
                                                                void 0 === i
                                                                ? void 0
                                                                : i.msgId,
                                                              Pt.b.isMyMessage(
                                                                e.lastMessage
                                                              ),
                                                              1
                                                            );
                                                          })
                                                        );
                                                      }
                                                      async _validateConversations(
                                                        e
                                                      ) {
                                                        const t = [],
                                                          s = [];
                                                        for (const o of e)
                                                          o.isGroup
                                                            ? s.push(o.noisedId)
                                                            : t.push(
                                                                o.noisedId
                                                              );
                                                        const [i, a] =
                                                            await Promise.all([
                                                              D.default
                                                                .getProfileFriendByIds(
                                                                  t
                                                                )
                                                                .catch(
                                                                  (e) => (
                                                                    this.logger.zsymb(
                                                                      18,
                                                                      11469,
                                                                      30022,
                                                                      () => [
                                                                        "validate friend error",
                                                                        {
                                                                          error:
                                                                            e,
                                                                        },
                                                                      ]
                                                                    ),
                                                                    {}
                                                                  )
                                                                ),
                                                              ne.default
                                                                .getGroupsByIds(
                                                                  s
                                                                )
                                                                .catch(
                                                                  (e) => (
                                                                    this.logger.zsymb(
                                                                      18,
                                                                      11469,
                                                                      30023,
                                                                      () => [
                                                                        "validate group error",
                                                                        {
                                                                          error:
                                                                            e,
                                                                        },
                                                                      ]
                                                                    ),
                                                                    {}
                                                                  )
                                                                ),
                                                            ]),
                                                          n = e.map((e) => ({
                                                            plainId: e.plainId,
                                                            noiseId: e.noisedId,
                                                            isExist:
                                                              !!N.a.ConvInfoDataManager.getConvByIdSync(
                                                                e.noisedId
                                                              ),
                                                            isGroup: e.isGroup,
                                                            hasPreview:
                                                              !!e.lastMessage,
                                                            lastMessage:
                                                              e.lastMessage,
                                                            shouldIgnore:
                                                              !i[e.noisedId] &&
                                                              !a[e.noisedId],
                                                          })),
                                                          r = n.filter(
                                                            (e) =>
                                                              !e.shouldIgnore
                                                          ).length;
                                                        return (
                                                          this.logger.zsymb(
                                                            0,
                                                            11469,
                                                            30024,
                                                            () => [
                                                              "validate conversations done",
                                                              {
                                                                total: e.length,
                                                                valid: r,
                                                              },
                                                            ]
                                                          ),
                                                          n
                                                        );
                                                      }
                                                      cleanUrgent() {
                                                        this.abortRestore(),
                                                          this.logger.zsymb(
                                                            0,
                                                            11469,
                                                            30025,
                                                            "abort restore"
                                                          ),
                                                          this.storage.clear(),
                                                          this.logger.zsymb(
                                                            0,
                                                            11469,
                                                            30026,
                                                            "clean storage"
                                                          ),
                                                          (this.session = null),
                                                          this.logger.zsymb(
                                                            0,
                                                            11469,
                                                            30027,
                                                            "clean session"
                                                          ),
                                                          ir.ipcRenderer.send(
                                                            "sync-msg-abort",
                                                            {
                                                              reason:
                                                                "session-expired",
                                                              path: Hr,
                                                            }
                                                          );
                                                      }
                                                      async abortRestore() {
                                                        this._currentTask &&
                                                          (await this._currentTask.abort()),
                                                          (this._currentTask =
                                                            null);
                                                      }
                                                      getRequestBackupTimeout(
                                                        e
                                                      ) {
                                                        if (e)
                                                          return (
                                                            1e3 *
                                                            I.default
                                                              .cross_setting
                                                              .waitDbTimeout
                                                          );
                                                        const t =
                                                          1e3 *
                                                          I.default
                                                            .cross_setting
                                                            .cfTimeout;
                                                        return Math.max(
                                                          0,
                                                          t -
                                                            (Date.now() -
                                                              this.ui.getStartSyncTime())
                                                        );
                                                      }
                                                      async cleanupTempFiles() {
                                                        this.logger.zsymb(
                                                          0,
                                                          11469,
                                                          30028,
                                                          "remove temp files"
                                                        ),
                                                          await Nr.b(Hr).catch(
                                                            (e) => {
                                                              this.logger.zsymb(
                                                                18,
                                                                11469,
                                                                30029,
                                                                () => [
                                                                  "remove temp failed",
                                                                  { err: e },
                                                                ]
                                                              );
                                                            }
                                                          );
                                                      }
                                                      newSession() {
                                                        return Pr.create(
                                                          this.hostName,
                                                          this.keyGenerator
                                                        );
                                                      }
                                                      getHardcodeError(e) {
                                                        return 0;
                                                      }
                                                    })
                                                  ) || Gr)
                                              ) || Gr)
                                          ) || Gr)
                                      ) || Gr)
                                  ) || Gr)
                              ) || Gr)
                          ) || Gr)
                      ) || Gr)
                  ) || Gr)
              ) || Gr)
          ) || Gr)
      );
      var Kr, $r;
      const Wr = new Map();
      Object(j.h)()(
        (Kr =
          Object(a.injectable)()(
            (Kr =
              (function (e, t) {
                return Object(a.inject)(O.ZLoggerFactory)(e, void 0, 0);
              })(
                (Kr =
                  Reflect.metadata(
                    "design:type",
                    Function
                  )(
                    (Kr =
                      Reflect.metadata("design:paramtypes", [
                        void 0 === O.ZLoggerFactory ? Object : O.ZLoggerFactory,
                      ])(
                        (Kr = class extends Ar.a {
                          constructor(e) {
                            super(),
                              Object(i.a)(this, "logger", void 0),
                              (this.logger = e.createZLogger("sync-message", [
                                "noise-id-handler",
                              ]));
                          }
                          async execute({ params: e }) {
                            const t = e.uids.length + e.gids.length;
                            return 0 === t
                              ? []
                              : t > 1e4
                              ? Promise.all([
                                  this.getNoiseIdFromServer(e.uids, []),
                                  this.getNoiseIdFromServer([], e.gids),
                                ]).then(([e, t]) => [...e, ...t])
                              : this.getNoiseIdFromServer(e.uids, e.gids);
                          }
                          async getNoiseIdFromServer(e, t) {
                            let s = e.map((e) => Number.parseInt(e)),
                              i = t.map((e) => Number.parseInt(e));
                            const a = await an.default
                              .getnuid(s, i)
                              .then(tn.a)
                              .catch((s) => {
                                this.logger.zsymb(18, 9912, 30001, () => [
                                  "get noise id from server error",
                                  s,
                                ]);
                                const i = s.code || s.error_code;
                                if (
                                  i === w.NetWorkError.NO_NETWORK ||
                                  -69 === i
                                )
                                  throw (
                                    (Zt.default.increaseFailed(
                                      Wn.e.REQ_NOISE_ID,
                                      0,
                                      0,
                                      Wn.d.NO_NET_OR_TOO_MUCH_REQ,
                                      Date.now()
                                    ),
                                    s)
                                  );
                                return (
                                  this.logger.zsymb(0, 9912, 30002, () => [
                                    "return empty result for ids:",
                                    { uids: e, gids: t },
                                  ]),
                                  Zt.default.increaseFailed(
                                    Wn.e.REQ_NOISE_ID,
                                    0,
                                    0,
                                    s.error_code,
                                    Date.now()
                                  ),
                                  { fids: [], gids: [] }
                                );
                              });
                            if (s.length > 0 && s.length !== a.fids.length)
                              throw (
                                (this.logger.zsymb(
                                  18,
                                  9912,
                                  30003,
                                  `data mismatch: uids: ${s.length}, fids: ${a.fids.length}`
                                ),
                                Zt.default.increaseFailed(
                                  Wn.e.REQ_NOISE_ID,
                                  0,
                                  0,
                                  Wn.d.U_MIS_MATCH,
                                  Date.now()
                                ),
                                new Error("data mismatch reason:uids"))
                              );
                            if (i.length > 0 && i.length !== a.gids.length)
                              throw (
                                (this.logger.zsymb(
                                  18,
                                  9912,
                                  30004,
                                  `data mismatch: gids: ${i.length}, gids: ${a.gids.length}`
                                ),
                                Zt.default.increaseFailed(
                                  Wn.e.REQ_NOISE_ID,
                                  0,
                                  0,
                                  Wn.d.G_MIS_MATCH,
                                  Date.now()
                                ),
                                new Error("data mismatch reason:gids"))
                              );
                            let n = [];
                            return (
                              a.gids &&
                                a.gids.forEach((e, s) => {
                                  (e = e.startsWith("g") ? e : `g${e}`),
                                    n.push([t[s], e]),
                                    Wr.set(t[s], e);
                                }),
                              a.fids &&
                                a.fids.forEach((t, s) => {
                                  const i = `g${t}`;
                                  ne.default.getGroupByIdSync(i)
                                    ? (n.push([e[s], i]), Wr.set(e[s], i))
                                    : (n.push([e[s], t]), Wr.set(e[s], t));
                                }),
                              n
                            );
                          }
                          getType() {
                            return "REQUEST_NOISE_ID";
                          }
                          getHardcodeError(e) {
                            return 0;
                          }
                        })
                      ) || Kr)
                  ) || Kr)
              ) || Kr)
          ) || Kr)
      ),
        Object(j.h)()(
          ($r =
            Object(a.injectable)()(
              ($r = class extends Ar.a {
                async execute() {
                  return Array.from(Wr.entries());
                }
                getType() {
                  return "REQUEST_ALL_NOISE_ID";
                }
              })
            ) || $r)
        );
      var Zr;
      Object(j.h)()(
        (Zr =
          Object(a.injectable)()(
            (Zr = class extends Ar.a {
              async execute({ params: e }) {
                const t = a.ModuleContainer.resolve(me.h);
                await t.onReceiveNewMessages("sync-db", e);
              }
              getType() {
                return "UPDATE_CONVERSATION_PREVIEW";
              }
            })
          ) || Zr)
      );
      var Qr,
        Yr = s("xdZB");
      Object(j.h)()(
        (Qr =
          Object(a.injectable)()(
            (Qr =
              (function (e, t) {
                return Object(a.inject)(O.ZLoggerFactory)(e, void 0, 0);
              })(
                (Qr =
                  Reflect.metadata(
                    "design:type",
                    Function
                  )(
                    (Qr =
                      Reflect.metadata("design:paramtypes", [
                        void 0 === O.ZLoggerFactory ? Object : O.ZLoggerFactory,
                      ])(
                        (Qr = class extends Ar.a {
                          constructor(e) {
                            super(),
                              Object(i.a)(this, "logger", void 0),
                              (this.logger = e.createZLogger("feat", [
                                "sync-message",
                                "reload-msg-handler",
                              ]));
                          }
                          async execute({ params: e }) {
                            if (!Ca.b.messageCache) return;
                            Ca.b.messageCache.deleteConversation(e.convId);
                            Yr.a.getExistConvIds().includes(e.convId) &&
                              Yt.a.getLastMessagesForConversation(e.convId, {});
                          }
                          getType() {
                            return "RELOAD_MESSAGE";
                          }
                        })
                      ) || Qr)
                  ) || Qr)
              ) || Qr)
          ) || Qr)
      );
      var Jr,
        Xr = s("1KLq"),
        eo = s("nuPU");
      Object(j.h)()(
        (Jr =
          Object(a.injectable)()(
            (Jr =
              (function (e, t) {
                return Object(a.inject)(Xr.b)(e, void 0, 0);
              })(
                (Jr =
                  Reflect.metadata(
                    "design:type",
                    Function
                  )(
                    (Jr =
                      Reflect.metadata("design:paramtypes", [
                        void 0 === Xr.IMediaEventEmitter
                          ? Object
                          : Xr.IMediaEventEmitter,
                      ])(
                        (Jr = class extends Ar.a {
                          constructor(e) {
                            super(),
                              Object(i.a)(this, "_mediaEventEmitter", void 0),
                              (this._mediaEventEmitter = e);
                          }
                          async execute({ params: e }) {
                            this._mediaEventEmitter.emit(
                              eo.a.RELOAD_MEDIA_OF_CONV,
                              e
                            );
                          }
                          getType() {
                            return "RELOAD_MEDIA";
                          }
                        })
                      ) || Jr)
                  ) || Jr)
              ) || Jr)
          ) || Jr)
      );
      var to = s("Erqw");
      const { setTimeoutUnlimited: so, clearTimeoutUnlimited: io } = (function (
        e = {}
      ) {
        var t, s;
        const i = null != (t = e.step) && t ? 1e4 : 36e5,
          a = null != (s = e.registry) ? s : {};
        return {
          setTimeoutUnlimited: (e, t, ...s) => {
            const n = ((e) => {
              var t;
              const s = e.step,
                i = e.registry;
              let a = null != (t = e.timeout) ? t : 0;
              const n = e.callback,
                r = e.args,
                o = performance.now() + a;
              let c;
              function l() {
                let e = Math.min(o - performance.now(), s);
                return (
                  performance.now() > o
                    ? (i[c] = setTimeout(n, 0, r))
                    : (i[c] = setTimeout(l, e)),
                  i[c]
                );
              }
              return (function () {
                let e = Math.min(o - performance.now(), s);
                return (c = setTimeout(l, e)), (i[c] = c), c;
              })();
            })({ step: i, registry: a, callback: e, timeout: t, args: s });
            return n;
          },
          clearTimeoutUnlimited: (e) => {
            ((e) => {
              const t = e.id,
                s = e.registry;
              clearTimeout(s[t]), delete s[t];
            })({ id: e, registry: a });
          },
        };
      })({ registry: {} });
      var ao,
        no = s("1p+n"),
        ro = s("UYft"),
        oo = s("AULX");
      Object(a.injectable)()(
        (ao =
          Object(a.singleton)(oo.a)(
            (ao =
              Object(j.g)()(
                (ao =
                  Object(j.e)()(
                    (ao =
                      (function (e, t) {
                        return Object(a.inject)(c)(e, void 0, 0);
                      })(
                        (ao =
                          (function (e, t) {
                            return Object(a.inject)(O.ZLoggerFactory)(
                              e,
                              void 0,
                              1
                            );
                          })(
                            (ao =
                              Reflect.metadata(
                                "design:type",
                                Function
                              )(
                                (ao =
                                  Reflect.metadata("design:paramtypes", [
                                    void 0 === o ? Object : o,
                                    void 0 === O.ZLoggerFactory
                                      ? Object
                                      : O.ZLoggerFactory,
                                  ])(
                                    (ao = class {
                                      constructor(e, t) {
                                        (this.kvCacheFactory = e),
                                          (this.loggerFactory = t),
                                          Object(i.a)(this, "_logger", void 0),
                                          Object(i.a)(
                                            this,
                                            "_authEvent",
                                            void 0
                                          ),
                                          Object(i.a)(this, "__cache", void 0),
                                          Object(i.a)(
                                            this,
                                            "_renewRegistry",
                                            {}
                                          ),
                                          Object(i.a)(
                                            this,
                                            "updateEmitter",
                                            new no.a()
                                          ),
                                          (this._logger =
                                            this.loggerFactory.createZLogger(
                                              "feat",
                                              ["group-link"]
                                            ));
                                      }
                                      onAuthenticated(e) {
                                        this._authEvent = e;
                                      }
                                      _makeCache() {
                                        if (!this._authEvent)
                                          throw new Error("Not authenticated");
                                        return this.kvCacheFactory.createCache(
                                          `group-link-v3-${
                                            this._authEvent.getSession().userId
                                          }`,
                                          { maxSize: 50 }
                                        );
                                      }
                                      get _cache() {
                                        return (
                                          this.__cache ||
                                            (this.__cache = this._makeCache()),
                                          this.__cache
                                        );
                                      }
                                      _scheduleRenew(e, t) {
                                        if (
                                          (this._clearRenewSchedule(e),
                                          !t.enabled)
                                        )
                                          return this;
                                        if (
                                          !I.default.groupLink
                                            .enableScheduleRenew
                                        )
                                          return (
                                            this._logger.debug([
                                              "_scheduleRenew skipped, enableScheduleRenew:",
                                              I.default.groupLink
                                                .enableScheduleRenew,
                                            ]),
                                            this
                                          );
                                        let s =
                                            t.expirationDate - Y.a.getTimeNow(),
                                          i = so(() => {
                                            this._clearRenewSchedule(e),
                                              this._emitGroupLinkUpdated(e, !0);
                                          }, s);
                                        return (
                                          (this._renewRegistry[e] = () => {
                                            io(i),
                                              delete this._renewRegistry[e];
                                          }),
                                          this
                                        );
                                      }
                                      _clearRenewSchedule(e) {
                                        var t, s;
                                        return (
                                          null ===
                                            (t = (s = this._renewRegistry)[
                                              e
                                            ]) ||
                                            void 0 === t ||
                                            t.call(s),
                                          this
                                        );
                                      }
                                      onDispose() {
                                        (this._authEvent = void 0),
                                          (this.__cache = void 0);
                                      }
                                      async _getFromCache(e) {
                                        if (!I.default.groupLink.enableCache)
                                          return void this._logger.debug([
                                            "cache skipped, enableCache:",
                                            I.default.groupLink.enableCache,
                                          ]);
                                        e = co(e);
                                        let t = await this._cache.getItem(e);
                                        if (t) {
                                          if (
                                            (function (e) {
                                              if (!e) return !1;
                                              let { data: t, meta: s } = e;
                                              if (!t) return !1;
                                              if (!s) return !1;
                                              if (to.a.isOverflowAtTime(s.ts))
                                                return !1;
                                              const i = Y.a.getTimeNow();
                                              if (
                                                s.ts +
                                                  I.default.groupLink
                                                    .maxCacheDuration <
                                                i
                                              )
                                                return !1;
                                              if (
                                                t.enabled &&
                                                t.expirationDate < i
                                              )
                                                return !1;
                                              return !0;
                                            })(t)
                                          )
                                            return t.data;
                                          await this._cache.removeItem(e);
                                        }
                                      }
                                      async _fetchAndPutToCache(e, t) {
                                        const s = Y.a.getTimeNow(),
                                          i = await t(),
                                          a = {
                                            enabled: i.enabled,
                                            expirationDate: i.expiration_date,
                                            link: i.link,
                                          };
                                        let n = { ts: s };
                                        return (
                                          await this._cache.setItem(e, {
                                            data: a,
                                            meta: n,
                                          }),
                                          a
                                        );
                                      }
                                      async _deleteCache(e) {
                                        await this._cache.removeItem(e);
                                      }
                                      async getGroupLinkDetail(e, t = !1) {
                                        this._logger.zsymb(12, 9830, 3e4, [
                                          "getting",
                                          e,
                                        ]);
                                        let s = co(e),
                                          i = await this._getFromCache(s);
                                        if (i && !t)
                                          return (
                                            this._logger.zsymb(
                                              12,
                                              9830,
                                              30001,
                                              ["cache hit", s]
                                            ),
                                            this._scheduleRenew(s, i),
                                            i
                                          );
                                        this._logger.zsymb(12, 9830, 30002, [
                                          "fetching",
                                          s,
                                        ]);
                                        let a = b.default.getRawGroupId(s);
                                        let n = await this._fetchAndPutToCache(
                                          s,
                                          () => is.default.getGroupLinkDetail(a)
                                        ).catch(
                                          ro.a.catch((e) =>
                                            this._logger.zsymb(
                                              18,
                                              9830,
                                              30003,
                                              ["get failed", s, e]
                                            )
                                          )
                                        );
                                        return (
                                          this._scheduleRenew(s, n),
                                          t &&
                                            (await this._emitGroupLinkUpdated(
                                              e
                                            )),
                                          this._logger.zsymb(12, 9830, 30004, [
                                            "done",
                                            s,
                                          ]),
                                          n
                                        );
                                      }
                                      async renewGroupLink(e) {
                                        this._logger.zsymb(12, 9830, 30005, [
                                          "renewing",
                                          e,
                                        ]);
                                        let t = co(e),
                                          s = b.default.getRawGroupId(t);
                                        let i = await this._fetchAndPutToCache(
                                          t,
                                          () => is.default.renewGroupLink(s)
                                        ).catch(
                                          ro.a.catch((e) =>
                                            this._logger.zsymb(
                                              18,
                                              9830,
                                              30006,
                                              ["renew failed", t, e]
                                            )
                                          )
                                        );
                                        return (
                                          this._scheduleRenew(t, i),
                                          await this._emitGroupLinkUpdated(t),
                                          this._logger.zsymb(12, 9830, 30007, [
                                            "renew done",
                                            e,
                                          ]),
                                          i
                                        );
                                      }
                                      async disableGroupLink(e) {
                                        this._logger.zsymb(12, 9830, 30008, [
                                          "disabling",
                                          e,
                                        ]);
                                        let t = co(e),
                                          s = b.default.getRawGroupId(t);
                                        await is.default
                                          .disableGroupLink(s)
                                          .catch(
                                            ro.a.catch((e) =>
                                              this._logger.zsymb(
                                                18,
                                                9830,
                                                30009,
                                                ["disable failed", t, e]
                                              )
                                            )
                                          ),
                                          await this._emitGroupLinkUpdated(
                                            t,
                                            !0
                                          ),
                                          this._logger.zsymb(12, 9830, 30010, [
                                            "disable done",
                                            e,
                                          ]);
                                      }
                                      async _emitGroupLinkUpdated(e, t = !1) {
                                        const s = co(e);
                                        t && (await this._deleteCache(s)),
                                          this.updateEmitter.emit(s, s),
                                          this.updateEmitter.emit("*", s);
                                      }
                                      async emitGroupLinkUpdated(e) {
                                        return await this._emitGroupLinkUpdated(
                                          e,
                                          !0
                                        );
                                      }
                                    })
                                  ) || ao)
                              ) || ao)
                          ) || ao)
                      ) || ao)
                  ) || ao)
              ) || ao)
          ) || ao)
      );
      function co(e) {
        return w.GROUPID_PREFIX + b.default.getRawGroupId(e);
      }
      var lo,
        ho = s("TO4U");
      const uo = { loading: !0 };
      Object(B.b)(ho.a)(
        (lo =
          (function (e, t) {
            return Object(a.inject)(oo.a)(e, void 0, 0);
          })(
            (lo =
              Reflect.metadata(
                "design:type",
                Function
              )(
                (lo =
                  Reflect.metadata("design:paramtypes", [
                    void 0 === oo.a ? Object : oo.a,
                  ])(
                    (lo = class e {
                      constructor(e) {
                        (this._groupLink = e),
                          Object(i.a)(this, "type", void 0),
                          Object(i.a)(this, "name", "group-link-ui"),
                          Object(i.a)(this, "key", "group-link-ui"),
                          Object(i.a)(
                            this,
                            "_cache",
                            new u.default({ maxSize: 50 })
                          ),
                          Object(i.a)(this, "_handleUpdate", (e) => {
                            const t = go(e);
                            this._cache.delete(t),
                              this._startFetchAndSetToSession(t);
                          }),
                          this._groupLink.updateEmitter.on(
                            "*",
                            this._handleUpdate
                          );
                      }
                      init() {}
                      getItem(e, t) {
                        if (!e.key.startsWith(w.GROUPID_PREFIX)) return;
                        const s = go(e.key);
                        this._startFetchAndSetToSession(s);
                        let i = this._cache.get(s);
                        return i || uo;
                      }
                      static shouldSignal(e, t) {
                        var s, i, a, n, r, o;
                        return (
                          !e ||
                          (null == e || e.error,
                          null == t || t.error,
                          null == t ||
                            null === (s = t.data) ||
                            void 0 === s ||
                            s.enabled,
                          null == t ||
                            null === (i = t.data) ||
                            void 0 === i ||
                            i.enabled,
                          null != e &&
                            null !== (a = e.data) &&
                            void 0 !== a &&
                            a.enabled &&
                            null != t &&
                            null !== (n = t.data) &&
                            void 0 !== n &&
                            n.enabled &&
                            (null == e ||
                              null === (r = e.data) ||
                              void 0 === r ||
                              r.link,
                            null == t ||
                              null === (o = t.data) ||
                              void 0 === o ||
                              o.link),
                          !1)
                        );
                      }
                      signalIfNeeded(t, s, i) {
                        e.shouldSignal(s, i) && Object(yt.g)(this.name, t);
                      }
                      _startFetchAndSetToSession(e) {
                        const t = this._cache.get(e);
                        setTimeout(() => {
                          this._groupLink
                            .getGroupLinkDetail(e)
                            .then((s) => {
                              const i = { loading: !1, data: s };
                              this._cache.set(e, i),
                                this.signalIfNeeded(e, t, i);
                            })
                            .catch((s) => {
                              const i = { loading: !1, error: s };
                              this._cache.set(e, i),
                                this.signalIfNeeded(e, t, i);
                            });
                        }, 0);
                      }
                      getList(e, t) {
                        throw new Error("Method not implemented.");
                      }
                      onGetItemFailure(e, t) {
                        throw new Error("Method not implemented.");
                      }
                      onGetListFailure(e, t) {
                        throw new Error("Method not implemented.");
                      }
                    })
                  ) || lo)
              ) || lo)
          ) || lo)
      );
      function go(e) {
        return w.GROUPID_PREFIX + b.default.getRawGroupId(e);
      }
      var po = s("oOjv"),
        mo = s("bB26"),
        vo = s("lteq");
      const fo = { [Ze.c]: {} };
      a.ModuleContainer.registerSingleton(
        po.b,
        class {
          constructor() {
            Object(i.a)(this, "state", fo),
              Object(i.a)(this, "animationControllers", new Map()),
              Object(i.a)(this, "_manuallyOff", !1),
              Object(i.a)(this, "name", po.a),
              Object(i.a)(this, "key", "convId"),
              Object(i.a)(
                this,
                "isFeatEnabled",
                () => !this._manuallyOff && I.default.preview_msg_time.enable
              ),
              (this.state = fo);
          }
          offFeature() {
            this._manuallyOff = !0;
          }
          enableFeature() {
            this._manuallyOff = !1;
          }
          getAnimController(e) {
            if (!this.isFeatEnabled()) return null;
            if (!this.animationControllers.has(e)) {
              const t = new mo.a(e);
              this.animationControllers.set(e, t);
            }
            return this.animationControllers.get(e) || null;
          }
          setScrollDirection(e, t) {
            if (!this.isFeatEnabled()) return;
            const s = this.getAnimController(e);
            null == s || s.setScrollDirection(t);
          }
          hasNewMsgInView(e, t) {
            if (!this.isFeatEnabled()) return;
            const s = this.getAnimController(e);
            null == s || s.hasNewMsgInView(t);
          }
          hasViewOverflowMsg(e, t) {
            if (!this.isFeatEnabled()) return;
            const s = this.getAnimController(e);
            null == s || s.hasViewOverflowMsg(t);
          }
          hitBottom(e, t) {
            if (!this.isFeatEnabled()) return;
            const s = this.getAnimController(e);
            null == s || s.hitBottom(t);
          }
          triggerActiveScroll(e, t) {
            if (!this.isFeatEnabled()) return;
            const s = this.getAnimController(e);
            null == s || s.triggerActiveScroll(t);
          }
          onChangeConversation(e) {
            var t;
            const s = this.getAnimController(e);
            null == s || s.resetAnimation(),
              null === (t = vo.a.getInViewController(e)) ||
                void 0 === t ||
                t.resetPreviewTimestamp();
          }
          clearAnimations(e) {
            const t = this.getAnimController(e);
            null == t || t.clearAnimations();
          }
          onMouseEnterPreviewTime(e, t) {
            if (!this.isFeatEnabled() || !t) return;
            const s = this.getAnimController(e);
            (null == s ? void 0 : s.mountedPreviewTime) === t &&
              (null == s || s.pause());
          }
          onMouseLeavePreviewTime(e, t) {
            if (!this.isFeatEnabled() || !t) return;
            const s = this.getAnimController(e);
            (null == s ? void 0 : s.mountedPreviewTime) === t &&
              (null == s || s.resume());
          }
          setTopMost(e, t, s) {
            if (!this.isFeatEnabled()) return;
            const i = this.getAnimController(e);
            null == i || i.setTopMost(t, s);
          }
          setSecondTopMost(e, t, s) {
            if (!this.isFeatEnabled()) return;
            const i = this.getAnimController(e);
            null == i || i.setSecondTopMost(t, s);
          }
          init() {}
          getItem(e) {
            return this.state[e.key];
          }
          getList(e) {
            return Object.keys(this.state);
          }
          onGetItemFailure(e) {}
          onGetListFailure(e) {}
        }
      );
      const bo = Object(a.define)("chat-box-list-controller");
      var _o,
        So = s("Ti+8");
      Object(j.h)()(
        (_o =
          Object(j.g)()(
            (_o =
              Object(a.singleton)(bo)(
                (_o =
                  Object(a.injectable)()(
                    (_o =
                      (function (e, t) {
                        return Object(a.inject)(O.ZLoggerFactory)(e, void 0, 0);
                      })(
                        (_o =
                          Reflect.metadata(
                            "design:type",
                            Function
                          )(
                            (_o =
                              Reflect.metadata("design:paramtypes", [
                                void 0 === O.ZLoggerFactory
                                  ? Object
                                  : O.ZLoggerFactory,
                              ])(
                                (_o = class {
                                  constructor(e) {
                                    Object(i.a)(this, "logger", void 0),
                                      Object(i.a)(
                                        this,
                                        "handleMessageDelivered",
                                        (e) => {
                                          var t;
                                          b.default.log([
                                            "message delivered",
                                            null === (t = e.payload) ||
                                            void 0 === t
                                              ? void 0
                                              : t.length,
                                          ]);
                                        }
                                      ),
                                      (this.logger = e.createZLogger("feat", [
                                        "chat-box-list-controller",
                                      ]));
                                  }
                                  onStart() {
                                    a.ModuleContainer.resolve(
                                      So.a
                                    ).addEventListener(
                                      In.MessageDelivered,
                                      this.handleMessageDelivered
                                    );
                                  }
                                  onDispose() {
                                    a.ModuleContainer.resolve(
                                      So.a
                                    ).removeEventListener(
                                      In.MessageDelivered,
                                      this.handleMessageDelivered
                                    );
                                  }
                                  openConversation(e) {
                                    return Promise.resolve(!0);
                                  }
                                })
                              ) || _o)
                          ) || _o)
                      ) || _o)
                  ) || _o)
              ) || _o)
          ) || _o)
      );
      var yo,
        Co = s("7nHs");
      const Io = {
        isShown: !1,
        modalTitle: "",
        guideTitle: "",
        errorCode: "",
        guideItems: [],
        showReloadBtn: !0,
        reloadBtnName: "STR_BU_CONFIRM_TEXT_6",
        showDeleteDataBtn: !0,
        deleteDataBtnName: "STR_BU_CANCEL_TEXT_6",
      };
      Object(B.b)(Co.a)(
        (yo = class {
          constructor() {
            Object(i.a)(this, "name", Co.b),
              Object(i.a)(this, "key", ""),
              Object(i.a)(this, "state", Io);
          }
          setState(e) {
            const t = rt()(this.state, e);
            this.state !== t && ((this.state = t), Object(yt.g)(this.name, ""));
          }
          showModal(e) {
            this.state.isShown ||
              this.setState((t) =>
                Object(p.a)(
                  Object(p.a)(Object(p.a)({}, t), e),
                  {},
                  { isShown: !0 }
                )
              );
          }
          closeModal() {
            this.state.isShown &&
              this.setState((e) =>
                Object(p.a)(
                  Object(p.a)(Object(p.a)({}, e), Io),
                  {},
                  { isShown: !1 }
                )
              );
          }
          init(e) {}
          getItem(e, t) {
            return this.state;
          }
          getList(e, t) {
            return [];
          }
          onGetItemFailure(e, t) {
            throw new Error("Method not implemented.");
          }
          onGetListFailure(e, t) {
            throw new Error("Method not implemented.");
          }
        })
      );
      var Oo,
        Eo = s("Mf7h"),
        To = s("8c0e");
      const Ro = new b.LocalId();
      Object(a.injectable)()(
        (Oo =
          Object(a.singleton)(To.a)(
            (Oo = class {
              constructor() {
                Object(i.a)(this, "_linkPreviewDatas", new Map()),
                  Object(i.a)(this, "_lastCheckLinks", new Map()),
                  Object(i.a)(this, "_listeners", new Map());
              }
              addListenerAtConv(e, t) {
                if (e && "function" == typeof t) {
                  const s = this._listeners.get(e);
                  this._listeners.set(e, [...(s || []), t]);
                }
              }
              removeListenerAtConv(e, t) {
                let s = this._listeners.get(e);
                s &&
                  s.length > 0 &&
                  ((s = s.filter((e) => e !== t)), this._listeners.set(e, s));
              }
              removeAllListenerAtConv(e) {
                this._listeners.delete(e);
              }
              setLastCheckLinkByConvId(e, t) {
                this._lastCheckLinks.set(e, t);
              }
              isLastCheckLinkOfConv(e, t) {
                const s = this._lastCheckLinks.get(e);
                return !!s && s === t;
              }
              getLinkPreviewDataByConvId(e) {
                return this._linkPreviewDatas.get(e) || null;
              }
              addLinkDataToConv(e, t) {
                const s = this._prepareLinkPreviewData(e, t);
                this._linkPreviewDatas.set(e, Object(p.a)({}, s));
                const i = {
                  action: y.LinkPreviewActions.NEW_LINK_PREVIEW,
                  payload: { newLinkPreviewData: Object(p.a)({}, s) },
                };
                this._notifyLinkPreviewDataChangeToConv(e, i),
                  Eo.a.emit(y.LinkPreviewActions.NEW_LINK_PREVIEW, {
                    newLinkPreviewData: Object(p.a)({}, s),
                  });
              }
              createLoadingLinkPreview(e, t) {
                const s = {
                  id: Ro.next(),
                  convId: e,
                  content: {
                    title: jt.default.str("STR_GETTING_LINK_INFO"),
                    src: t,
                    desc: "",
                    thumb: "",
                    loading: !0,
                  },
                  link: t,
                  shouldParseLinkOrContact: !0,
                };
                e && this._linkPreviewDatas.set(e, Object(p.a)({}, s));
                const i = {
                  action: y.LinkPreviewActions.NEW_LINK_PREVIEW,
                  payload: { newLinkPreviewData: Object(p.a)({}, s) },
                };
                this._notifyLinkPreviewDataChangeToConv(e, i),
                  Eo.a.emit(y.LinkPreviewActions.NEW_LINK_PREVIEW, {
                    newLinkPreviewData: Object(p.a)({}, s),
                  });
              }
              removeLinkPreviewData(e) {
                if (!e) return;
                this._linkPreviewDatas.delete(e);
                const t = {
                  action: y.LinkPreviewActions.HIDE_LINK_PREVIEW,
                  payload: null,
                };
                this._notifyLinkPreviewDataChangeToConv(e, t),
                  Eo.a.emit(y.LinkPreviewActions.HIDE_LINK_PREVIEW, null);
              }
              _notifyLinkPreviewDataChangeToConv(e, t) {
                const s = this._listeners.get(e);
                null == s ||
                  s.forEach((e) => {
                    "function" == typeof e &&
                      e({ action: t.action, payload: t.payload });
                  });
              }
              _prepareLinkPreviewData(e, t) {
                return {
                  id: Ro.next(),
                  convId: e,
                  link: t.link,
                  content: t.content,
                  shouldParseLinkOrContact: !1,
                };
              }
            })
          ) || Oo)
      );
      var Lo,
        Mo = s("iy3m"),
        Fo = s("twqL");
      Object(j.h)()(
        (Lo =
          Object(a.singleton)(Fo.a)(
            (Lo =
              Reflect.metadata(
                "design:type",
                Function
              )(
                (Lo =
                  Reflect.metadata(
                    "design:paramtypes",
                    []
                  )(
                    (Lo = class {
                      constructor() {
                        (this.changeTimeFlushNotiReactWhenResumeApp =
                          this.changeTimeFlushNotiReactWhenResumeApp.bind(
                            this
                          )),
                          (this.changeTimeFlushNotiReactWhenDisNetwork =
                            this.changeTimeFlushNotiReactWhenDisNetwork.bind(
                              this
                            )),
                          (this.changeTimeFlushNotiReactWhenStartApp =
                            this.changeTimeFlushNotiReactWhenStartApp.bind(
                              this
                            ));
                      }
                      onStart(e) {
                        this.changeTimeFlushNotiReactWhenStartApp();
                      }
                      changeTimeFlushNotiReactWhenResumeApp() {
                        this.changeTimeFlushNotiReact(Object(Mo.d)());
                      }
                      setupTimer(e) {
                        (wa.a.TimeFlushNotiReact = e),
                          (wa.a.TimeMaxWaiting = Object(Mo.a)()),
                          wa.a.setupIntervalToFlushNotiReact(),
                          wa.a.setupTimeoutToGoBackNormalCondition();
                      }
                      changeTimeFlushNotiReactWhenDisNetwork(e) {
                        if (e === nn.a.CONNECTED) {
                          const e = nn.b.getPreStateNetwork();
                          e !== nn.a.CONNECTED &&
                            e !== nn.a.NOT_SET &&
                            this.changeTimeFlushNotiReact(Object(Mo.b)());
                        }
                      }
                      changeTimeFlushNotiReactWhenStartApp() {
                        this.changeTimeFlushNotiReact(Object(Mo.e)());
                      }
                      changeTimeFlushNotiReact(e) {
                        wa.a.notiReactTimeoutId
                          ? (wa.a.TimeFlushNotiReact !== e &&
                              ((wa.a.TimeFlushNotiReact = e),
                              wa.a.setupIntervalToFlushNotiReact()),
                            wa.a.TimeMaxWaiting !== Object(Mo.a)() &&
                              ((wa.a.TimeMaxWaiting = Object(Mo.a)()),
                              wa.a.setupTimeoutToGoBackNormalCondition()))
                          : this.setupTimer(e);
                      }
                    })
                  ) || Lo)
              ) || Lo)
          ) || Lo)
      );
      var wo = s("5cla"),
        Do = s("WV6O");
      class jo {
        static resetNewFriendList() {
          delete this.newListFriend, (this.newListFriend = void 0);
        }
        static addNewFriendUid(e) {
          void 0 === this.newListFriend && this.getNewFriendList(),
            this.newListFriend.push(e);
        }
        static getNewFriendList() {
          $e.default.removeNewFriend("", !0);
          let e = [];
          try {
            const t = r.a.getInstance().getItemForCurrentUser("f_nf");
            t && (e = JSON.parse(t));
          } catch (t) {}
          this.newListFriend = e.map((e) => e.userId);
        }
        static getFriendList(e) {
          const { userId: t } = e,
            s = [];
          return new Promise((e, i) => {
            D.default
              .getFriends()
              .then((i) => {
                if (i) {
                  const a = Boolean(Mt.g.getConfigShowAllUser(t));
                  for (let e = 0; e < i.length; e++)
                    (1 === i[e].isFr ||
                      i[e].isFr ||
                      i[e].userId === I.default.supportPage) &&
                      i[e].userId != t &&
                      i[e].isValid &&
                      i[e].userId != I.default.sendToMeId &&
                      (a ||
                        i[e].isActive ||
                        i[e].isActivePC ||
                        i[e].isActiveWeb) &&
                      s.push(i[e].userId);
                  e(s);
                } else e([]);
              })
              .catch((e) => i(e));
          });
        }
        static getFriendInfo(e) {
          var t;
          const { userId: s } = e,
            i = D.default.getProfileFriendSync(s);
          return i
            ? (void 0 === this.newListFriend && this.getNewFriendList(),
              {
                userId: i.userId,
                avatar: i.avatar,
                displayName: i.displayName,
                isFr: i.isFr,
                zaloName: i.zaloName,
                bizPkg: i.bizPkg,
                bizInfo: i.bizInfo,
                isNewFriend:
                  (null === (t = this.newListFriend) || void 0 === t
                    ? void 0
                    : t.includes(s)) || !1,
                isBlocked: i.isBlocked,
              })
            : null;
        }
      }
      Object(i.a)(jo, "newListFriend", void 0);
      class Ao {
        static getGroupList(e) {
          return new Promise((e, t) => {
            ne.default
              .getGroupsList()
              .then((t) => {
                const s = t.map((e) => e.userId);
                e(s);
              })
              .catch(t);
          });
        }
        static getGroupInfo(e) {
          const { userId: t } = e;
          return new Promise((e, s) => {
            ne.default
              .getGroupById(t)
              .then((t) => {
                e({
                  userId: t.userId,
                  avatar: t.avatar,
                  displayName: t.displayName,
                  topMember: t.topMember,
                  totalMember: t.totalMember,
                  creatorId: t.creatorId,
                });
              })
              .catch(s);
          });
        }
        static getGroupInfoSync(e) {
          const { userId: t } = e,
            s = ne.default.getGroupByIdSync(t);
          return s
            ? {
                userId: s.userId,
                avatar: s.avatar,
                displayName: s.displayName,
                topMember: s.topMember,
                totalMember: s.totalMember,
                creatorId: s.creatorId,
              }
            : null;
        }
      }
      class No {
        static getRecommendFriendList() {
          return new Promise((e, t) => {
            is.default
              .getRecommendedFriends()
              .then((t) => e(t.recommItems))
              .catch(t);
          });
        }
        static getRelatedGroup(e) {
          return new Promise((t, s) => {
            is.default.getRelatedGroup(e).then(t).catch(s);
          });
        }
        static getRequestedFriendList() {
          return new Promise((e, t) => {
            is.default.getRequestedFriends().then(e).catch(t);
          });
        }
        static acceptAddFriend(e) {
          return bs.a.acceptAddFriend(e);
        }
        static rejectAddFriend(e) {
          return bs.a.rejectRequestAddFriend(e);
        }
        static makeUndoSentRequestFriend(e) {
          return bs.a.undoRequestAddFriend(e.userId);
        }
        static removeSuggestFriend(e) {
          return new Promise((t, s) => {
            is.default
              .removeRecommendedFriendV2(e.uid, e.src, e.type)
              .then(t)
              .catch(s);
          });
        }
      }
      var Po;
      const ko = {
          currentView: Do.c.FRIEND_LIST,
          unread: { newFriendRequests: [], newGroupRequests: [] },
        },
        Uo = "1",
        Bo = "ctt_l_a",
        Go = "ctt_l_r";
      Object(B.b)(wo.b)(
        (Po =
          Reflect.metadata(
            "design:type",
            Function
          )(
            (Po =
              Reflect.metadata(
                "design:paramtypes",
                []
              )(
                (Po = class {
                  constructor() {
                    Object(i.a)(this, "type", void 0),
                      Object(i.a)(this, "name", void 0),
                      Object(i.a)(this, "key", void 0),
                      Object(i.a)(this, "currentTab", void 0),
                      Object(i.a)(this, "data", new Map()),
                      Object(i.a)(this, "_Logger", void 0),
                      (this.name = wo.a),
                      (this.key = wo.a),
                      this.data.set(Uo, ko),
                      (this.currentTab = "");
                  }
                  get Logger() {
                    return (
                      this._Logger ||
                        (this._Logger = a.ModuleContainer.resolve(
                          O.ZLoggerFactory
                        ).createZLogger(Ut.b.contactTabV2, [this.name])),
                      this._Logger
                    );
                  }
                  _updateState(e, t = "1", s = !0) {
                    this.data.set(t, e), s && Object(yt.g)(this.name, t);
                  }
                  _getState(e = "1") {
                    return this.data.get(e);
                  }
                  _getAccessTime() {
                    try {
                      return JSON.parse(
                        r.a.getInstance().getItemForCurrentUser(Bo)
                      );
                    } catch (e) {
                      return (
                        this.Logger.zsymb(
                          18,
                          8362,
                          3e4,
                          "[_getAccessTime], error: " + JSON.stringify(e)
                        ),
                        null
                      );
                    }
                  }
                  _setAccessTime(e) {
                    r.a
                      .getInstance()
                      .setItemForCurrentUser(Bo, JSON.stringify(e));
                  }
                  _setLastRequestFriendTime(e, t, s) {
                    let i = [];
                    try {
                      i =
                        JSON.parse(
                          r.a.getInstance().getItemForCurrentUser(Go)
                        ) || [];
                    } catch (n) {
                      this.Logger.zsymb(
                        18,
                        8362,
                        30001,
                        "[_setLastRequestFriendTime], error: " +
                          JSON.stringify(n)
                      );
                    }
                    let a = [];
                    switch (e) {
                      case "NEW":
                        i.find((e) => (null == e ? void 0 : e.userId) === s)
                          ? ((a = i.filter((e) => e.userId !== s)),
                            (a = [{ ts: t, userId: s }, ...i]))
                          : (a = [{ ts: t, userId: s }, ...i]);
                        break;
                      case "REMOVE":
                        a = i.filter((e) => e.userId !== s);
                    }
                    r.a
                      .getInstance()
                      .setItemForCurrentUser(Go, JSON.stringify(a));
                  }
                  _getLastRequestAddFriendTime() {
                    let e;
                    try {
                      e = JSON.parse(
                        r.a.getInstance().getItemForCurrentUser(Go)
                      );
                    } catch (t) {
                      this.Logger.zsymb(
                        18,
                        8362,
                        30002,
                        "[_getLastRequestAddFriendTime], error: " +
                          JSON.stringify(t)
                      );
                    }
                    return e ? e[0] : null;
                  }
                  _onChangeView(e) {
                    switch (
                      (a.ModuleContainer.resolve(
                        Ct.SidebarController
                      ).updateSelectedId(null),
                      e)
                    ) {
                      case Do.c.FRIEND_LIST:
                        Object(vt.f)({
                          type: y.SideBarActions.SELECT_FRIEND_LIST,
                          payload: { userId: "999" },
                        });
                        break;
                      case Do.c.GROUP_LIST:
                        Object(vt.f)({
                          type: y.SideBarActions.SELECT_GROUP_CENTER,
                          payload: { userId: "999" },
                        });
                        break;
                      case Do.c.FRIEND_REQUEST:
                        Object(vt.f)({
                          type: y.SideBarActions.SELECT_FRIEND_CENTER,
                          payload: { userId: "999" },
                        });
                    }
                  }
                  _onUpdateUnreadRequest(e, t) {
                    const s = this._getState();
                    if (!s) return;
                    let i = s.unread;
                    switch (t) {
                      case "FRIEND":
                        i.newFriendRequests.push(e);
                        break;
                      case "GROUP":
                        i.newGroupRequests.push(e);
                    }
                    this._updateState(
                      Object(p.a)(Object(p.a)({}, s), {}, { unread: i }),
                      Uo,
                      !0
                    );
                  }
                  _clearUnreadRequest() {
                    const e = this._getState();
                    if (!e) return;
                    let t = e.unread;
                    (t.newFriendRequests = []),
                      (t.newGroupRequests = []),
                      this._updateState(
                        Object(p.a)(Object(p.a)({}, e), {}, { unread: t }),
                        Uo,
                        !0
                      );
                  }
                  init(e) {
                    throw new Error("Method not implemented.");
                  }
                  getItem(e, t) {
                    return this._getState(e.key);
                  }
                  getList(e, t) {
                    throw new Error("Method not implemented.");
                  }
                  onGetItemFailure(e, t) {
                    throw new Error("Method not implemented.");
                  }
                  onGetListFailure(e, t) {
                    throw new Error("Method not implemented.");
                  }
                  getDefaultItem() {
                    throw new Error("Method not implemented.");
                  }
                  getDefaultList() {
                    throw new Error("Method not implemented.");
                  }
                  resetTabData() {
                    (this.currentTab = ""),
                      jo.resetNewFriendList(),
                      a.ModuleContainer.resolve(wo.b).resetData(),
                      a.ModuleContainer.resolve(wo.f).resetData(),
                      a.ModuleContainer.resolve(wo.e).resetData(),
                      a.ModuleContainer.resolve(wo.j).resetData(),
                      a.ModuleContainer.resolve(wo.i).resetData(),
                      a.ModuleContainer.resolve(wo.m).resetData();
                  }
                  resetData() {
                    const e = this._getState();
                    e &&
                      this._updateState(
                        Object(p.a)(
                          Object(p.a)({}, e),
                          {},
                          { currentView: Do.c.FRIEND_LIST }
                        )
                      );
                  }
                  changeView(e) {
                    const t = this._getState();
                    t &&
                      this._updateState(
                        Object(p.a)(Object(p.a)({}, t), {}, { currentView: e }),
                        Uo,
                        !0
                      ),
                      (this.currentTab = e),
                      this._onChangeView(e);
                  }
                  onClickContabTabEntry() {
                    if (document.getElementById("ContactTabV2")) {
                      const e = this._getState(),
                        t =
                          (null == e ? void 0 : e.currentView) ||
                          ko.currentView;
                      this._onChangeView(t);
                    }
                  }
                  onContactTab(e) {
                    this._setAccessTime(e), this._clearUnreadRequest();
                  }
                  getDefaultView() {
                    if (this.currentTab) return this.currentTab;
                    const e = this._getAccessTime(),
                      t = this._getLastRequestAddFriendTime();
                    if (!t)
                      return (
                        (this.currentTab = Do.c.FRIEND_LIST), this.currentTab
                      );
                    const s =
                        !I.default.contactTabV2
                          .enable_rule_last_view_friend_req ||
                        (e && t.ts < e),
                      i = t.ts < Date.now() - 864e5;
                    return (
                      (this.currentTab =
                        i && s ? Do.c.FRIEND_LIST : Do.c.FRIEND_REQUEST),
                      this.currentTab
                    );
                  }
                  onUpdateRequestTracking(e, t, s, i) {
                    if (
                      ("NEW" === t
                        ? this._onUpdateUnreadRequest(i, e)
                        : "REMOVE" === t && this._clearUnreadRequest(),
                      "FRIEND" === e)
                    )
                      this._setLastRequestFriendTime(t, s || 0, i);
                  }
                  onInitUnreadRequest() {
                    const e = this._getState();
                    let t = (null == e ? void 0 : e.unread) || ko.unread;
                    const s =
                        (null == e ? void 0 : e.currentView) || ko.currentView,
                      i = this._getAccessTime(),
                      a = this._getLastRequestAddFriendTime();
                    a &&
                      i &&
                      (i < a.ts && t.newFriendRequests.push(a.userId),
                      this._updateState({ currentView: s, unread: t }, Uo, !0));
                  }
                })
              ) || Po)
          ) || Po)
      );
      var zo = s("iq5K");
      const xo = (e, t) => {
          const s = b.default.simpleStripVietnamese(t).split(" "),
            i = b.default.simpleStripVietnamese(e).split(" ");
          return (() => {
            const e = [];
            for (const t of s) {
              let s = !1;
              for (let a = 0; a < i.length; ++a)
                if (i[a].startsWith(t) && !e.includes(a)) {
                  e.push(a), (s = !0);
                  break;
                }
              if (!s) return !1;
            }
            return !0;
          })();
        },
        Vo = (e) =>
          new Promise((t, s) => {
            if (!e) return t(e);
            setTimeout(() => {
              t(e);
            }, e);
          });
      var qo;
      Object(B.b)(wo.f)(
        (qo =
          Object(a.injectable)()(
            (qo =
              (function (e, t) {
                return a.ModuleContainer.inject(wo.e)(e, void 0, 0);
              })(
                (qo =
                  (function (e, t) {
                    return a.ModuleContainer.inject(Ct.LabelDataManager)(
                      e,
                      void 0,
                      1
                    );
                  })(
                    (qo =
                      Reflect.metadata(
                        "design:type",
                        Function
                      )(
                        (qo =
                          Reflect.metadata("design:paramtypes", [
                            void 0 === wo.e ? Object : wo.e,
                            void 0 === Ct.LabelDataManager
                              ? Object
                              : Ct.LabelDataManager,
                          ])(
                            (qo = class {
                              constructor(e, t) {
                                (this.friendInfoManager = e),
                                  (this.labelDataManager = t),
                                  Object(i.a)(this, "type", void 0),
                                  Object(i.a)(this, "name", void 0),
                                  Object(i.a)(this, "key", void 0),
                                  Object(i.a)(this, "listState", void 0),
                                  Object(i.a)(this, "listFriend", void 0),
                                  Object(i.a)(this, "initListFriend", void 0),
                                  Object(i.a)(this, "currentPage", void 0),
                                  Object(i.a)(this, "didSort", void 0),
                                  Object(i.a)(this, "eventBusInstance", void 0),
                                  Object(i.a)(this, "_Logger", void 0),
                                  (this.name = wo.d),
                                  (this.key = wo.d),
                                  (this.listState = zo.d),
                                  (this.listFriend = []),
                                  (this.initListFriend = []),
                                  (this.currentPage = 1),
                                  (this.didSort = !1),
                                  (this.eventBusInstance = null);
                              }
                              get Logger() {
                                return (
                                  this._Logger ||
                                    (this._Logger = a.ModuleContainer.resolve(
                                      O.ZLoggerFactory
                                    ).createZLogger(Ut.b.contactTabV2, [
                                      this.name,
                                    ])),
                                  this._Logger
                                );
                              }
                              _signalRenderList() {
                                Object(yt.h)(this.name, "all");
                              }
                              _signalRenderItem() {
                                Object(yt.g)(this.name, "all");
                              }
                              _signalRenderBoth() {
                                Object(yt.g)(this.name, "all"),
                                  Object(yt.h)(this.name, "all");
                              }
                              _onRemoveFriend(e) {
                                this.listFriend.includes(e.userId) &&
                                  (this.listFriend.splice(
                                    this.listFriend.indexOf(e.userId),
                                    1
                                  ),
                                  this.initListFriend.splice(
                                    this.initListFriend.indexOf(e.userId),
                                    1
                                  ),
                                  (this.listState.totalRecord =
                                    this.listFriend.length),
                                  this._signalRenderBoth());
                              }
                              _onAddFriend(e) {
                                this.listFriend.includes(e.userId) ||
                                  (this.listFriend.unshift(e.userId),
                                  this.initListFriend.unshift(e.userId),
                                  jo.addNewFriendUid(e.userId),
                                  this._signalRenderList());
                              }
                              _getItemInfo(e) {
                                return (
                                  this.friendInfoManager.getItem(
                                    { key: e, version: 1, extraData: null },
                                    null
                                  ) ||
                                  this.friendInfoManager.loadInfoNotRender({
                                    userId: e,
                                  })
                                );
                              }
                              _onBlockFriend(e) {
                                this.friendInfoManager.onLoadInfo({
                                  userId: e.userId,
                                });
                              }
                              _onUnBlockFriend(e) {
                                this.friendInfoManager.onLoadInfo({
                                  userId: e.userId,
                                });
                              }
                              _onEditAlias(e) {
                                this.friendInfoManager.onLoadInfo({
                                  userId: e.userId,
                                }),
                                  (this.listFriend = this._handleFilter(
                                    this.listState.searching.searchText,
                                    this.listState.searching.sorter,
                                    this.listState.searching.filter,
                                    !this.isDidSort(),
                                    !1
                                  )),
                                  (this.listState.totalRecord =
                                    this.listFriend.length),
                                  this._signalRenderBoth();
                              }
                              _onUpdateTagConv(e, t = "add") {
                                let s = !1;
                                e.convIds.forEach((i) => {
                                  if (
                                    (this.friendInfoManager.onLoadInfo({
                                      userId: i,
                                    }),
                                    this.listState.searching.filter.label.id &&
                                      this.listState.searching.filter.label
                                        .id === +e.labelId)
                                  ) {
                                    const e = this.listFriend.findIndex(
                                      (e) => e === i
                                    );
                                    "remove" === t && -1 !== e
                                      ? (this.listFriend.splice(e, 1),
                                        (this.listState.totalRecord = Math.max(
                                          this.listState.totalRecord - 1,
                                          0
                                        )),
                                        (s = !0))
                                      : "add" === t &&
                                        -1 === e &&
                                        (this.listFriend.push(i),
                                        (this.listFriend = this._handleFilter(
                                          this.listState.searching.searchText,
                                          this.listState.searching.sorter,
                                          this.listState.searching.filter,
                                          !1,
                                          !1
                                        )),
                                        (this.listState.totalRecord =
                                          this.listFriend.length),
                                        (s = !0));
                                  }
                                }),
                                  s && this._signalRenderBoth();
                              }
                              addComponentListeners() {
                                D.default.subscribeEventFriend(
                                  w.EventFriend.REMOVE_FRIEND,
                                  this._onRemoveFriend.bind(this)
                                ),
                                  D.default.subscribeEventFriend(
                                    w.EventFriend.ADD_FRIEND,
                                    this._onAddFriend.bind(this)
                                  ),
                                  D.default.subscribeEventFriend(
                                    w.EventFriend.BLOCK_FRIEND,
                                    this._onBlockFriend.bind(this)
                                  ),
                                  D.default.subscribeEventFriend(
                                    w.EventFriend.UNBLOCK_FRIEND,
                                    this._onUnBlockFriend.bind(this)
                                  ),
                                  (this.eventBusInstance = _.default.on(
                                    y.FetchActions.UPDATE_NAME,
                                    this._onEditAlias.bind(this)
                                  )),
                                  this.labelDataManager.addEventListener(
                                    Ct.LabelEvents.LabelAddConvs,
                                    (e) => {
                                      this._onUpdateTagConv(e.payload, "add");
                                    }
                                  ),
                                  this.labelDataManager.addEventListener(
                                    Ct.LabelEvents.LabelRemoveConvs,
                                    (e) => {
                                      this._onUpdateTagConv(
                                        e.payload,
                                        "remove"
                                      );
                                    }
                                  );
                              }
                              removeComponentListeners() {
                                D.default.unsubscribeEventFriend(
                                  w.EventFriend.REMOVE_FRIEND,
                                  this._onRemoveFriend.bind(this)
                                ),
                                  D.default.unsubscribeEventFriend(
                                    w.EventFriend.ADD_FRIEND,
                                    this._onAddFriend.bind(this)
                                  ),
                                  D.default.unsubscribeEventFriend(
                                    w.EventFriend.BLOCK_FRIEND,
                                    this._onBlockFriend.bind(this)
                                  ),
                                  D.default.unsubscribeEventFriend(
                                    w.EventFriend.UNBLOCK_FRIEND,
                                    this._onUnBlockFriend.bind(this)
                                  ),
                                  this.eventBusInstance &&
                                    this.eventBusInstance.remove(),
                                  this.labelDataManager.removeEventListener(
                                    Ct.LabelEvents.LabelAddConvs,
                                    (e) => {
                                      this._onUpdateTagConv(e.payload, "add");
                                    }
                                  ),
                                  this.labelDataManager.removeEventListener(
                                    Ct.LabelEvents.LabelRemoveConvs,
                                    (e) => {
                                      this._onUpdateTagConv(
                                        e.payload,
                                        "remove"
                                      );
                                    }
                                  );
                              }
                              async onLoadList(e) {
                                try {
                                  const t = await jo.getFriendList(e);
                                  (this.listFriend = t),
                                    (this.initListFriend = t),
                                    (this.listState.totalRecord = t.length),
                                    (this.listFriend = this._handleFilter(
                                      zo.g.searching.searchText,
                                      zo.g.searching.sorter,
                                      zo.g.searching.filter,
                                      !0,
                                      !1
                                    )),
                                    (this.initListFriend = this._handleFilter(
                                      zo.g.searching.searchText,
                                      zo.g.searching.sorter,
                                      zo.g.searching.filter,
                                      !0,
                                      !0
                                    )),
                                    (this.listState.totalRecord =
                                      this.listFriend.length),
                                    this._signalRenderItem(),
                                    this._signalRenderList();
                                } catch (t) {
                                  this.Logger.zsymb(
                                    18,
                                    9592,
                                    3e4,
                                    "[FriendListController] -> [onLoadList], error: " +
                                      JSON.stringify(t)
                                  );
                                }
                              }
                              onLoadMore() {
                                this.currentPage++, this._signalRenderList();
                              }
                              onFilterByName(e) {
                                if (!e) return [...this.initListFriend];
                                return [...this.initListFriend].filter((t) => {
                                  const s = this._getItemInfo(t);
                                  return xo(
                                    (null == s
                                      ? void 0
                                      : s.displayName.toLowerCase()) || "",
                                    e.toLowerCase()
                                  );
                                });
                              }
                              onFilterByLabel(e, t) {
                                if (!e) return t;
                                if (0 === e.length) return [];
                                return t.filter((t) => e.includes(t));
                              }
                              onFilterAll(e) {
                                return e;
                              }
                              onFilterHidden(e, t, s) {
                                return t || e
                                  ? s
                                  : s.filter((e) => !ae.a.isThreadHidden(e));
                              }
                              onSortAlpha(e, t) {
                                if (e === zo.o.DEFAULT) return t;
                                return t.sort((t, s) => {
                                  const i = this._getItemInfo(t),
                                    a = this._getItemInfo(s);
                                  return ((t, s) => {
                                    const i = /^[a-zA-Z]/,
                                      a = i.test(
                                        b.default.simpleStripVietnamese(t)
                                      ),
                                      n = i.test(
                                        b.default.simpleStripVietnamese(s)
                                      );
                                    switch (e) {
                                      case zo.o.ALPHA_INCREASE:
                                        return !a && n
                                          ? 1
                                          : a && !n
                                          ? -1
                                          : t.localeCompare(s);
                                      case zo.o.ALPHA_DECREASE:
                                        return !a && n
                                          ? -1
                                          : a && !n
                                          ? 1
                                          : s.localeCompare(t);
                                      default:
                                        return 0;
                                    }
                                  })(
                                    (null == i
                                      ? void 0
                                      : i.displayName.toLowerCase()) ||
                                      (null == i
                                        ? void 0
                                        : i.zaloName.toLowerCase()) ||
                                      "",
                                    (null == a
                                      ? void 0
                                      : a.displayName.toLowerCase()) ||
                                      (null == a
                                        ? void 0
                                        : a.zaloName.toLowerCase()) ||
                                      ""
                                  );
                                });
                              }
                              onMovingNewFriend(e) {
                                let t = [],
                                  s = [];
                                for (let i = e.length - 1; i >= 0; i--) {
                                  const a = this._getItemInfo(e[i]);
                                  null != a && a.isNewFriend
                                    ? t.unshift(null == a ? void 0 : a.userId)
                                    : s.unshift(null == a ? void 0 : a.userId);
                                }
                                return [...t, ...s];
                              }
                              _handleFilter(e, t, s, i, a) {
                                var n;
                                let r = [];
                                return (
                                  (r = this.onFilterByName(e)),
                                  (r = this.onFilterByLabel(
                                    null == s ||
                                      null === (n = s.label) ||
                                      void 0 === n
                                      ? void 0
                                      : n.convs,
                                    r
                                  )),
                                  (r = this.onFilterAll(r)),
                                  (r = this.onSortAlpha(t, r)),
                                  (r = this.onFilterHidden(a, e, r)),
                                  i && (r = this.onMovingNewFriend(r)),
                                  r
                                );
                              }
                              _checkDidSort(e) {
                                return (
                                  e !== zo.o.ALPHA_INCREASE
                                    ? (this.didSort = !0)
                                    : (this.didSort = !1),
                                  this.didSort
                                );
                              }
                              isDidSort() {
                                return this.didSort;
                              }
                              _updateInitListFriendWithoutDockNewFriends() {
                                (this.initListFriend = this._handleFilter(
                                  zo.g.searching.searchText,
                                  zo.g.searching.sorter,
                                  zo.g.searching.filter,
                                  !1,
                                  !0
                                )),
                                  (this.listState.totalRecord =
                                    this.listFriend.length);
                              }
                              onFilter(e, t, s) {
                                const i = this._checkDidSort(t);
                                i &&
                                  this._updateInitListFriendWithoutDockNewFriends(),
                                  (this.listFriend = this._handleFilter(
                                    e,
                                    t,
                                    s,
                                    !i,
                                    !1
                                  )),
                                  (this.listState.totalRecord =
                                    this.listFriend.length),
                                  this._signalRenderItem(),
                                  this._signalRenderList();
                              }
                              init(e) {
                                throw new Error("Method not implemented.");
                              }
                              getItem(e, t) {
                                return this.listState;
                              }
                              getList(e, t) {
                                return this.listFriend;
                              }
                              onGetItemFailure(e, t) {
                                throw new Error("Method not implemented.");
                              }
                              onGetListFailure(e, t) {
                                throw new Error("Method not implemented.");
                              }
                              getDefaultItem() {
                                throw new Error("Method not implemented.");
                              }
                              getDefaultList() {
                                throw new Error("Method not implemented.");
                              }
                              setSearchText(e) {
                                (this.listState.searching.searchText = e),
                                  this._signalRenderItem();
                              }
                              setSorter(e) {
                                (this.listState.searching.sorter = e),
                                  this._signalRenderItem();
                              }
                              setFilter(e) {
                                (this.listState.searching.filter = e),
                                  this._signalRenderItem();
                              }
                              getFilter() {
                                return this.listState.searching.filter;
                              }
                              getSorter() {
                                return this.listState.searching.sorter;
                              }
                              resetData() {
                                (this.listFriend = []),
                                  (this.initListFriend = []);
                              }
                              resetState() {
                                (this.listState = {
                                  totalRecord: 0,
                                  searching: {
                                    searchText: "",
                                    sorter: zo.o.ALPHA_INCREASE,
                                    filter: {
                                      label: { convs: null, id: null },
                                      admin: "",
                                      all: !0,
                                    },
                                  },
                                }),
                                  (this.currentPage = 1),
                                  (this.didSort = !1);
                              }
                            })
                          ) || qo)
                      ) || qo)
                  ) || qo)
              ) || qo)
          ) || qo)
      );
      var Ho;
      Object(B.b)(wo.e)(
        (Ho =
          Reflect.metadata(
            "design:type",
            Function
          )(
            (Ho =
              Reflect.metadata(
                "design:paramtypes",
                []
              )(
                (Ho = class {
                  constructor() {
                    Object(i.a)(this, "type", void 0),
                      Object(i.a)(this, "name", void 0),
                      Object(i.a)(this, "key", void 0),
                      Object(i.a)(this, "data", new Map()),
                      (this.name = wo.c),
                      (this.key = wo.c);
                  }
                  init(e) {
                    throw new Error("Method not implemented.");
                  }
                  onLoadInfo(e) {
                    const t = jo.getFriendInfo(e);
                    t &&
                      (this.data.set(e.userId, t),
                      Object(yt.g)(this.name, e.userId));
                  }
                  loadInfoNotRender(e) {
                    const t = jo.getFriendInfo(e);
                    return t ? (this.data.set(e.userId, t), t) : null;
                  }
                  getItem(e, t) {
                    return this.data.get(e.key);
                  }
                  getList(e, t) {
                    throw new Error("Method not implemented.");
                  }
                  onGetItemFailure(e, t) {
                    throw new Error("Method not implemented.");
                  }
                  onGetListFailure(e, t) {
                    throw new Error("Method not implemented.");
                  }
                  getDefaultItem() {
                    throw new Error("Method not implemented.");
                  }
                  getDefaultList() {
                    throw new Error("Method not implemented.");
                  }
                  resetData() {
                    this.data.clear();
                  }
                })
              ) || Ho)
          ) || Ho)
      );
      var Ko;
      Object(B.b)(wo.j)(
        (Ko =
          Object(a.injectable)()(
            (Ko =
              (function (e, t) {
                return a.ModuleContainer.inject(wo.i)(e, void 0, 0);
              })(
                (Ko =
                  (function (e, t) {
                    return a.ModuleContainer.inject(me.h)(e, void 0, 1);
                  })(
                    (Ko =
                      (function (e, t) {
                        return a.ModuleContainer.inject(Ct.LabelDataManager)(
                          e,
                          void 0,
                          2
                        );
                      })(
                        (Ko =
                          Reflect.metadata(
                            "design:type",
                            Function
                          )(
                            (Ko =
                              Reflect.metadata("design:paramtypes", [
                                void 0 === wo.i ? Object : wo.i,
                                void 0 === me.h ? Object : me.h,
                                void 0 === Ct.LabelDataManager
                                  ? Object
                                  : Ct.LabelDataManager,
                              ])(
                                (Ko = class {
                                  constructor(e, t, s) {
                                    (this.groupInfoManager = e),
                                      (this.previewDataManager = t),
                                      (this.labelDataManager = s),
                                      Object(i.a)(this, "type", void 0),
                                      Object(i.a)(this, "name", void 0),
                                      Object(i.a)(this, "key", void 0),
                                      Object(i.a)(this, "listState", void 0),
                                      Object(i.a)(this, "listGroup", void 0),
                                      Object(i.a)(
                                        this,
                                        "initListGroup",
                                        void 0
                                      ),
                                      Object(i.a)(this, "currentPage", void 0),
                                      Object(i.a)(this, "_Logger", void 0),
                                      (this.name = wo.h),
                                      (this.key = wo.h),
                                      (this.listState = zo.e),
                                      (this.listGroup = []),
                                      (this.initListGroup = []),
                                      (this.currentPage = 1);
                                  }
                                  get Logger() {
                                    return (
                                      this._Logger ||
                                        (this._Logger =
                                          a.ModuleContainer.resolve(
                                            O.ZLoggerFactory
                                          ).createZLogger(Ut.b.contactTabV2, [
                                            this.name,
                                          ])),
                                      this._Logger
                                    );
                                  }
                                  _signalRenderList() {
                                    Object(yt.h)(this.name, "all");
                                  }
                                  _signalRenderItem() {
                                    Object(yt.g)(this.name, "all");
                                  }
                                  _signalRenderBoth() {
                                    Object(yt.g)(this.name, "all"),
                                      Object(yt.h)(this.name, "all");
                                  }
                                  _getItemInfo(e) {
                                    return (
                                      this.groupInfoManager.getItem(
                                        { key: e, version: 1, extraData: null },
                                        null
                                      ) ||
                                      this.groupInfoManager.loadInfoNotRender({
                                        userId: e,
                                      })
                                    );
                                  }
                                  init(e) {
                                    throw new Error("Method not implemented.");
                                  }
                                  getItem(e, t) {
                                    return this.listState;
                                  }
                                  async onLoadList() {
                                    try {
                                      const e = await Ao.getGroupList({});
                                      (this.listGroup = e),
                                        (this.initListGroup = e),
                                        (this.listState.totalRecord = e.length),
                                        this.groupInfoManager.loadMultiGroupInfo(
                                          this.initListGroup
                                        ),
                                        (this.listGroup = this._handleFilter(
                                          zo.h.searching.searchText,
                                          zo.h.searching.sorter,
                                          zo.h.searching.filter,
                                          !1
                                        )),
                                        (this.initListGroup =
                                          this._handleFilter(
                                            zo.h.searching.searchText,
                                            zo.h.searching.sorter,
                                            zo.h.searching.filter,
                                            !0
                                          )),
                                        (this.listState.totalRecord =
                                          this.listGroup.length),
                                        this._signalRenderItem(),
                                        this._signalRenderList();
                                    } catch (e) {
                                      this.Logger.zsymb(
                                        18,
                                        9590,
                                        3e4,
                                        "[GroupListController] -> [onLoadList], error: " +
                                          JSON.stringify(e)
                                      );
                                    }
                                  }
                                  onLoadMore() {
                                    this.currentPage++,
                                      this._signalRenderList();
                                  }
                                  onFilterByName(e) {
                                    if (!e) return [...this.initListGroup];
                                    return this.initListGroup.filter((t) => {
                                      const s = this._getItemInfo(t);
                                      return xo(
                                        (null == s
                                          ? void 0
                                          : s.displayName.toLowerCase()) || "",
                                        e.toLowerCase()
                                      );
                                    });
                                  }
                                  onFilterByLabel(e, t) {
                                    if (!e) return t;
                                    if (0 === e.length) return [];
                                    return t.filter((t) => e.includes(t));
                                  }
                                  onFilterMyAdminGroup(e, t) {
                                    if (!e) return t;
                                    return t.filter((t) => {
                                      const s = this._getItemInfo(t);
                                      return (
                                        (null == s ? void 0 : s.creatorId) === e
                                      );
                                    });
                                  }
                                  onFilterAll(e) {
                                    return e;
                                  }
                                  onSortAlpha(e, t) {
                                    return e === zo.o.DEFAULT ||
                                      e === zo.o.ACTION_INCREASE ||
                                      e === zo.o.ACTION_DECREASE
                                      ? t
                                      : t.sort((t, s) => {
                                          const i = this._getItemInfo(t),
                                            a = this._getItemInfo(s),
                                            n =
                                              (null == i
                                                ? void 0
                                                : i.displayName.toLowerCase()) ||
                                              "",
                                            r =
                                              (null == a
                                                ? void 0
                                                : a.displayName.toLowerCase()) ||
                                              "";
                                          switch (e) {
                                            case zo.o.ALPHA_INCREASE:
                                              return n.localeCompare(r);
                                            case zo.o.ALPHA_DECREASE:
                                              return r.localeCompare(n);
                                            default:
                                              return 0;
                                          }
                                        });
                                  }
                                  onFilterHidden(e, t, s) {
                                    return t || e
                                      ? s
                                      : s.filter(
                                          (e) => !ae.a.isThreadHidden(e)
                                        );
                                  }
                                  onSortActionTime(e, t) {
                                    return e === zo.o.DEFAULT ||
                                      e === zo.o.ALPHA_INCREASE ||
                                      e === zo.o.ALPHA_DECREASE
                                      ? t
                                      : t.sort((t, s) => {
                                          var i, a;
                                          const n =
                                              (null ===
                                                (i =
                                                  this.previewDataManager.getPreviewByIDSync(
                                                    t
                                                  )) || void 0 === i
                                                ? void 0
                                                : i.messageTime) || 0,
                                            r =
                                              (null ===
                                                (a =
                                                  this.previewDataManager.getPreviewByIDSync(
                                                    s
                                                  )) || void 0 === a
                                                ? void 0
                                                : a.messageTime) || 0;
                                          switch (e) {
                                            case zo.o.ACTION_DECREASE:
                                              if (r && n) {
                                                if (r > n) return 1;
                                                if (r < n) return -1;
                                              }
                                              return r && !n
                                                ? 1
                                                : !r && n
                                                ? -1
                                                : 0;
                                            case zo.o.ACTION_INCREASE:
                                              if (r && n) {
                                                if (r < n) return 1;
                                                if (r > n) return -1;
                                              }
                                              return !r && n
                                                ? 1
                                                : r && !n
                                                ? -1
                                                : 0;
                                            default:
                                              return 0;
                                          }
                                        });
                                  }
                                  _handleFilter(e, t, s, i) {
                                    var a;
                                    let n = [];
                                    return (
                                      (n = this.onFilterByName(e)),
                                      (n = this.onFilterByLabel(
                                        null == s ||
                                          null === (a = s.label) ||
                                          void 0 === a
                                          ? void 0
                                          : a.convs,
                                        n
                                      )),
                                      (n = this.onFilterMyAdminGroup(
                                        (null == s ? void 0 : s.admin) || "",
                                        n
                                      )),
                                      (n = this.onFilterAll(n)),
                                      (n = this.onSortAlpha(t, n)),
                                      (n = this.onSortActionTime(t, n)),
                                      (n = this.onFilterHidden(i, e, n)),
                                      n
                                    );
                                  }
                                  onFilter(e, t, s) {
                                    (this.listGroup = this._handleFilter(
                                      e,
                                      t,
                                      s,
                                      !1
                                    )),
                                      (this.listState.totalRecord =
                                        this.listGroup.length),
                                      this._signalRenderItem(),
                                      this._signalRenderList();
                                  }
                                  _onUpdateTagConv(e, t = "add") {
                                    let s = !1;
                                    e.convIds.forEach((i) => {
                                      if (
                                        (this.groupInfoManager.onLoadInfo({
                                          userId: i,
                                        }),
                                        this.listState.searching.filter.label
                                          .id &&
                                          this.listState.searching.filter.label
                                            .id === +e.labelId)
                                      ) {
                                        const e = this.listGroup.findIndex(
                                          (e) => e === i
                                        );
                                        "remove" === t && -1 !== e
                                          ? (this.listGroup.splice(e, 1),
                                            (this.listState.totalRecord =
                                              Math.max(
                                                this.listState.totalRecord - 1,
                                                0
                                              )),
                                            (s = !0))
                                          : "add" === t &&
                                            -1 === e &&
                                            (this.listGroup.push(i),
                                            (this.listGroup =
                                              this._handleFilter(
                                                this.listState.searching
                                                  .searchText,
                                                this.listState.searching.sorter,
                                                this.listState.searching.filter,
                                                !1
                                              )),
                                            (this.listState.totalRecord =
                                              this.listGroup.length),
                                            (s = !0));
                                      }
                                    }),
                                      s && this._signalRenderBoth();
                                  }
                                  _onLeaveGroup(e) {
                                    for (let t = 0; t < e.length; t++) {
                                      if (!this.listGroup.includes(e[t]))
                                        return;
                                      this.listGroup.splice(
                                        this.listGroup.indexOf(e[t]),
                                        1
                                      ),
                                        this.initListGroup.splice(
                                          this.listGroup.indexOf(e[t]),
                                          1
                                        ),
                                        (this.listState.totalRecord =
                                          this.listGroup.length);
                                    }
                                    this._signalRenderBoth();
                                  }
                                  addComponentListeners() {
                                    ne.default.subscribeEventGroup(
                                      w.EventGroup.LEAVE_GROUP,
                                      this._onLeaveGroup.bind(this)
                                    ),
                                      this.labelDataManager.addEventListener(
                                        Ct.LabelEvents.LabelAddConvs,
                                        (e) => {
                                          this._onUpdateTagConv(
                                            e.payload,
                                            "add"
                                          );
                                        }
                                      ),
                                      this.labelDataManager.addEventListener(
                                        Ct.LabelEvents.LabelRemoveConvs,
                                        (e) => {
                                          this._onUpdateTagConv(
                                            e.payload,
                                            "remove"
                                          );
                                        }
                                      );
                                  }
                                  removeComponentListeners() {
                                    ne.default.unsubscribeEventGroup(
                                      w.EventGroup.LEAVE_GROUP,
                                      this._onLeaveGroup.bind(this)
                                    ),
                                      this.labelDataManager.removeEventListener(
                                        Ct.LabelEvents.LabelAddConvs,
                                        (e) => {
                                          this._onUpdateTagConv(
                                            e.payload,
                                            "add"
                                          );
                                        }
                                      ),
                                      this.labelDataManager.removeEventListener(
                                        Ct.LabelEvents.LabelRemoveConvs,
                                        (e) => {
                                          this._onUpdateTagConv(
                                            e.payload,
                                            "remove"
                                          );
                                        }
                                      );
                                  }
                                  getList(e, t) {
                                    return this.listGroup;
                                  }
                                  onGetItemFailure(e, t) {
                                    throw new Error("Method not implemented.");
                                  }
                                  onGetListFailure(e, t) {
                                    throw new Error("Method not implemented.");
                                  }
                                  getDefaultItem() {
                                    throw new Error("Method not implemented.");
                                  }
                                  getDefaultList() {
                                    throw new Error("Method not implemented.");
                                  }
                                  setSearchText(e) {
                                    (this.listState.searching.searchText = e),
                                      this._signalRenderItem();
                                  }
                                  setSorter(e) {
                                    (this.listState.searching.sorter = e),
                                      this._signalRenderItem();
                                  }
                                  setFilter(e) {
                                    (this.listState.searching.filter = e),
                                      this._signalRenderItem();
                                  }
                                  getFilter() {
                                    return this.listState.searching.filter;
                                  }
                                  getSorter() {
                                    return this.listState.searching.sorter;
                                  }
                                  resetData() {
                                    (this.listGroup = []),
                                      (this.initListGroup = []);
                                  }
                                  resetState() {
                                    (this.listState = {
                                      totalRecord: 0,
                                      searching: {
                                        searchText: "",
                                        sorter: zo.o.ACTION_DECREASE,
                                        filter: {
                                          label: { convs: null, id: null },
                                          admin: "",
                                          all: !0,
                                        },
                                      },
                                    }),
                                      (this.currentPage = 1);
                                  }
                                })
                              ) || Ko)
                          ) || Ko)
                      ) || Ko)
                  ) || Ko)
              ) || Ko)
          ) || Ko)
      );
      var $o;
      let Wo;
      Object(B.b)(wo.i)(
        ($o =
          Reflect.metadata(
            "design:type",
            Function
          )(
            ($o =
              Reflect.metadata(
                "design:paramtypes",
                []
              )(
                ($o = class {
                  constructor() {
                    Object(i.a)(this, "type", void 0),
                      Object(i.a)(this, "name", void 0),
                      Object(i.a)(this, "key", void 0),
                      Object(i.a)(this, "data", new Map()),
                      (this.name = wo.g),
                      (this.key = wo.g);
                  }
                  init(e) {
                    throw new Error("Method not implemented.");
                  }
                  async onLoadInfo(e) {
                    const t = Ao.getGroupInfoSync(e);
                    t &&
                      (this.data.set(e.userId, t),
                      Object(yt.g)(this.name, e.userId));
                  }
                  loadInfoNotRender(e) {
                    const t = Ao.getGroupInfoSync(e);
                    return t ? (this.data.set(e.userId, t), t) : null;
                  }
                  loadMultiGroupInfo(e) {
                    for (const t of e) this.loadInfoNotRender({ userId: t });
                  }
                  openGroupMemberPopup(e) {
                    const t = this.data.get(e);
                    He.ModalManagerV2.openModal({
                      windowId: "1",
                      name: w.ModalIdentitiesDefine.GROUP_PROFILE,
                      params: { group_member: t },
                    });
                  }
                  getItem(e, t) {
                    return this.data.get(e.key);
                  }
                  getList(e, t) {
                    throw new Error("Method not implemented.");
                  }
                  onGetItemFailure(e, t) {
                    throw new Error("Method not implemented.");
                  }
                  onGetListFailure(e, t) {
                    throw new Error("Method not implemented.");
                  }
                  getDefaultItem() {
                    throw new Error("Method not implemented.");
                  }
                  getDefaultList() {
                    throw new Error("Method not implemented.");
                  }
                  resetData() {
                    this.data.clear();
                  }
                })
              ) || $o)
          ) || $o)
      );
      !(function (e) {
        (e[(e.RECOMMEND = 1)] = "RECOMMEND"), (e[(e.RECEIVE = 2)] = "RECEIVE");
      })(Wo || (Wo = {}));
      const Zo = 500,
        Qo = 500;
      var Yo;
      Object(B.b)(wo.m)(
        (Yo =
          (function (e, t) {
            return a.ModuleContainer.inject(wo.b)(e, void 0, 0);
          })(
            (Yo =
              Reflect.metadata(
                "design:type",
                Function
              )(
                (Yo =
                  Reflect.metadata("design:paramtypes", [
                    void 0 === wo.b ? Object : wo.b,
                  ])(
                    (Yo = class extends re.b {
                      constructor(e) {
                        super(),
                          (this.contactTabController = e),
                          Object(i.a)(this, "type", void 0),
                          Object(i.a)(this, "name", void 0),
                          Object(i.a)(this, "key", void 0),
                          Object(i.a)(this, "data", new Map()),
                          Object(i.a)(this, "_Logger", void 0),
                          (this.name = wo.k),
                          (this.key = wo.k),
                          this.data.set("all", {
                            isLoadingRecommendFriendList: !1,
                            isLoadingRequestedFriendList: !1,
                            listFriendReceived: [],
                            listFriendSent: [],
                            listFriendSuggest: [],
                            mapRelatedGroup: {},
                          }),
                          this.addPublicListeners();
                      }
                      get Logger() {
                        return (
                          this._Logger ||
                            (this._Logger = a.ModuleContainer.resolve(
                              O.ZLoggerFactory
                            ).createZLogger(Ut.b.contactTabV2, [this.name])),
                          this._Logger
                        );
                      }
                      _signalRenderItem() {
                        Object(yt.g)(this.name, "all");
                      }
                      init(e) {
                        throw new Error("Method not implemented.");
                      }
                      getItem(e, t) {
                        return this.data.get(e.key);
                      }
                      _updateLoadingState(e, t) {
                        const {
                          listFriendReceived: s = [],
                          listFriendSuggest: i = [],
                          listFriendSent: a = [],
                        } = this.data.get("all") || {};
                        let {
                          isLoadingRecommendFriendList: n,
                          isLoadingRequestedFriendList: r,
                        } = this.data.get("all") || {};
                        if ("RecommendFriendList" === e)
                          switch (t) {
                            case "ON":
                              n || 0 !== s.length || 0 !== i.length || (n = !0);
                              break;
                            case "OFF":
                              n && (n = !1);
                          }
                        if ("RequestedFriendList" === e)
                          switch (t) {
                            case "ON":
                              r || 0 !== a.length || (r = !0);
                              break;
                            case "OFF":
                              r && (r = !1);
                          }
                        this.data.set(
                          "all",
                          Object(p.a)(
                            Object(p.a)({}, this.data.get("all")),
                            {},
                            {
                              isLoadingRecommendFriendList: n,
                              isLoadingRequestedFriendList: r,
                            }
                          )
                        ),
                          this._signalRenderItem();
                      }
                      async onLoadRequestedFriendList() {
                        const e = Date.now();
                        try {
                          this._updateLoadingState("RequestedFriendList", "ON");
                          const t = await No.getRequestedFriendList();
                          Date.now() - e < Zo && (await Vo(Qo)),
                            this._updateLoadingState(
                              "RequestedFriendList",
                              "OFF"
                            );
                          const s = Object.keys(t)
                              .map((e) => t[e])
                              .sort((e, t) => {
                                var s, i;
                                const a =
                                    null === (s = e.fReqInfo) || void 0 === s
                                      ? void 0
                                      : s.time,
                                  n =
                                    null === (i = t.fReqInfo) || void 0 === i
                                      ? void 0
                                      : i.time;
                                return n > a ? 1 : n < a ? -1 : 0;
                              }),
                            {
                              listFriendReceived: i = [],
                              listFriendSuggest: a = [],
                              mapRelatedGroup: n = {},
                            } = this.data.get("all") || {};
                          this.data.set(
                            "all",
                            Object(p.a)(
                              Object(p.a)({}, this.data.get("all")),
                              {},
                              {
                                listFriendReceived: i,
                                listFriendSent: s,
                                listFriendSuggest: a,
                                mapRelatedGroup: n,
                              }
                            )
                          ),
                            this._signalRenderItem();
                        } catch (t) {
                          Date.now() - e < Zo && (await Vo(Qo)),
                            this._updateLoadingState(
                              "RequestedFriendList",
                              "OFF"
                            ),
                            this.Logger.zsymb(
                              18,
                              10990,
                              3e4,
                              "[InvitationController] -> [onLoadRequestedFriendList], error: " +
                                JSON.stringify(t)
                            );
                        }
                      }
                      async onLoadRecommendFriendList() {
                        const e = Date.now();
                        try {
                          this._updateLoadingState("RecommendFriendList", "ON");
                          const t = await No.getRecommendFriendList();
                          if (
                            (Date.now() - e < Zo && (await Vo(Qo)),
                            this._updateLoadingState(
                              "RecommendFriendList",
                              "OFF"
                            ),
                            Array.isArray(t) && t.length > 0)
                          ) {
                            const e = t.filter((e) => {
                                var t;
                                return (
                                  (null === (t = e.dataInfo) || void 0 === t
                                    ? void 0
                                    : t.recommType) === Wo.RECEIVE
                                );
                              }),
                              s = t.filter((e) => {
                                var t;
                                return (
                                  (null === (t = e.dataInfo) || void 0 === t
                                    ? void 0
                                    : t.recommType) === Wo.RECOMMEND
                                );
                              }),
                              {
                                listFriendSent: i = [],
                                mapRelatedGroup: a = {},
                              } = this.data.get("all") || {};
                            this.data.set(
                              "all",
                              Object(p.a)(
                                Object(p.a)({}, this.data.get("all")),
                                {},
                                {
                                  listFriendReceived: e,
                                  listFriendSent: i,
                                  listFriendSuggest: s,
                                  mapRelatedGroup: a,
                                }
                              )
                            ),
                              s.length > 0 &&
                                this.dispatchEvent(
                                  new Do.b(Do.a.LoadRelatedGroups, "", {})
                                ),
                              this._signalRenderItem();
                          }
                        } catch (t) {
                          Date.now() - e < Zo && (await Vo(Qo)),
                            this._updateLoadingState(
                              "RecommendFriendList",
                              "OFF"
                            ),
                            this.Logger.zsymb(
                              18,
                              10990,
                              30001,
                              "[InvitationController] -> [onLoadRecommendFriendList], error: " +
                                JSON.stringify(t)
                            );
                        }
                      }
                      _handleSortFriendSuggestList(e, t) {
                        return 0 === e.length
                          ? e
                          : e.sort((e, s) => {
                              var i, a, n, r, o, c;
                              const l =
                                  t[
                                    null === (i = e.dataInfo) || void 0 === i
                                      ? void 0
                                      : i.userId
                                  ] &&
                                  t[
                                    null === (a = e.dataInfo) || void 0 === a
                                      ? void 0
                                      : a.userId
                                  ].length,
                                d =
                                  (null === (n = e.dataInfo) || void 0 === n
                                    ? void 0
                                    : n.displayName) || "",
                                h =
                                  t[
                                    null === (r = s.dataInfo) || void 0 === r
                                      ? void 0
                                      : r.userId
                                  ] &&
                                  t[
                                    null === (o = s.dataInfo) || void 0 === o
                                      ? void 0
                                      : o.userId
                                  ].length,
                                u =
                                  (null === (c = s.dataInfo) || void 0 === c
                                    ? void 0
                                    : c.displayName) || "";
                              return l && h
                                ? l === h
                                  ? d.localeCompare(u)
                                  : h > l
                                  ? 1
                                  : -1
                                : l && !h
                                ? -1
                                : !l && h
                                ? 1
                                : l || h
                                ? 0
                                : d.localeCompare(u);
                            });
                      }
                      async onLoadRelatedGroupList() {
                        try {
                          const { listFriendSuggest: e = [] } =
                              this.data.get("all") || {},
                            t = e.map((e) => {
                              var t;
                              return null == e ||
                                null === (t = e.dataInfo) ||
                                void 0 === t
                                ? void 0
                                : t.userId;
                            }),
                            s = await No.getRelatedGroup(t),
                            {
                              listFriendReceived: i = [],
                              listFriendSent: a = [],
                            } = this.data.get("all") || {},
                            n = this._handleSortFriendSuggestList(
                              e,
                              s.groupRelateds
                            );
                          this.data.set(
                            "all",
                            Object(p.a)(
                              Object(p.a)({}, this.data.get("all")),
                              {},
                              {
                                listFriendReceived: i,
                                listFriendSent: a,
                                listFriendSuggest: n,
                                mapRelatedGroup: s.groupRelateds || {},
                              }
                            )
                          ),
                            this._signalRenderItem();
                        } catch (e) {
                          this.Logger.zsymb(
                            18,
                            10990,
                            30002,
                            "[InvitationController] -> [onLoadRelatedGroupList], error: " +
                              JSON.stringify(e)
                          );
                        }
                      }
                      handleFriendProfileChange(e) {
                        const {
                          listFriendReceived: t = [],
                          listFriendSuggest: s = [],
                          listFriendSent: i = [],
                        } = this.data.get("all") || {};
                        Object.keys(e).forEach((e) => {
                          const a = D.default.getDName(e),
                            n = t.findIndex((t) => t.dataInfo.userId === e);
                          -1 !== n && (t[n].displayName = a);
                          const r = s.findIndex((t) => t.dataInfo.userId === e);
                          -1 !== r && (s[r].displayName = a);
                          const o = i.findIndex((t) => t.userId === e);
                          -1 !== o && (i[o].displayName = a);
                        }),
                          this._signalRenderItem();
                      }
                      handlePublicFriendEvents(e) {
                        const t = e.payload;
                        if (t)
                          for (let i = 0; i < t.length; i++) {
                            var s;
                            const a = t[i].ts,
                              n =
                                ("add" === t[i].act && t[i].data) ||
                                (null === (s = t[i].data) || void 0 === s
                                  ? void 0
                                  : s.fromUid),
                              r = n === e.userId;
                            if (a && n && !r && "fr" === t[i].act_type)
                              switch (t[i].act) {
                                case "req_v2":
                                  this.contactTabController.onUpdateRequestTracking(
                                    "FRIEND",
                                    "NEW",
                                    a,
                                    n
                                  );
                                  break;
                                case "undo_req":
                                  this.contactTabController.onUpdateRequestTracking(
                                    "FRIEND",
                                    "REMOVE",
                                    a,
                                    n
                                  ),
                                    this.dispatchEvent(
                                      new Do.b(Do.a.UndoAddFriendEvent, "", n)
                                    );
                                  break;
                                case "add":
                                  this.contactTabController.onUpdateRequestTracking(
                                    "FRIEND",
                                    "REMOVE",
                                    a,
                                    n
                                  ),
                                    this.dispatchEvent(
                                      new Do.b(Do.a.AcceptAddFriendEvent, "", n)
                                    );
                                  break;
                                case "reject":
                                  this.contactTabController.onUpdateRequestTracking(
                                    "FRIEND",
                                    "REMOVE",
                                    a,
                                    n
                                  ),
                                    this.dispatchEvent(
                                      new Do.b(Do.a.RejectAddFriendEvent, "", n)
                                    );
                              }
                          }
                      }
                      handlePublicAddFriendEvent(e) {
                        let t = [];
                        const s = e.payload;
                        if (s) {
                          for (let e = 0; e < s.length; e++) {
                            let i = {};
                            (i.userId = s[e].userId),
                              (i.zaloName = s[e].zaloName),
                              (i.avatar = s[e].avatar),
                              (i.displayName = s[e].displayName),
                              (i.recommInfo = {
                                message: s[e].friendRequestMsg,
                                source: s[e].friendRequestSource,
                              }),
                              (i.recommTime = s[e].friendRequestFetchTime),
                              (i.recommType = s[e].friendRequestType),
                              t.push({ dataInfo: i, recommItemType: 1 });
                          }
                          this.dispatchEvent(
                            new Do.b(Do.a.ReceiveAddFriendEvent, "", t)
                          );
                        }
                      }
                      addPublicListeners() {
                        this.addEventListener(
                          Do.a.PublicInvitationEvents,
                          this.handlePublicFriendEvents.bind(this)
                        ),
                          this.addEventListener(
                            Do.a.PublicReceiveAddFriendEvent,
                            this.handlePublicAddFriendEvent.bind(this)
                          ),
                          D.default.connectSignalChangeDNameAndAvatar(
                            this.handleFriendProfileChange.bind(this)
                          );
                      }
                      addComponentListeners() {}
                      removeComponentListeners() {}
                      _addFriendReceived(e) {
                        const {
                            listFriendReceived: t = [],
                            listFriendSent: s = [],
                            listFriendSuggest: i = [],
                            mapRelatedGroup: a = {},
                          } = this.data.get("all") || {},
                          n = e.concat(t);
                        this.data.set(
                          "all",
                          Object(p.a)(
                            Object(p.a)({}, this.data.get("all")),
                            {},
                            {
                              listFriendReceived: n,
                              listFriendSent: s,
                              listFriendSuggest: i,
                              mapRelatedGroup: a,
                            }
                          )
                        ),
                          this._signalRenderItem();
                      }
                      _removeFriendReceived(e) {
                        const {
                            listFriendReceived: t = [],
                            listFriendSent: s = [],
                            listFriendSuggest: i = [],
                            mapRelatedGroup: a = {},
                          } = this.data.get("all") || {},
                          n = t.filter((t) => {
                            var s;
                            return (
                              (null === (s = t.dataInfo) || void 0 === s
                                ? void 0
                                : s.userId) !== e
                            );
                          });
                        this.data.set(
                          "all",
                          Object(p.a)(
                            Object(p.a)({}, this.data.get("all")),
                            {},
                            {
                              listFriendReceived: n,
                              listFriendSent: s,
                              listFriendSuggest: i,
                              mapRelatedGroup: a,
                            }
                          )
                        ),
                          this._signalRenderItem();
                      }
                      onUpdateFriendRequests(e, t) {
                        switch (t) {
                          case "ADD":
                            this._addFriendReceived(e);
                            break;
                          case "REMOVE":
                            this._removeFriendReceived(e),
                              this._removeFriendSent(e);
                        }
                      }
                      async onRejectFriend(e) {
                        return new Promise((t, s) => {
                          No.rejectAddFriend(e)
                            .then(() => {
                              this._removeFriendReceived(e), t(e);
                            })
                            .catch((e) => {
                              this.Logger.zsymb(
                                18,
                                10990,
                                30003,
                                "[InvitationController] -> [onRejectFriend], error: " +
                                  JSON.stringify(e)
                              ),
                                s(e);
                            });
                        });
                      }
                      async onAddFriend(e) {
                        return new Promise((t, s) => {
                          No.acceptAddFriend(e)
                            .then(t)
                            .catch((e) => {
                              this.Logger.zsymb(
                                18,
                                10990,
                                30004,
                                "[InvitationController] -> [onAddFriend], error: " +
                                  JSON.stringify(e)
                              ),
                                s(e);
                            });
                        });
                      }
                      removeFriendSent(e) {
                        const {
                            listFriendReceived: t = [],
                            listFriendSent: s = [],
                            listFriendSuggest: i = [],
                            mapRelatedGroup: a = {},
                          } = this.data.get("all") || {},
                          n = s.filter(
                            (t) => (null == t ? void 0 : t.userId) !== e
                          );
                        this.data.set(
                          "all",
                          Object(p.a)(
                            Object(p.a)({}, this.data.get("all")),
                            {},
                            {
                              listFriendReceived: t,
                              listFriendSent: n,
                              listFriendSuggest: i,
                              mapRelatedGroup: a,
                            }
                          )
                        ),
                          this._signalRenderItem();
                      }
                      onRemoveFriendSent(e) {
                        No.makeUndoSentRequestFriend(e)
                          .then(() => {
                            this.removeFriendSent(e.userId);
                          })
                          .catch((e) => {
                            this.Logger.zsymb(
                              18,
                              10990,
                              30005,
                              "[InvitationController] -> [onRemoveFriendSent], error: " +
                                JSON.stringify(e)
                            ),
                              e && 301 == e.error_code
                                ? Dt.a.createError(
                                    jt.default.str("STR_UNDO_REQUEST_ERROR_301")
                                  )
                                : e && "ERR_NO_NETWORK" === e.code
                                ? Dt.a.createError(
                                    jt.default.str("STR_CHECK_NET")
                                  )
                                : Dt.a.createError(
                                    jt.default.str(
                                      "STR_UNDO_REQUEST_ERROR_UNKNOWN"
                                    )
                                  );
                          });
                      }
                      _removeFriendSuggest(e) {
                        const {
                            listFriendReceived: t = [],
                            listFriendSent: s = [],
                            listFriendSuggest: i = [],
                            mapRelatedGroup: a = {},
                          } = this.data.get("all") || {},
                          n = i.filter((t) => {
                            var s;
                            return (
                              (null == t ||
                              null === (s = t.dataInfo) ||
                              void 0 === s
                                ? void 0
                                : s.userId) !== e
                            );
                          });
                        this.data.set(
                          "all",
                          Object(p.a)(
                            Object(p.a)({}, this.data.get("all")),
                            {},
                            {
                              listFriendReceived: t,
                              listFriendSent: s,
                              listFriendSuggest: n,
                              mapRelatedGroup: a,
                            }
                          )
                        ),
                          this._signalRenderItem();
                      }
                      onAddFriendSuggest(e) {
                        vn.a
                          .doAddFriend(e.uid, e.src, null, e.windowId)
                          .then(() => {
                            this._removeFriendSuggest(e.uid),
                              this.onLoadRequestedFriendList();
                          })
                          .catch((e) => {
                            this.Logger.zsymb(
                              18,
                              10990,
                              30006,
                              "[InvitationController] -> [onAddFriendSuggest], error: " +
                                JSON.stringify(e)
                            );
                          });
                      }
                      onRemoveFriendSuggest(e) {
                        No.removeSuggestFriend(e)
                          .then(() => {
                            this._removeFriendSuggest(e.uid);
                          })
                          .catch((e) => {
                            this.Logger.zsymb(
                              18,
                              10990,
                              30007,
                              "[InvitationController] -> [onRemoveFriendSuggest], error: " +
                                JSON.stringify(e)
                            );
                          });
                      }
                      openMutualGroupPopup(e) {
                        He.ModalManagerV2.openModal({
                          windowId: "1",
                          name: w.ModalIdentitiesDefine.FRIEND_PROFILE,
                          params: { userId: e, showMutualGroups: !0 },
                        });
                      }
                      resetData() {
                        this.data.set("all", {
                          isLoadingRecommendFriendList: !1,
                          isLoadingRequestedFriendList: !1,
                          listFriendReceived: [],
                          listFriendSent: [],
                          listFriendSuggest: [],
                          mapRelatedGroup: {},
                        });
                      }
                      makeExpiredReceivedFriendRequest() {
                        let {
                          listFriendReceived: e = [],
                          listFriendSent: t = [],
                          listFriendSuggest: s = [],
                          mapRelatedGroup: i = {},
                        } = this.data.get("all") || {};
                        if (0 !== e.length) {
                          for (let t = 0; t < e.length; t++)
                            (e[t].dataInfo.recommTime = -1),
                              (e[t].dataInfo.recommInfo.source = -1),
                              (e[t].dataInfo.recommInfo.message = "");
                          this.data.set(
                            "all",
                            Object(p.a)(
                              Object(p.a)({}, this.data.get("all")),
                              {},
                              {
                                listFriendReceived: e,
                                listFriendSent: t,
                                listFriendSuggest: s,
                                mapRelatedGroup: i,
                              }
                            )
                          ),
                            this._signalRenderItem();
                        }
                      }
                      makeExpiredSentFriendSentRequest() {
                        let {
                          listFriendReceived: e = [],
                          listFriendSent: t = [],
                          listFriendSuggest: s = [],
                          mapRelatedGroup: i = {},
                        } = this.data.get("all") || {};
                        if (0 !== t.length) {
                          for (let e = 0; e < t.length; e++)
                            (t[e].fReqInfo.time = -1),
                              (t[e].fReqInfo.src = -1),
                              (t[e].fReqInfo.message = "");
                          this.data.set(
                            "all",
                            Object(p.a)(
                              Object(p.a)({}, this.data.get("all")),
                              {},
                              {
                                listFriendReceived: e,
                                listFriendSent: t,
                                listFriendSuggest: s,
                                mapRelatedGroup: i,
                              }
                            )
                          ),
                            this._signalRenderItem();
                        }
                      }
                      getList(e, t) {
                        throw new Error("Method not implemented.");
                      }
                      onGetItemFailure(e, t) {
                        throw new Error("Method not implemented.");
                      }
                      onGetListFailure(e, t) {
                        throw new Error("Method not implemented.");
                      }
                      getDefaultItem() {
                        throw new Error("Method not implemented.");
                      }
                      getDefaultList() {
                        throw new Error("Method not implemented.");
                      }
                    })
                  ) || Yo)
              ) || Yo)
          ) || Yo)
      );
      var Jo = s("akSd"),
        Xo = s("xQyS"),
        ec = s("fqRP"),
        tc = s("L904"),
        sc = s("EiAw"),
        ic = s("IoRb"),
        ac = s("CzFt");
      let nc;
      class rc {
        static get instance() {
          return nc || (nc = new rc()), nc;
        }
        get _eventStore() {
          return (
            this.__eventStore || (this.__eventStore = s("emRR").default),
            this.__eventStore
          );
        }
        constructor() {
          Object(i.a)(this, "__eventStore", void 0),
            Object(i.a)(this, "_emitConversationDeleted", (e) => {
              let t,
                s,
                i = [];
              if (
                (e.ok
                  ? ({ conversation: t, toUid: s, allItems: i } = e.value)
                  : ({ conversation: t, toUid: s, allItems: i } = e.error),
                t)
              )
                return;
              if (i.length && i.every((e) => e.ttlType === Da.a.Quote)) return;
              const a = {
                type: y.FetchActions.DELETE_CONVERSATION,
                payload: s,
              };
              this._eventStore.dispatch(a),
                ac.a.dispatch(a),
                _.default.send(a.type, a.payload);
            }),
            Object(i.a)(this, "_emitDeletedMsgs", (e) => {
              let t, s;
              e.ok
                ? ({ allItems: s, conversation: t } = e.value)
                : ({ allItems: s, conversation: t } = e.error);
              const i = s
                .filter((e) => e.ttlType === Da.a.Message)
                .map((e) => e.msgId);
              Object(sc.a)({ msgId: i, conversation: t });
            }),
            Object(i.a)(this, "_emitUpdateUnread", (e, t) => {
              let s,
                i = [];
              e.ok
                ? ({ toUid: s, allItems: i } = e.value)
                : ({ toUid: s, allItems: i } = e.error),
                N.a.UnreadDataManager.updateUnreadTTLConversation(
                  s,
                  i,
                  null == t ? void 0 : t.get(s)
                );
            }),
            Object(i.a)(this, "emitPerConversation", async (e, t) => {
              let s = await Object(Xo.a)(this._emitConversationDeleted, e);
              s.ok || Object(ic.a)("_emitConversationDeleted failed", s.error),
                (s = await Object(Xo.a)(this._emitDeletedMsgs, e)),
                s.ok || Object(ic.a)("_emitDeletedMsgs failed", s.error),
                (s = await Object(Xo.a)(this._emitUpdateUnread, e, t)),
                s.ok || Object(ic.a)("_emitUpdateUnread failed", s.error);
            });
        }
      }
      var oc,
        cc = s("LA52"),
        lc = s("GSaP");
      const dc = (e) => (null == e ? void 0 : e.toUid),
        hc = (e) => (null != e && e.ok ? "success" : "error");
      Object(a.singleton)(cc.a)(
        (oc =
          Reflect.metadata(
            "design:type",
            Function
          )(
            (oc =
              Reflect.metadata(
                "design:paramtypes",
                []
              )(
                (oc = class {
                  constructor() {
                    Object(i.a)(this, "_pruning", !1),
                      Object(i.a)(this, "_task", void 0),
                      Object(i.a)(
                        this,
                        "_ttl",
                        a.ModuleContainer.resolve(ec.a)
                      ),
                      Object(i.a)(this, "_logger", void 0),
                      Object(i.a)(this, "dispose", () => {}),
                      Object(i.a)(this, "prune", async () =>
                        this._pruning
                          ? await this._task
                          : ((this._pruning = !0),
                            (this._task = this._pruneFromDB()),
                            (this._pruning = !1),
                            this._task)
                      ),
                      Object(i.a)(this, "_pruneFromDB", async () => {
                        const e = Y.a.getTimeNow();
                        this._logger.zsymb(
                          0,
                          8293,
                          3e4,
                          "Pruner execute task",
                          e
                        );
                        const t = await Object(Xo.b)(
                          this._ttl.getExpireItemsBefore,
                          e
                        );
                        if (!t.ok)
                          return (
                            this._logger.zsymb(
                              18,
                              8293,
                              30001,
                              "Pruner getExpireItemsBefore failed",
                              t.error
                            ),
                            { ok: !1, error: null }
                          );
                        const s = t.ok ? t.value : [];
                        return await this._pruneTTLItems(s);
                      }),
                      Object(i.a)(this, "_pruneByMsgsBatch", []),
                      Object(i.a)(this, "pruneByMsgs", async (e) => {
                        const t = Object(C.a)(e);
                        this._pruneByMsgsBatch.push(...t),
                          setTimeout(() => {
                            const e = this._pruneByMsgsBatch;
                            (this._pruneByMsgsBatch = []),
                              e.length &&
                                (this._logger.zsymb(
                                  15,
                                  8293,
                                  30002,
                                  "running a batch {}",
                                  e.length
                                ),
                                this._pruneByMsgs(e));
                          }, 2e3);
                      }),
                      Object(i.a)(this, "_pruneByMsgs", async (e) => {
                        const t = Y.a.getTimeNow();
                        this._logger.zsymb(
                          15,
                          8293,
                          30003,
                          "deriving {}",
                          e.length
                        );
                        let s = lc.a
                          .createFromCurrentSession()
                          .deriveTTLItems(e);
                        this._logger.zsymb(
                          15,
                          8293,
                          30004,
                          "ttlItems count: {}",
                          s.length
                        ),
                          (s = s.filter((e) => {
                            const s =
                              +e.expireOn +
                              I.default.ttl
                                .enable_delete_on_filter_minimum_overtime;
                            return !isNaN(s) && s < t;
                          })),
                          this._logger.zsymb(
                            15,
                            8293,
                            30005,
                            "expired count: {}",
                            s.length
                          ),
                          (s = s.filter((e) => !this._hasPruneMsgCache(e))),
                          s.forEach((e) => {
                            this._setPruneMsgCache(e);
                          }),
                          this._logger.zsymb(
                            15,
                            8293,
                            30006,
                            "no cache count: {}",
                            s.length
                          ),
                          s.length
                            ? (this._logger.zsymb(
                                3,
                                8293,
                                30007,
                                "pruning {}, {}",
                                s.length,
                                s
                              ),
                              await this._deleteMsgsAndEmit(s))
                            : this._logger.zsymb(
                                15,
                                8293,
                                30008,
                                "no items to prune"
                              );
                      }),
                      Object(i.a)(
                        this,
                        "_pruneMsgCache",
                        new u.default({ maxSize: 1e4 })
                      ),
                      Object(i.a)(this, "_pruneTTLItems", async (e) => {
                        const t = e.map((e) => [e.msgId, e.ttlType]);
                        this._logger.zsymb(
                          3,
                          8293,
                          30009,
                          "pruning {} items: {}",
                          t.length,
                          t
                        ),
                          await this._deleteMsgsAndEmit(e);
                        const s = await Object(Xo.b)(this._ttl.deletes, t);
                        return (
                          s.ok ||
                            this._logger.zsymb(
                              18,
                              8293,
                              30010,
                              "Pruner deletes ttl failed",
                              s.error
                            ),
                          s
                        );
                      }),
                      Object(i.a)(this, "_retryErrorMsgsIfNeeded", (e) => {
                        for (const s of e) {
                          var t;
                          if (s.ok) continue;
                          const { errorItems: e, toUid: i } = s.error;
                          this._logger.zsymb(
                            0,
                            8293,
                            30011,
                            "_retryErrorDelete " + i,
                            null == e || null === (t = e[0]) || void 0 === t
                              ? void 0
                              : t.msgId
                          ),
                            setTimeout(() => {
                              Object(Xo.b)(this._deleteMsgsBelongToTTLItems, e);
                            }, 5e3);
                        }
                      }),
                      Object(i.a)(this, "_retryErrorDelete", (e) =>
                        setTimeout(async () => {
                          const t =
                              await this._ttl.getMappedMsgsByConvIdFromTTLItems(
                                e
                              ),
                            s = await Object(Xo.b)(
                              this._deleteMsgsBelongToTTLItems,
                              e
                            );
                          !s.ok &&
                            this._logger.zsymb(
                              18,
                              8293,
                              30012,
                              "Pruner _retryErrorDelete",
                              s.error
                            ),
                            s.ok && this._emitPruneResult(s.value, t);
                        }, 5e3)
                      ),
                      Object(i.a)(this, "_emitPruneResult", async (e, t) => {
                        for (const s of e)
                          await Object(Xo.b)(
                            rc.instance.emitPerConversation,
                            s,
                            t
                          );
                      }),
                      Object(i.a)(
                        this,
                        "_deletePerConversation",
                        async (e, t = []) => {
                          var s, i, a, n, r, o, c, l, d;
                          const h = await Object(Xo.b)(
                            la.b.vanishMessages,
                            e,
                            t
                          );
                          if (!h.ok)
                            return {
                              ok: !1,
                              error: {
                                toUid: e,
                                allItems: [],
                                errorItems: t,
                                successItems: [],
                              },
                            };
                          const u =
                              null === (s = h.value.vanish) || void 0 === s
                                ? void 0
                                : s[0],
                            g =
                              null === (i = h.value.quote) || void 0 === i
                                ? void 0
                                : i[0];
                          if (!u && !g)
                            return {
                              ok: !1,
                              error: {
                                toUid: e,
                                conversation: {},
                                allItems: [],
                                errorItems: t,
                                successItems: [],
                              },
                            };
                          const p =
                            null === (a = h.value.vanish) ||
                            void 0 === a ||
                            null === (n = a[0]) ||
                            void 0 === n ||
                            null === (r = n.conv) ||
                            void 0 === r
                              ? void 0
                              : r.conversation;
                          let m = [
                            ...(null !=
                            (o =
                              null === (c = h.value.vanish) || void 0 === c
                                ? void 0
                                : c.map((e) => e.res).flat())
                              ? o
                              : []),
                            ...(null !=
                            (l =
                              null === (d = h.value.quote) || void 0 === d
                                ? void 0
                                : d.flat())
                              ? l
                              : []),
                          ];
                          m = m.filter((e) => e);
                          const { success: v = [], error: f = [] } = Object(
                              tc.a
                            )(m, hc),
                            b = v.map((e) => e.info),
                            _ = f.map((e) => e.info),
                            S = [...b, ..._];
                          return _.length
                            ? {
                                ok: !1,
                                error: {
                                  toUid: e,
                                  conversation: p,
                                  allItems: S,
                                  successItems: b,
                                  errorItems: _,
                                },
                              }
                            : {
                                ok: !0,
                                value: {
                                  toUid: e,
                                  conversation: p,
                                  allItems: S,
                                  successItems: b,
                                },
                              };
                        }
                      ),
                      Object(i.a)(
                        this,
                        "_deleteMsgsBelongToTTLItems",
                        async (e) => {
                          const t = Object(tc.a)(e, dc),
                            s = Object.keys(t).map(
                              async (e) => (
                                Object(Xo.b)(this._sideEffect, e, t[e]),
                                this._deletePerConversation(e, t[e])
                              )
                            );
                          return await Promise.all(s);
                        }
                      ),
                      Object(i.a)(this, "_sideEffect", async (e, t = []) =>
                        setTimeout(async () => {
                          const s = await Object(Xo.b)(
                            this._cancelSendingPerConversation,
                            e,
                            t
                          );
                          s.ok ||
                            this._logger.zsymb(
                              18,
                              8293,
                              30013,
                              "cancelSendingPerConversation failed",
                              s.error
                            );
                          const i = await Object(Xo.b)(
                            this._syncDeletePerConversation,
                            e,
                            t
                          );
                          i.ok ||
                            this._logger.zsymb(
                              18,
                              8293,
                              30014,
                              "syncDeletePerConversation failed",
                              i.error
                            );
                        }, 0)
                      ),
                      Object(i.a)(
                        this,
                        "_cancelSendingPerConversation",
                        async (e, t = []) => {
                          t.forEach((t) =>
                            Object(Xo.b)(
                              () => {},
                              e,
                              null == t ? void 0 : t.cliMsgId
                            )
                          );
                        }
                      ),
                      Object(i.a)(
                        this,
                        "_syncDeletePerConversation",
                        async (e, t = []) => {
                          if (!I.default.ttl.enable_sync_delete) return;
                          const s = (t) => {
                            +t.msgId &&
                              Object(Jo.e)(e, {
                                cliMsgId: t.cliMsgId,
                                msgId: t.msgId,
                                sendDttm: t.sendDttm,
                                toUid: e,
                                fromUid: t.fromUid,
                              });
                          };
                          t.forEach((e) => Object(Xo.b)(s, e));
                        }
                      ),
                      (this._pruning = !1),
                      (this._logger = a.ModuleContainer.resolve(
                        O.ZLoggerFactory
                      ).createZLogger("utils", [
                        "ttl",
                        "destructor",
                        "pruner",
                      ]));
                  }
                  _getPruneMsgKey(e) {
                    return e ? `${e.msgId}|${e.ttlType}` : "";
                  }
                  _hasPruneMsgCache(e) {
                    return this._pruneMsgCache.has(this._getPruneMsgKey(e));
                  }
                  _setPruneMsgCache(e) {
                    this._pruneMsgCache.set(this._getPruneMsgKey(e), void 0);
                  }
                  async _deleteMsgsAndEmit(e) {
                    const t = await this._ttl.getMappedMsgsByConvIdFromTTLItems(
                        e
                      ),
                      s = await Object(Xo.b)(
                        this._deleteMsgsBelongToTTLItems,
                        e
                      );
                    s.ok ||
                      (this._logger.zsymb(
                        18,
                        8293,
                        30015,
                        "Pruner",
                        "deleteMessages failed"
                      ),
                      this._retryErrorDelete(e)),
                      s.ok && this._retryErrorMsgsIfNeeded(s.value),
                      s.ok && this._emitPruneResult(s.value, t);
                  }
                })
              ) || oc)
          ) || oc)
      );
      s("Ceyj");
      var uc,
        gc = s("K0f4"),
        pc = s("buT3"),
        mc = s("wudS");
      Object(j.h)()(
        (uc =
          Object(j.e)()(
            (uc = class {
              onAuthenticated(e) {
                const { userId: t } = e.getSession();
                if (t) {
                  const e = Object(mc.b)(t),
                    s = `${e}_${gc.m}`,
                    i = pc.a.getItem(s);
                  if (!(null !== i)) return;
                  const a = 97124,
                    n = "1" === i,
                    r = `${e}_${gc.g}`,
                    o = +(pc.a.getItem(r) || "-1"),
                    c = isNaN(o) ? -1 : o,
                    l = `${e}_${gc.i}`,
                    d = +(pc.a.getItem(l) || "-1"),
                    h = isNaN(d) ? -1 : d;
                  if (n) Zt.default.increaseSuccess(a, 0, c, [h]);
                  else {
                    const t = `${e}_${gc.c}`,
                      s = pc.a.getItem(t),
                      i = Number(s);
                    Zt.default.increaseFailed(a, 0, c, i, Date.now(), [h]);
                  }
                  pc.a.removeItem(s), pc.a.removeItem(r), pc.a.removeItem(l);
                }
              }
              onStart() {
                const e = gc.l,
                  t = pc.a.getItem(e);
                if (!(null !== t)) return;
                const s = "1" === t,
                  i = gc.f,
                  a = +(pc.a.getItem(i) || "-1"),
                  n = isNaN(a) ? -1 : a,
                  r = gc.h,
                  o = +(pc.a.getItem(r) || "-1"),
                  c = isNaN(o) ? -1 : o;
                if (s) Zt.default.increaseSuccess(97123, 0, n, [c]);
                else {
                  const e = pc.a.getItem(gc.b),
                    t = Number(e);
                  Zt.default.increaseFailed(97123, 0, n, t, Date.now(), [c]);
                }
                pc.a.removeItem(e), pc.a.removeItem(i), pc.a.removeItem(r);
              }
            })
          ) || uc)
      );
      var vc,
        fc = s("l9L4"),
        bc = s("CDcE");
      Object(j.d)()(
        (vc =
          Object(a.injectable)()(
            (vc =
              Object(a.singleton)(fc.a)(
                (vc =
                  (function (e, t) {
                    return Object(a.inject)(O.ZLoggerFactory)(e, void 0, 0);
                  })(
                    (vc =
                      Reflect.metadata(
                        "design:type",
                        Function
                      )(
                        (vc =
                          Reflect.metadata("design:paramtypes", [
                            void 0 === O.ZLoggerFactory
                              ? Object
                              : O.ZLoggerFactory,
                          ])(
                            (vc = class {
                              constructor(e) {
                                Object(i.a)(
                                  this,
                                  "_isFirstLoginMap",
                                  new Map()
                                ),
                                  Object(i.a)(
                                    this,
                                    "_firstLoginTimeMap",
                                    new Map()
                                  ),
                                  Object(i.a)(this, "_logger", void 0),
                                  (this._logger = e.createZLogger("utils", [
                                    "first-login-checker",
                                  ]));
                              }
                              getFirstLoginTime(e) {
                                if (this.firstLoginTimeMap.has(e))
                                  return (
                                    this.firstLoginTimeMap.get(e) ||
                                    this.getDefaultFirstLoginTime()
                                  );
                                try {
                                  const t = r.a
                                    .getInstance()
                                    .getItemForCurrentUser(
                                      w.FirstLoginLocalStorageKeys
                                        .FIRST_LOGIN_TIME
                                    );
                                  null != t &&
                                    this.firstLoginTimeMap.set(e, parseInt(t));
                                } catch (t) {
                                  this.logger.zsymb(
                                    21,
                                    8368,
                                    3e4,
                                    "getFirstLoginTime error {} - {}",
                                    e,
                                    Object(bc.f)(t, 2)
                                  );
                                }
                                return (
                                  this.firstLoginTimeMap.get(e) ||
                                  this.getDefaultFirstLoginTime()
                                );
                              }
                              isFirstLogin(e) {
                                return !!this._isFirstLoginMap.get(e);
                              }
                              onApplicationReady(e) {
                                this.removeFirstLoginFlag();
                              }
                              setFirstLogin(e, t) {
                                this._isFirstLoginMap.set(e, t);
                              }
                              setFirstLoginTime(e, t) {
                                this.firstLoginTimeMap.set(e, t);
                                try {
                                  r.a
                                    .getInstance()
                                    .setItemForCurrentUser(
                                      w.FirstLoginLocalStorageKeys
                                        .FIRST_LOGIN_TIME,
                                      (t && t.toString()) || ""
                                    );
                                } catch (s) {
                                  this.logger.zsymb(
                                    21,
                                    8368,
                                    30001,
                                    "setFirstLoginTime error {} - {} - {}",
                                    e,
                                    t,
                                    Object(bc.f)(s, 2)
                                  );
                                }
                              }
                              removeFirstLoginFlag() {
                                const e = D.default.getUidMe(),
                                  t = r.a.getInstance();
                                t.getItem(
                                  w.FirstLoginLocalStorageKeys.IS_FIRST_LOGIN
                                ) === e &&
                                  t.removeItem(
                                    w.FirstLoginLocalStorageKeys.IS_FIRST_LOGIN
                                  );
                              }
                              getDefaultFirstLoginTime() {
                                return Y.a.getTimeNow();
                              }
                              get firstLoginTimeMap() {
                                return this._firstLoginTimeMap;
                              }
                              get logger() {
                                return this._logger;
                              }
                            })
                          ) || vc)
                      ) || vc)
                  ) || vc)
              ) || vc)
          ) || vc)
      );
      const _c = Object(a.define)("transfer-data-suggestion-loader");
      var Sc = s("cgeJ"),
        yc = s("XVri"),
        Cc = s("bAqL");
      var Ic = class {
        constructor(e) {
          Object(i.a)(this, "_logger", void 0),
            Object(i.a)(this, "_moduleName", void 0),
            (this._moduleName = e);
        }
        log() {
          this.Logger.zsymb(0, 8460, 3e4, this.moduleTagName, ...arguments);
        }
        logError(e, t) {
          const s = null == t ? "" : this.stringifyDepthLevel(t);
          this.Logger.zsymb(18, 8460, 30001, this.moduleTagName, e, s);
        }
        stringifyDepthLevel(e) {
          return Object(Cc.d)(e, Object(Cc.a)());
        }
        get Logger() {
          return (
            this._logger ||
              (this._logger = a.ModuleContainer.resolve(
                O.ZLoggerFactory
              ).createZLogger("msg-sync", [yc.a])),
            this._logger
          );
        }
        get moduleTagName() {
          return this._moduleName + " - ";
        }
      };
      var Oc,
        Ec = class {
          constructor(e) {
            (this.moduleName = e),
              Object(i.a)(this, "_logger", void 0),
              (this._logger = new Ic(this.moduleName));
          }
          get Logger() {
            return this._logger;
          }
        };
      function Tc(e) {
        try {
          return JSON.stringify(e);
        } catch (t) {
          return "";
        }
      }
      function Rc(e) {
        return JSON.parse(e);
      }
      Object(a.injectable)()(
        (Oc =
          Object(a.singleton)(_c)(
            (Oc =
              Reflect.metadata(
                "design:type",
                Function
              )(
                (Oc =
                  Reflect.metadata(
                    "design:paramtypes",
                    []
                  )(
                    (Oc = class extends Ec {
                      constructor() {
                        super(Sc.d.LOADER),
                          Object(i.a)(this, "_friendManager", void 0),
                          Object(i.a)(this, "_groupManager", void 0);
                      }
                      async loadLastCloseBannerDownloadPC() {
                        const e = this.getSecureLocalStorageDB();
                        if (!e)
                          return (
                            this.Logger.logError(
                              "Load last close banner download pc failed cause invalid storage"
                            ),
                            Promise.reject()
                          );
                        try {
                          const t = await e.getItemForCurrentUserAsync(Sc.b);
                          return null != t
                            ? Rc(t)
                            : (this.Logger.logError(
                                "Load last close banner download pc failed null"
                              ),
                              null);
                        } catch (t) {
                          return (
                            this.Logger.logError(
                              "Load last close banner download pc failed",
                              t
                            ),
                            t
                          );
                        }
                      }
                      async loadListConversationsFromDB() {
                        const e = this.getSecureLocalStorageDB();
                        if (!e)
                          return (
                            this.Logger.logError(
                              "Load list conversations from DB failed cause invalid storage"
                            ),
                            Promise.reject([])
                          );
                        try {
                          const t = await e.getItemForCurrentUserAsync(Sc.c);
                          return null != t
                            ? Rc(t)
                            : (this.Logger.logError(
                                "Load list conversations from DB failed null"
                              ),
                              []);
                        } catch (t) {
                          return (
                            this.Logger.logError(
                              "Load list conversations from DB failed",
                              t
                            ),
                            []
                          );
                        }
                      }
                      async loadListFriends() {
                        const e = this.getFriendManagerModule();
                        if (e)
                          try {
                            return await e.getFriends();
                          } catch (t) {
                            return (
                              this.Logger.logError(
                                "Load list friends failed",
                                t
                              ),
                              []
                            );
                          }
                        return this.Logger.log("Load list friends empty"), [];
                      }
                      async loadListGroups() {
                        const e = this.getGroupManagerModule();
                        if (e)
                          try {
                            return await e.getGroupsList();
                          } catch (t) {
                            return (
                              this.Logger.logError(
                                "Load list groups failed",
                                t
                              ),
                              []
                            );
                          }
                        return this.Logger.log("Load list groups empty"), [];
                      }
                      async loadRegisteredData() {
                        const e = this.getSecureLocalStorageDB();
                        if (!e)
                          return (
                            this.Logger.logError(
                              "Load registered data failed cause invalid storage"
                            ),
                            Promise.reject()
                          );
                        try {
                          let t = e.getItemForCurrentUser(
                            w.RegisterLocalStorageKeys
                              .IS_REGISTERED_ON_THIS_DEVICE
                          );
                          return null != t
                            ? { isRegisteredOnThisDevice: Rc(t) }
                            : (this.Logger.log("Load registered data null"),
                              null);
                        } catch (t) {
                          return (
                            this.Logger.logError(
                              "Load registered data failed",
                              t
                            ),
                            t
                          );
                        }
                      }
                      async loadSyncMessagesData() {
                        const e = this.getSecureLocalStorageDB();
                        if (!e)
                          return (
                            this.Logger.logError(
                              "Load sync messages data failed cause invalid storage"
                            ),
                            Promise.reject()
                          );
                        try {
                          const t = e.getItemForCurrentUser(
                            "sync_cross_settings"
                          );
                          return t
                            ? Rc(t)
                            : (this.Logger.log("Load sync messages data null"),
                              null);
                        } catch (t) {
                          return (
                            this.Logger.logError(
                              "Load sync messages data failed",
                              t
                            ),
                            t
                          );
                        }
                      }
                      async loadTransferMessagesData() {
                        const e = this.getSecureLocalStorageDB();
                        if (!e)
                          return (
                            this.Logger.logError(
                              "Load transfer messages data failed cause invalid storage"
                            ),
                            Promise.reject()
                          );
                        try {
                          const t = await e.getItemForCurrentUserAsync(Sc.k);
                          return t
                            ? Rc(t)
                            : (this.Logger.logError(
                                "Load transfer messages data failed null"
                              ),
                              null);
                        } catch (t) {
                          return (
                            this.Logger.logError(
                              "Load transfer messages data failed",
                              t
                            ),
                            t
                          );
                        }
                      }
                      async setLastCloseBannerDownloadPC(e) {
                        const t = this.getSecureLocalStorageDB();
                        return t
                          ? await t.setItemForCurrentUserAsync(Sc.b, Tc(e))
                          : Promise.reject("Invalid storage");
                      }
                      async setListConversationsFirstLoginToDB(e) {
                        const t = this.getSecureLocalStorageDB();
                        return t
                          ? await t.setItemForCurrentUserAsync(Sc.c, Tc(e))
                          : Promise.reject("Invalid storage");
                      }
                      async updateTransferMessagesData(e) {
                        const t = {
                          lastTransferSuccessTime:
                            e.lastTransferSuccessTime || Date.now(),
                        };
                        try {
                          return await this.getSecureLocalStorageDB().setItemForCurrentUserAsync(
                            Sc.k,
                            Tc(t)
                          );
                        } catch (s) {
                          return s;
                        }
                      }
                      getFriendManagerModule() {
                        var e;
                        this._friendManager ||
                          (this._friendManager =
                            null === (e = s("UiPd")) || void 0 === e
                              ? void 0
                              : e.default);
                        return this._friendManager;
                      }
                      getGroupManagerModule() {
                        var e;
                        this._groupManager ||
                          (this._groupManager =
                            null === (e = s("Gm1y")) || void 0 === e
                              ? void 0
                              : e.default);
                        return this._groupManager;
                      }
                      getSecureLocalStorageDB() {
                        return r.a.getInstance();
                      }
                    })
                  ) || Oc)
              ) || Oc)
          ) || Oc)
      );
      var Lc = s("n09q"),
        Mc = s("31cx"),
        Fc = s("a1r1"),
        wc = s("BO4k");
      var Dc,
        jc = class extends Ec {
          constructor(e, t) {
            super(yc.c.MANAGER),
              Object(i.a)(this, "_eventMap", new Map()),
              Object(i.a)(this, "_fistLoginTime", void 0),
              Object(i.a)(this, "_listConversationsBeforeLogin", []),
              Object(i.a)(this, "_moduleLoader", void 0),
              Object(i.a)(this, "_moduleUIManager", void 0),
              (this._moduleLoader = e),
              (this._moduleUIManager = t),
              (this.handleUpdateConfigs = this.handleUpdateConfigs.bind(this)),
              (this.isDisplayedBannerDownloadPCSuggestion =
                this.isDisplayedBannerDownloadPCSuggestion.bind(this)),
              (this.isDisplayedBubbleInfoEcard =
                this.isDisplayedBubbleInfoEcard.bind(this)),
              (this.isDisplayedCloseButtonBannerDownloadPC =
                this.isDisplayedCloseButtonBannerDownloadPC.bind(this)),
              (this.isDisplayedConversationFooter =
                this.isDisplayedConversationFooter.bind(this)),
              (this.isDisplayedGlobalSearchFooter =
                this.isDisplayedGlobalSearchFooter.bind(this)),
              (this.isDisplayedSearchInConversationFooter =
                this.isDisplayedSearchInConversationFooter.bind(this)),
              (this.isDisplayedMilestoneInPreviewMedia =
                this.isDisplayedMilestoneInPreviewMedia.bind(this)),
              (this.isDisplayedSuggestionInMediaList =
                this.isDisplayedSuggestionInMediaList.bind(this)),
              (this.isDisplayedTransferModal =
                this.isDisplayedTransferModal.bind(this)),
              (this.isValidForTransferMessages =
                this.isValidForTransferMessages.bind(this));
          }
          addEventListeners(e, t) {
            this.eventMap.set(e, [...(this.eventMap.get(e) || []), t]);
          }
          callTransferMessages(e) {}
          closeBannerDownloadPCSuggestion() {}
          getConversationFooterRendererHeight() {
            return this.isDisplayedConversationFooter() ? yc.b.CONVERSATION : 0;
          }
          getFirstLoginTime() {
            return this.firstLoginTime;
          }
          getGlobalSearchFooterRendererHeight() {
            return this.isDisplayedConversationFooter()
              ? yc.b.GLOBAL_SEARCH
              : 0;
          }
          getLogger() {
            return this.Logger;
          }
          getUrlDownloadPC() {
            return "";
          }
          hasConversationBeforeFirstLogin(e) {
            return this._listConversationsBeforeLogin.includes(e);
          }
          hideTransferMessagesModal() {}
          async initialize() {
            (this.firstLoginTime = a.ModuleContainer.resolve(
              Fc.a
            ).getFirstLoginTime(this.getUserId())),
              this.handleUpdateConfigs(wc.a()),
              this.registerSubscriptions(),
              await this.initializeListConversationsBeforeFirstLogin();
          }
          isDisplayedBannerDownloadPCSuggestion() {
            return !!this.isEnabledFeature() && wc.e();
          }
          isDisplayedBubbleInfoEcard(e) {
            return (
              !!this.isEnabledFeature() &&
              !!wc.f() &&
              this.hasConversationBeforeFirstLogin(e)
            );
          }
          isDisplayedCloseButtonBannerDownloadPC() {
            return !!this.isEnabledFeature() && wc.i();
          }
          isDisplayedConversationFooter() {
            return !!this.isEnabledFeature() && wc.j();
          }
          isDisplayedCTADownloadPC() {
            return !!this.isEnabledFeature() && wc.g();
          }
          isDisplayedCTATransferMessages() {
            return !!this.isEnabledFeature() && wc.h();
          }
          isDisplayedGlobalSearchFooter() {
            return !!this.isEnabledFeature() && wc.k();
          }
          isDisplayedSearchInConversationFooter(e) {
            return (
              !!this.isEnabledFeature() &&
              !!wc.n() &&
              this.hasConversationBeforeFirstLogin(e)
            );
          }
          isDisplayedMilestoneInPreviewMedia(e) {
            return (
              !!this.isEnabledFeature() &&
              !!wc.m() &&
              this.hasConversationBeforeFirstLogin(e)
            );
          }
          isDisplayedSuggestionInMediaList(e) {
            return (
              !!this.isEnabledFeature() &&
              !!wc.l() &&
              this.hasConversationBeforeFirstLogin(e)
            );
          }
          isDisplayedTransferModal() {
            return !!this.isEnabledFeature() && wc.o();
          }
          isEnabledFeature() {
            return wc.p();
          }
          isValidSupportDownloadPC() {
            return !1;
          }
          isValidForTransferMessages() {
            return this.isEnabledFeature();
          }
          needTransferMessages() {}
          removeEventListeners(e, t) {
            const s = this.eventMap.get(e);
            if (Array.isArray(s)) {
              const e = s.findIndex((e) => e === t);
              -1 !== e && s.splice(e, 1);
            }
          }
          setFirstLoginTime(e) {
            this.firstLoginTime = e;
          }
          shouldTransferMessages() {
            return !1;
          }
          showTransferMessagesModal() {}
          registerSubscriptions() {
            I.$AppConfig.subscribe(this.handleUpdateConfigs);
          }
          isFirstLogin() {
            return a.ModuleContainer.resolve(Fc.a).isFirstLogin(
              this.getUserId()
            );
          }
          async initializeListConversationsBeforeFirstLogin() {
            this._listConversationsBeforeLogin =
              await this.loadListConversationsBeforeFirstLogin();
          }
          handleUpdateConfigs(e = {}) {
            const { data_content: t } = wc.b(e),
              { first_time_login_device: s } = e;
            t && this.UIManager.updateDataContent(Object(Mc.a)(t)),
              null != s && (this.firstLoginTime = s);
          }
          async loadListConversations() {
            const e = [],
              t = await this.loaderModule.loadListFriends();
            Array.isArray(t) &&
              t.forEach((t) => {
                e.push(t.userId);
              });
            const s = await this.loaderModule.loadListGroups();
            return (
              Array.isArray(s) &&
                s.forEach((t) => {
                  e.push(t.userId);
                }),
              e
            );
          }
          async loadListConversationsBeforeFirstLogin() {
            let e;
            if (this.isFirstLogin())
              (e = await this.loadListConversations()),
                this.loaderModule.setListConversationsFirstLoginToDB(e);
            else {
              const t = await this.loaderModule.loadListConversationsFromDB();
              (e = t),
                (t || []).length ||
                  ((e = await this.loadListConversations()),
                  this.loaderModule.setListConversationsFirstLoginToDB(e));
            }
            return e;
          }
          notifyEvent(e, ...t) {
            const s = this.eventMap.get(e);
            Array.isArray(s) &&
              s.forEach((e) => Promise.resolve(() => e(...t)));
          }
          get firstLoginTime() {
            return this._fistLoginTime;
          }
          set firstLoginTime(e) {
            this._fistLoginTime = e;
          }
          get eventMap() {
            return this._eventMap;
          }
          get loaderModule() {
            return this._moduleLoader;
          }
          get UIManager() {
            return this._moduleUIManager;
          }
          getUserId() {
            const e = a.ModuleContainer.resolve(j.a),
              { userId: t } = e.getSession() || {};
            return t || "";
          }
        },
        Ac = s("mgoj"),
        Nc = s("JCvM"),
        Pc = s("Vp9m"),
        kc = s("y4fj");
      Object(a.injectable)()(
        (Dc =
          Object(j.d)()(
            (Dc =
              Object(a.singleton)(Lc.a)(
                (Dc =
                  (function (e, t) {
                    return Object(a.inject)(_c)(e, void 0, 0);
                  })(
                    (Dc =
                      (function (e, t) {
                        return Object(a.inject)(Ac.a)(e, void 0, 1);
                      })(
                        (Dc =
                          (function (e, t) {
                            return Object(a.inject)(nr.a)(e, void 0, 2);
                          })(
                            (Dc =
                              Reflect.metadata(
                                "design:type",
                                Function
                              )(
                                (Dc =
                                  Reflect.metadata("design:paramtypes", [
                                    Object,
                                    void 0 ===
                                    Nc.ITransferDataSuggestionUIManager
                                      ? Object
                                      : Nc.ITransferDataSuggestionUIManager,
                                    void 0 === nr.a ? Object : nr.a,
                                  ])(
                                    (Dc = class extends jc {
                                      constructor(e, t, s) {
                                        super(e, t),
                                          Object(i.a)(
                                            this,
                                            "_moduleSyncMessages",
                                            void 0
                                          ),
                                          Object(i.a)(
                                            this,
                                            "_isImportedMessages",
                                            !1
                                          ),
                                          Object(i.a)(
                                            this,
                                            "_isRegisteredOnThisDevice",
                                            !1
                                          ),
                                          Object(i.a)(
                                            this,
                                            "_shouldTransferMessages",
                                            !1
                                          ),
                                          Object(i.a)(
                                            this,
                                            "_transferMessagesData",
                                            { lastTransferSuccessTime: void 0 }
                                          ),
                                          (this._moduleSyncMessages = s);
                                      }
                                      callTransferMessages(e) {
                                        this.Logger.log(
                                          "call transfer messages",
                                          e
                                        );
                                        switch (
                                          this.syncMessagesModule.getCurrentSyncScreenState()
                                        ) {
                                          case _r.a.Hidden:
                                          case _r.a.SuggestNewSync:
                                            return void this.syncMessagesStartSync(
                                              e
                                            );
                                          case _r.a.SuggestResume:
                                            return void this.syncMessagesResume();
                                          case _r.a.SyncGuide:
                                            return (
                                              this.syncMessagesModule.metricts.clickViewGuide(),
                                              void this.syncMessagesModule.showSuggestPopup()
                                            );
                                          case _r.a.WaitForBackup:
                                          case _r.a.DownloadingBackup:
                                          case _r.a.DecryptingBackup:
                                          case _r.a.SyncInProgress:
                                          case _r.a.ClearData:
                                          case _r.a.SyncSuccess:
                                            return void this.syncMessagesShowToast();
                                          case _r.a.WaitForNetwork:
                                          case _r.a.Error:
                                            return void this.syncMessagesStartSync(
                                              e
                                            );
                                          default:
                                            return;
                                        }
                                      }
                                      async initialize() {
                                        await super.initialize(),
                                          await this.loadTransferMessagesData(),
                                          await this.loadSyncMessagesData(),
                                          await this.loadRegisteredData(),
                                          this.loadImportMessagesData();
                                      }
                                      hideTransferMessagesModal() {
                                        this.UIManager.hideTransferMessagesModal();
                                      }
                                      isDisplayedBannerDownloadPCSuggestion() {
                                        return !1;
                                      }
                                      isDisplayedBubbleInfoEcard(e) {
                                        return (
                                          !!super.isDisplayedBubbleInfoEcard(
                                            e
                                          ) &&
                                          !this.isTransferredMessages() &&
                                          !this.isImportedMessages()
                                        );
                                      }
                                      isDisplayedConversationFooter() {
                                        return (
                                          !!super.isDisplayedConversationFooter() &&
                                          !this.isTransferredMessages() &&
                                          !this.isImportedMessages()
                                        );
                                      }
                                      isDisplayedGlobalSearchFooter() {
                                        return (
                                          !!super.isDisplayedConversationFooter() &&
                                          !this.isTransferredMessages() &&
                                          !this.isImportedMessages()
                                        );
                                      }
                                      isDisplayedMilestoneInPreviewMedia(e) {
                                        return (
                                          !!super.isDisplayedMilestoneInPreviewMedia(
                                            e
                                          ) &&
                                          !this.isTransferredMessages() &&
                                          !this.isImportedMessages()
                                        );
                                      }
                                      isDisplayedSearchInConversationFooter(e) {
                                        return (
                                          !!super.isDisplayedSearchInConversationFooter(
                                            e
                                          ) &&
                                          !this.isTransferredMessages() &&
                                          !this.isImportedMessages()
                                        );
                                      }
                                      isDisplayedSuggestionInMediaList(e) {
                                        return (
                                          !!super.isDisplayedSuggestionInMediaList(
                                            e
                                          ) &&
                                          !this.isTransferredMessages() &&
                                          !this.isImportedMessages()
                                        );
                                      }
                                      shouldTransferMessages() {
                                        return this._shouldTransferMessages;
                                      }
                                      isValidForTransferMessages() {
                                        return !0;
                                      }
                                      needTransferMessages() {
                                        this._shouldTransferMessages = !0;
                                      }
                                      onApplicationReady(e) {
                                        this.checkTransferMessagesSuggestionOnApplicationReady(),
                                          this.isEnabledFeature() &&
                                            (this.isRegisteredOnThisDevice() &&
                                              this.UIManager.turnOffDisplayingEntryPoints(),
                                            this.isTransferredMessages() ||
                                              this.isImportedMessages() ||
                                              this.isRegisteredOnThisDevice() ||
                                              kc.a.logAction(
                                                kc.a.Common
                                                  .DISPLAYED_NOT_ENOUGH_DATA_MESSAGE
                                              ));
                                      }
                                      showTransferMessagesModal() {
                                        kc.a.logAction(kc.a.Modal.DISPLAYED),
                                          this.UIManager.showTransferMessagesModal();
                                      }
                                      checkTransferMessagesSuggestionOnApplicationReady() {
                                        this.isEnabledFeature() &&
                                          this.isFirstLogin() &&
                                          !this.isTransferredMessages() &&
                                          this.shouldTransferMessages() &&
                                          this.showTransferMessagesModal();
                                      }
                                      handleEvents(e, t) {
                                        if (e === cs.c.EXPORT_IMPORT_FINISHED) {
                                          const { type: e, error: s } = t;
                                          e !== cs.g.IMPORT_TYPE ||
                                            s ||
                                            this.handleImportMessagesSuccess();
                                        }
                                      }
                                      handleImportMessagesSuccess() {
                                        (this._isImportedMessages = !0),
                                          this.UIManager.turnOffDisplayingEntryPoints(),
                                          a.ModuleContainer.resolve(
                                            Ct.ConvListController
                                          ).rerenderList();
                                      }
                                      handleSyncMessagesSuccess() {
                                        (this.transferMessagesData = {
                                          lastTransferSuccessTime:
                                            Y.a.getTimeNow(),
                                        }),
                                          this.loaderModule.updateTransferMessagesData(
                                            this.transferMessagesData
                                          ),
                                          this.UIManager.turnOffDisplayingEntryPoints(),
                                          a.ModuleContainer.resolve(
                                            Ct.ConvListController
                                          ).rerenderList();
                                      }
                                      isImportedMessages() {
                                        return this._isImportedMessages;
                                      }
                                      isRegisteredOnThisDevice() {
                                        return this._isRegisteredOnThisDevice;
                                      }
                                      isTransferredMessages() {
                                        return Boolean(
                                          this.transferMessagesData &&
                                            null !=
                                              this.transferMessagesData
                                                .lastTransferSuccessTime
                                        );
                                      }
                                      loadImportMessagesData() {
                                        const e = s("XSmZ").default;
                                        if (e) {
                                          const t =
                                            e.getExportImportInformation();
                                          t &&
                                            null != t.lastTimeImportSuccess &&
                                            (this._isImportedMessages = !0);
                                        }
                                      }
                                      async loadRegisteredData() {
                                        const e =
                                          await this.loaderModule.loadRegisteredData();
                                        e &&
                                          null != e.isRegisteredOnThisDevice &&
                                          (this._isRegisteredOnThisDevice =
                                            e.isRegisteredOnThisDevice);
                                      }
                                      async loadSyncMessagesData() {
                                        try {
                                          const e =
                                            await this.loaderModule.loadSyncMessagesData();
                                          e &&
                                            e.lastSync &&
                                            0 != e.lastSync &&
                                            this.updateLastTransferSuccessTime(
                                              e.lastSync
                                            );
                                        } catch (e) {}
                                      }
                                      async loadTransferMessagesData() {
                                        try {
                                          const e =
                                            await this.loaderModule.loadTransferMessagesData();
                                          e &&
                                            ((this.transferMessagesData = e),
                                            this.UIManager.turnOffDisplayingEntryPoints());
                                        } catch (e) {}
                                      }
                                      updateLastTransferSuccessTime(e) {
                                        this.transferMessagesData.lastTransferSuccessTime =
                                          e;
                                      }
                                      registerSubscriptions() {
                                        super.registerSubscriptions(),
                                          this.syncMessagesModule.addEventListener(
                                            hr.b.ON_SUCCESS,
                                            this.handleSyncMessagesSuccess.bind(
                                              this
                                            )
                                          ),
                                          _.default.subscribe(
                                            this.handleEvents.bind(this)
                                          );
                                      }
                                      syncMessagesShowToast() {
                                        Pc.default.show({
                                          textKey: "STR_TRANSFERRING_MSG_TOAST",
                                          type: Pc.TOAST_TYPE.INFO,
                                          noBackground: !0,
                                          duration: wc.d(),
                                        });
                                      }
                                      syncMessagesStartSync(e) {
                                        let t;
                                        switch (e) {
                                          case yc.j.CONVERSATION:
                                            t = Wn.i.CSC_LIST;
                                            break;
                                          case yc.j.BUBBLE_CSC:
                                            t = Wn.i.CSC;
                                            break;
                                          case yc.j.SEARCH_IN_CONVERSATION:
                                          case yc.j.GLOBAL_SEARCH:
                                            t = Wn.i.SEARCH;
                                            break;
                                          default:
                                            t = Wn.i.FIRST_TIME_LOGIN;
                                        }
                                        this.syncMessagesModule.sync(t);
                                      }
                                      syncMessagesResume() {
                                        this.syncMessagesModule.resume();
                                      }
                                      get syncMessagesModule() {
                                        return this._moduleSyncMessages;
                                      }
                                      get transferMessagesData() {
                                        return this._transferMessagesData;
                                      }
                                      set transferMessagesData(e) {
                                        this._transferMessagesData = e;
                                      }
                                    })
                                  ) || Dc)
                              ) || Dc)
                          ) || Dc)
                      ) || Dc)
                  ) || Dc)
              ) || Dc)
          ) || Dc)
      );
      var Uc,
        Bc = class extends Ec {
          constructor() {
            super(yc.c.UI),
              Object(i.a)(this, "key", Nc.c),
              Object(i.a)(this, "name", Nc.c),
              Object(i.a)(this, "dataState", Object(p.a)({}, yc.f)),
              Object(i.a)(this, "UIState", Object(p.a)({}, yc.g));
          }
          closeBannerDownloadPCSuggestion() {}
          hideTransferMessagesModal() {}
          init(e) {}
          initialize() {
            const { data_content: e } = Object(wc.b)(Object(wc.a)());
            this.handleUpdateContent(e);
          }
          getItem(e, t) {
            return e.key === yc.e
              ? this.dataState
              : e.key === yc.h
              ? this.UIState
              : {};
          }
          getList(e, t) {
            return [];
          }
          turnOffDisplayingEntryPoints() {
            this.handleUpdateRenderer({ isDisplayedEntryPoints: !1 });
          }
          onGetItemFailure(e, t) {}
          onGetListFailure(e, t) {}
          showTransferMessagesModal() {}
          updateDataContent(e) {
            this.handleUpdateContent(e);
          }
          setDataState(e) {
            const t = rt()(this.dataState, e);
            this.dataState !== t &&
              ((this.dataState = t), Object(yt.g)(this.name, yc.e));
          }
          setUIState(e) {
            const t = rt()(this.UIState, e);
            this.UIState !== t &&
              ((this.UIState = t), Object(yt.g)(this.name, yc.h));
          }
          handleUpdateContent(e) {
            this.setDataState((t) => {
              (t.version = e.version), (t.content = e.content);
            });
          }
          handleUpdateRenderer(e) {
            this.setUIState((t) => {
              for (const s in e) t[s] = e[s];
            });
          }
        };
      Object(B.b)(Nc.b)(
        (Uc = class extends Bc {
          hideTransferMessagesModal() {
            this.setUIState((e) => {
              e[Sc.j.TRANSFER_MODAL].isDisplayed = !1;
            });
          }
          getItem(e, t) {
            const s = super.getItem(e, t);
            if (!s) return;
            let i = {};
            if (e.key === Sc.f) {
              const { content: e = {} } = s;
              for (const t in e) {
                const s = e[t];
                if (s)
                  for (const e in s) {
                    var a;
                    i[t] || (i[t] = {}),
                      (i[t][e] =
                        null === (a = s[e]) || void 0 === a ? void 0 : a.pc);
                  }
              }
            } else i = s;
            return i;
          }
          showTransferMessagesModal() {
            this.setUIState((e) => {
              e[Sc.j.TRANSFER_MODAL].isDisplayed = !0;
            });
          }
        })
      );
      var Gc = Object(a.define)("forward-message"),
        zc = s("oAAg");
      zc.Pool;
      var xc,
        Vc,
        qc,
        Hc,
        Kc,
        $c = Object(a.define)("forward-message-pool");
      (xc = Object(a.singleton)(Gc)),
        (Vc = function (e, t) {
          return Object(a.inject)($c)(e, void 0, 0);
        }),
        (qc = Reflect.metadata("design:type", Function)),
        (Hc = Reflect.metadata("design:paramtypes", [Object])),
        Object(a.injectable)(
          (Kc =
            xc(
              (Kc =
                Vc(
                  (Kc =
                    qc(
                      (Kc =
                        Hc(
                          (Kc = class {
                            constructor(e) {
                              Object(i.a)(this, "_pool", void 0),
                                (this.pool = e);
                            }
                            forward(e, t) {
                              const s = this.buildTask();
                              this.pool.use(s);
                            }
                            buildTask() {
                              return async () => {};
                            }
                            get pool() {
                              return this._pool;
                            }
                            set pool(e) {
                              this._pool = e;
                            }
                          })
                        ) || Kc)
                    ) || Kc)
                ) || Kc)
            ) || Kc)
        );
      var Wc = Object(a.define)("pin-topic-message-loader");
      var Zc = Object(a.define)("pin-topic-storage"),
        Qc = Zc,
        Yc = s("UIHX"),
        Jc = s("0URt"),
        Xc = s("DRpF");
      function el(e) {
        return !(-1 === Object(Jc.g)().indexOf(e.msgType)) && !Object(Xc.a)(e);
      }
      var tl = s("3ZdV");
      var sl = s("YYsv");
      function il(e, t, s) {
        return s === e ? 1 : s < t ? 0 : -1;
      }
      function al(e) {
        const t = { needFetch: !1, reason: "" };
        if (null == e || null == e || !e.lastFetch)
          return (t.needFetch = !0), (t.reason = "empty"), t;
        const { lastFetch: s } = e,
          i = (function (e) {
            return to.a.isOverflowAtTime(e);
          })(s);
        if (i) return (t.needFetch = !0), (t.reason = "overflow"), t;
        const a = (function (e) {
          return Date.now() - e > Object(tl.e)();
        })(s);
        if (a) return (t.needFetch = !0), (t.reason = "expired"), t;
        const n = (function (e) {
          const t = r.a
            .getInstance()
            .getItemForCurrentUser(sl.g.FORCE_FETCH_MILESTONE);
          return !(!t || isNaN(+t)) && e < +t;
        })(s);
        return n ? ((t.needFetch = !0), (t.reason = "forcedByServer"), t) : t;
      }
      function nl(e) {
        const t = [];
        return (
          e.forEach((e) => {
            t.push({ topicId: e.id, topicType: e.type });
          }),
          t
        );
      }
      function rl(e) {
        var t;
        return (
          (null === (t = e.params) || void 0 === t
            ? void 0
            : t.client_msg_id) || ""
        );
      }
      function ol(e) {
        var t;
        return (
          (null === (t = e.params) || void 0 === t
            ? void 0
            : t.global_msg_id) || ""
        );
      }
      function cl(e, t, s) {
        let i = t;
        const { topics: a } = s;
        if (!Array.isArray(a)) return i;
        switch (e) {
          case Yc.a.ADD: {
            const { index: e } = s;
            i =
              null == e
                ? [...a, ...t]
                : [...t.slice(0, e), ...a, ...t.slice(e)];
            break;
          }
          case Yc.a.REMOVE: {
            const e = {};
            a.forEach((t) => {
              e[t.id] = t.type;
            }),
              (i = []),
              t.forEach((t) => {
                (!e.hasOwnProperty(t.id) ||
                  (e.hasOwnProperty(t.id) && e[t.id] !== t.type)) &&
                  i.push(t);
              });
            break;
          }
        }
        return i;
      }
      function ll(e) {
        const t = (e) => {
            if (!Array.isArray(e)) return e;
            const t = [];
            for (let s = 0; s < e.length; s++) {
              const i = e[s];
              i &&
                (null != i.id && (i.id = i.id.toString()),
                null != i.topicId && (i.topicId = i.topicId.toString()),
                null != i.type && (i.type = parseInt(i.type)),
                null != i.topicType && (i.topicType = parseInt(i.topicType)),
                t.push(i));
            }
            return t;
          },
          s = Object(p.a)({}, e);
        return (
          null != s.oldTopic && (s.oldTopic = t([s.oldTopic])[0]),
          null != s.topic && (s.topic = t([s.topic])[0]),
          null != s.topics && (s.topics = t(s.topics)),
          s
        );
      }
      function dl(e) {
        let t = {};
        if (!e.params) return e;
        try {
          t = JSON.parse(e.params);
        } catch (s) {
          return;
        }
        if (t.extra && t.extra.constructor === String)
          try {
            t.extra = JSON.parse(t.extra);
          } catch (s) {
            return;
          }
        return (e.params = t), e;
      }
      var hl,
        ul = function () {
          const e = {};
          return {
            clear: () => {
              for (const t in e) delete e[t];
            },
            get: (t) => e[t],
            getCache: () => e,
            set: (t, s) => {
              e[t] = s;
            },
            has: (t) => e.hasOwnProperty(t),
            remove: (t) => {
              delete e[t];
            },
          };
        };
      var gl =
        Object(a.injectable)()(
          (hl =
            (function (e, t) {
              return Object(a.inject)(Qc)(e, void 0, 0);
            })(
              (hl =
                Reflect.metadata(
                  "design:type",
                  Function
                )(
                  (hl =
                    Reflect.metadata("design:paramtypes", [Object])(
                      (hl = class {
                        constructor(e) {
                          (this.storage = e),
                            Object(i.a)(this, "clientMsgCache", void 0),
                            Object(i.a)(this, "globalMsgCache", void 0),
                            (this.globalMsgCache = ul()),
                            (this.clientMsgCache = ul());
                        }
                        clear(e) {
                          switch (e) {
                            case Yc.g.GLOBAL:
                              return void this.globalMsgCache.clear();
                            case Yc.g.CLIENT:
                              return void this.clientMsgCache.clear();
                            default:
                              return (
                                this.globalMsgCache.clear(),
                                void this.clientMsgCache.clear()
                              );
                          }
                        }
                        loadMessages(e) {
                          return new Promise((t, s) => {
                            (e && 0 !== e.length) || s("Invalid topics");
                            const i = e.length;
                            for (let a = 0; a < i; a++) {
                              const t = e[a];
                              if (!t) continue;
                              let i = ol(t);
                              if (i && "0" !== i)
                                this.getMessage(Yc.g.GLOBAL, i)
                                  .then()
                                  .catch((e) => {
                                    s(e);
                                  });
                              else {
                                let e = rl(t);
                                if (e) {
                                  let i = t.params && t.params.senderUid;
                                  this.getMessage(Yc.g.CLIENT, e, { userId: i })
                                    .then()
                                    .catch((e) => {
                                      s(e);
                                    });
                                }
                              }
                            }
                            t();
                          });
                        }
                        getMessageFromTopic(e) {
                          if (e.type !== Yc.i.MESSAGE || !e.params) return {};
                          let t = ol(e);
                          if (this.globalMsgCache && this.globalMsgCache.has(t))
                            return this.globalMsgCache.get(t) || {};
                          let s = rl(e);
                          return (
                            (this.clientMsgCache &&
                              this.clientMsgCache.has(s) &&
                              this.clientMsgCache.get(s)) ||
                            {}
                          );
                        }
                        removeMessages(e) {
                          Array.isArray(e) &&
                            e.forEach((e) => {
                              const t = ol(e),
                                s = rl(e);
                              this.globalMsgCache.remove(t),
                                this.clientMsgCache.remove(s);
                            });
                        }
                        getMessage(e, t, s = {}) {
                          return new Promise((i, a) => {
                            switch (e) {
                              case Yc.g.GLOBAL: {
                                let s = this.globalMsgCache.get(t);
                                s
                                  ? i(s)
                                  : this.storage
                                      .getMessagesByIds([t])
                                      .then((s) => {
                                        s
                                          ? (this.setMessage(e, t, s), i(s))
                                          : a("Not found");
                                      })
                                      .catch((e) => {
                                        a(e);
                                      });
                                break;
                              }
                              case Yc.g.CLIENT: {
                                const { userId: n } = s;
                                let r = this.clientMsgCache.get(t);
                                r
                                  ? i(r)
                                  : this.storage
                                      .getMessageByCliMsgId(t, {
                                        myUID: D.default.getUidMe(),
                                        userId: n,
                                      })
                                      .then((s) => {
                                        s
                                          ? (this.setMessage(e, t, s), i(s))
                                          : a("Not found");
                                      })
                                      .catch((e) => {
                                        a(e);
                                      });
                                break;
                              }
                              default:
                                a("Unknown");
                            }
                          });
                        }
                        setMessage(e, t, s) {
                          switch (e) {
                            case Yc.g.GLOBAL:
                              return void this.globalMsgCache.set(t, s);
                            case Yc.g.CLIENT:
                              return void this.clientMsgCache.set(t, s);
                            default:
                              return;
                          }
                        }
                      })
                    ) || hl)
                ) || hl)
            ) || hl)
        ) || hl;
      a.ModuleContainer.register(Wc, gl);
      var pl = Object(a.define)("pin-topic-data-repository"),
        ml = s("ZsEe"),
        vl = s("vSga");
      var fl = function () {
        const e = {},
          t = (t) => e[t] || null;
        return {
          clear: () => {
            for (const t in e) delete e[t];
          },
          get: t,
          getAll: () => e,
          getLastFetch: (e) => {
            var s;
            return (
              (null === (s = t(e)) || void 0 === s ? void 0 : s.lastFetch) || 0
            );
          },
          getLastModified: (e) => {
            var s;
            return (
              (null === (s = t(e)) || void 0 === s ? void 0 : s.lastModified) ||
              0
            );
          },
          getTopics: (e) => {
            var s;
            return (
              (null === (s = t(e)) || void 0 === s ? void 0 : s.topics) || []
            );
          },
          getVersion: (e) => {
            var s;
            return (
              (null === (s = t(e)) || void 0 === s ? void 0 : s.version) || 0
            );
          },
          has: (t) => !!e[t],
          remove: (t) => {
            delete e[t];
          },
          set: (t, s) => {
            e[t] = s;
          },
        };
      };
      var bl = function (e) {
        const t = [];
        let s = !1;
        const i = e || (() => {}),
          a = () => t.length,
          n = (e) => {
            s = e;
          },
          r = () => {
            if (s) return;
            if (!a()) return void i();
            const e = t.shift();
            e &&
              (n(!0),
              e()
                .then(() => {
                  n(!1), r();
                })
                .catch(() => {
                  n(!1), r();
                }));
          };
        return {
          enqueue: (e) => {
            t.push(e), r();
          },
          dequeue: r,
          getLength: a,
        };
      };
      var _l = function () {
          const e = [];
          let t;
          const s = () => e.length,
            i = (a, n) => {
              if ((n && (t = n), !s())) return t && t(a);
              const r = e.shift();
              r &&
                ((e, t) => {
                  const { callback: s } = e;
                  let a;
                  "function" == typeof s && (a = s(e.data, t)), i(a);
                })(r, a);
            };
          return {
            enqueue: (t) => {
              e.push(t);
            },
            dequeue: i,
            getLength: s,
          };
        },
        Sl = s("u+F0");
      var yl = Object(a.define)("pin-topic-request-handler");
      function Cl(e) {
        return new Promise((t) => {
          let s = 0,
            i = 0,
            a = {};
          for (let n in e)
            s++,
              e[n]
                .then((e) => {
                  (a[n] = e), i++, i === s && t(a);
                })
                .catch(() => {
                  (a[n] = null), i++, i === s && t(a);
                });
          0 === s && t({});
        });
      }
      function Il(e, t) {
        return Object(bc.f)(e, Number.isInteger(+t) ? t : 1 / 0);
      }
      var Ol,
        El = class {
          constructor(e, t) {
            (this.moduleName = e),
              (this.instanceNames = t),
              Object(i.a)(this, "instanceMap", new Map());
          }
          error(e, ...t) {
            const s = this.getLogger(e);
            void 0 !== s && s.zsymb(18, 10578, 3e4, ...t);
          }
          info(e, ...t) {
            const s = this.getLogger(e);
            void 0 !== s && s.zsymb(0, 10578, 30001, ...t);
          }
          getLogger(e) {
            if (
              this.instanceNames.includes(e) &&
              void 0 === this.instanceMap.get(e)
            ) {
              const t = this.LoggerFactory.createZLogger(Ut.b.pinTopic, [
                this.moduleName,
                e,
              ]);
              this.instanceMap.set(e, t);
            }
            return this.instanceMap.get(e);
          }
          get LoggerFactory() {
            return a.ModuleContainer.resolve(O.ZLoggerFactory);
          }
        };
      !(function (e) {
        (e.CONTROL = "control"),
          (e.CREATE = "create"),
          (e.FETCH = "fetch"),
          (e.LOAD = "load"),
          (e.REORDER = "reorder"),
          (e.UNPIN = "unpin");
      })(Ol || (Ol = {}));
      var Tl,
        Rl = class extends El {
          constructor() {
            super(Yc.f.DataRepository, [
              Ol.CONTROL,
              Ol.CREATE,
              Ol.FETCH,
              Ol.LOAD,
              Ol.REORDER,
              Ol.UNPIN,
            ]);
          }
          infoControl(...e) {
            this.logInfo(Ol.CONTROL, ...e);
          }
          infoCreate(...e) {
            this.logInfo(Ol.CREATE, ...e);
          }
          infoFetch(...e) {
            this.logInfo(Ol.FETCH, ...e);
          }
          infoLoad(...e) {
            this.logInfo(Ol.LOAD, ...e);
          }
          infoReorder(...e) {
            this.logInfo(Ol.REORDER, ...e);
          }
          infoUnpin(...e) {
            this.logInfo(Ol.UNPIN, ...e);
          }
          errorControl(...e) {
            this.logError(Ol.CONTROL, ...e);
          }
          errorCreate(...e) {
            this.logError(Ol.CREATE, ...e);
          }
          errorFetch(...e) {
            this.logError(Ol.FETCH, ...e);
          }
          errorLoad(...e) {
            this.logError(Ol.LOAD, ...e);
          }
          errorReorder(...e) {
            this.logError(Ol.REORDER, ...e);
          }
          errorUnpin(...e) {
            this.logError(Ol.UNPIN, ...e);
          }
          logInfo(e, ...t) {
            this.isEnableLog() && super.info(e, ...t);
          }
          logError(e, ...t) {
            this.isEnableLog() && super.error(e, ...t);
          }
          isEnableLog() {
            return Object(tl.h)();
          }
        };
      var Ll =
        Object(a.injectable)()(
          (Tl =
            (function (e, t) {
              return Object(a.inject)(Qc)(e, void 0, 0);
            })(
              (Tl =
                (function (e, t) {
                  return Object(a.inject)(yl)(e, void 0, 1);
                })(
                  (Tl =
                    Reflect.metadata(
                      "design:type",
                      Function
                    )(
                      (Tl =
                        Reflect.metadata("design:paramtypes", [Object, Object])(
                          (Tl = class {
                            constructor(e, t) {
                              (this.storage = e),
                                (this.fetcher = t),
                                Object(i.a)(this, "cache", void 0),
                                Object(i.a)(this, "eventQueue", void 0),
                                Object(i.a)(this, "logger", void 0),
                                Object(i.a)(
                                  this,
                                  "pendingWhenLoadQueue",
                                  void 0
                                ),
                                Object(i.a)(this, "requestID", void 0),
                                (this.cache = fl()),
                                (this.eventQueue = {}),
                                (this.pendingWhenLoadQueue = {}),
                                (this.logger = new Rl()),
                                (this.requestID = new ml.a());
                            }
                            clear() {
                              this.cache.clear();
                              for (const e in this.pendingWhenLoadQueue)
                                delete this.pendingWhenLoadQueue[e];
                              for (const e in this.eventQueue)
                                delete this.eventQueue[e];
                            }
                            clearPinTopicsForConversation(e, t = !1) {
                              this.cache.remove(e),
                                delete this.pendingWhenLoadQueue[e],
                                delete this.eventQueue[e],
                                this.Storage.clearTopics(e, t);
                            }
                            createPinTopic(e, t, s = {}) {
                              return new Promise((i, a) => {
                                const n = this.getRequestID();
                                this.Logger.infoCreate(n, `call cId:${e}`),
                                  this.loadDataFromCacheOrDB(e).then((r) => {
                                    const { checkEnableToCreate: o } = s || {};
                                    let c = null;
                                    if (o) {
                                      const { enable: s, oldTopic: i } = o(
                                        e,
                                        t,
                                        r
                                      );
                                      if (!s)
                                        return (
                                          this.Logger.infoCreate(
                                            n,
                                            `cId:${e} react limit`
                                          ),
                                          a({
                                            code: Sl.a.PINBOARD_OVER_MAXIMUM,
                                            message: "",
                                            data: { cache: r },
                                          })
                                        );
                                      i && (c = i);
                                    }
                                    const { version: l } = r;
                                    this.Logger.infoCreate(n, `cId:${e}`, l),
                                      this.Fetcher.createTopic(e, t, l)
                                        .then((t) => {
                                          this.Logger.infoCreate(
                                            n,
                                            `cId:${e}, create topic success`
                                          );
                                          let s = t.response.data;
                                          (s.oldVersion = l),
                                            c &&
                                              (s.oldTopic = {
                                                topicId: c.id,
                                                topicType: c.type,
                                              }),
                                            (s = ll(s)),
                                            this.enqueueEvent(
                                              e,
                                              this.addTopic.bind(
                                                this,
                                                e,
                                                s,
                                                (e) => i(e)
                                              )
                                            );
                                        })
                                        .catch((t) => {
                                          const s = t.error;
                                          (s.data = Object(p.a)(
                                            Object(p.a)(
                                              {},
                                              null == s ? void 0 : s.data
                                            ),
                                            {},
                                            { cache: r }
                                          )),
                                            this.Logger.errorCreate(
                                              n,
                                              `cId:${e}, create topic fail`,
                                              Il(t, Object(tl.b)())
                                            ),
                                            a(s);
                                        });
                                  });
                              });
                            }
                            getEntryPointPromotionalTooltipShowedStatus() {
                              return this.Storage.getEntryPointPromotionalTooltipShowedStatus();
                            }
                            handleReceivingEvent(e, t) {
                              return new Promise((s, i) => {
                                if (
                                  (this.Logger.infoControl(
                                    `call ${e}`,
                                    Il(t, Object(tl.b)())
                                  ),
                                  e === Yc.c.FORCE_SYNC)
                                ) {
                                  const { conversationIds: e } = t;
                                  if (!Array.isArray(e))
                                    return i(
                                      "Invalid conversationIds for force all"
                                    );
                                  if (0 === e.length)
                                    this.Storage.setForcedFetchMilestone(
                                      Date.now()
                                    );
                                  else
                                    for (let t = 0; t < e.length; t++) {
                                      var a;
                                      const n =
                                        null === (a = e[t]) || void 0 === a
                                          ? void 0
                                          : a.toString();
                                      n &&
                                        (this.clearPinTopicsForConversation(n),
                                        this.fetchTopics(n)
                                          .then((e) => {
                                            s(e);
                                          })
                                          .catch(i));
                                    }
                                } else {
                                  const { conversationId: a } = t;
                                  this.loadDataFromCacheOrDB(a).then((a) => {
                                    this.processEventControl(e, t, a, s, i);
                                  });
                                }
                              });
                            }
                            loadPinTopics(e, t) {
                              return new Promise((s, i) => {
                                e ||
                                  i({
                                    status: Yc.h.ERROR,
                                    error: {
                                      code: Sl.a.INVALID_PARAMETERS,
                                      message: "ConversationId not valid",
                                    },
                                  });
                                const a = this.getRequestID();
                                if (
                                  (this.Logger.infoLoad(a, `call cId:${e}`),
                                  t && t !== Yc.d.NONE)
                                )
                                  return (
                                    this.Logger.infoLoad(
                                      a,
                                      `force fetch cId:${e}`,
                                      t
                                    ),
                                    this.fetchTopics(e).then((e) => {
                                      s(e);
                                    })
                                  );
                                this.loadDataFromCacheOrDB(e).then((n) => {
                                  if (
                                    (this.Logger.infoLoad(a, `cId:${e}`),
                                    t === Yc.d.NONE)
                                  )
                                    return s(n);
                                  this.doCheckAndFetchData(n)
                                    .then((e) => {
                                      s(e);
                                    })
                                    .catch(i);
                                });
                              });
                            }
                            reorderPinTopics(e, t) {
                              return new Promise((s, i) => {
                                const a = this.getRequestID();
                                this.Logger.infoReorder(a, `call cId:${e}`),
                                  this.loadDataFromCacheOrDB(e).then((n) => {
                                    const { version: r } = n,
                                      o = nl(t);
                                    this.Logger.infoReorder(a, `cId:${e}`, r),
                                      this.Fetcher.reorderTopics(e, o, r)
                                        .then((i) => {
                                          this.Logger.infoReorder(
                                            a,
                                            `cId:${e}, reorder topic success`
                                          );
                                          let n = i.response.data;
                                          (n.oldVersion = r),
                                            (n.topics = t),
                                            (n = ll(n)),
                                            this.enqueueEvent(
                                              e,
                                              this.setTopics.bind(
                                                this,
                                                e,
                                                n,
                                                (e) => s(e)
                                              )
                                            );
                                        })
                                        .catch((t) => {
                                          this.Logger.errorReorder(
                                            a,
                                            `cId:${e}, reorder topic fail`,
                                            Il(t, Object(tl.b)())
                                          ),
                                            i(t.error);
                                        });
                                  });
                              });
                            }
                            setEntryPointPromotionalTooltipShowedStatus(e) {
                              this.Storage.setEntryPointPromotionalTooltipShowedStatus(
                                e
                              );
                            }
                            unpinTopics(e, t) {
                              return new Promise((s, i) => {
                                const a = this.getRequestID();
                                this.Logger.infoUnpin(a, `call cId:${e}`),
                                  this.loadDataFromCacheOrDB(e).then((n) => {
                                    const { version: r } = n,
                                      o = nl(t);
                                    this.Logger.infoUnpin(a, `cId:${e}`, r),
                                      this.Fetcher.unpinTopics(e, o, r)
                                        .then((i) => {
                                          this.Logger.infoUnpin(
                                            a,
                                            `cId:${e} unpin topic success`
                                          );
                                          let n = i.response.data;
                                          (n.oldVersion = r),
                                            (n.topics = t),
                                            (n = ll(n)),
                                            this.enqueueEvent(
                                              e,
                                              this.removeTopics.bind(
                                                this,
                                                e,
                                                n,
                                                (e) => s(e)
                                              )
                                            );
                                        })
                                        .catch((t) => {
                                          this.Logger.errorUnpin(
                                            a,
                                            `cId:${e}, unpin topic fail`,
                                            Il(t, Object(tl.b)())
                                          ),
                                            i(t.error);
                                        });
                                  });
                              });
                            }
                            setPendingQueue(e, t) {
                              t && !this.pendingWhenLoadQueue[e]
                                ? (this.pendingWhenLoadQueue[e] = _l())
                                : delete this.pendingWhenLoadQueue[e];
                            }
                            isInPending(e) {
                              return !!this.pendingWhenLoadQueue[e];
                            }
                            openPendingQueue(e) {
                              this.setPendingQueue(e, !0);
                            }
                            closePendingQueue(e) {
                              this.setPendingQueue(e, !1);
                            }
                            enqueuePending(e, t) {
                              this.pendingWhenLoadQueue[e] &&
                                this.pendingWhenLoadQueue[e].enqueue(t);
                            }
                            loadTopicsFromDB(e) {
                              this.openPendingQueue(e);
                              return new Promise((t) => {
                                const s = this.getRequestID();
                                this.Logger.infoLoad(s, `DB call cId:${e}`),
                                  this.Storage.loadTopics(e)
                                    .then((i) => {
                                      const a = this.handleLoadDBFinish(e, i);
                                      this.Logger.infoLoad(
                                        s,
                                        `DB cId:${e} success`
                                      ),
                                        t({
                                          status: Yc.h.SUCCESS,
                                          response: { data: a },
                                        });
                                    })
                                    .catch((i) => {
                                      const a = this.handleLoadDBFinish(
                                        e,
                                        null
                                      );
                                      this.Logger.errorLoad(
                                        s,
                                        `DB cId:${e} fail`,
                                        Il(
                                          null == i ? void 0 : i.error,
                                          Object(tl.b)()
                                        )
                                      ),
                                        t({
                                          status: Yc.h.ERROR,
                                          response: { data: a },
                                        });
                                    });
                              });
                            }
                            getRequestID() {
                              return this.requestID.next();
                            }
                            handleLoadDBFinish(e, t) {
                              var s;
                              let i;
                              var a;
                              t &&
                                (i = {
                                  conversationId: (a = t).conversationId,
                                  topics: a.topics,
                                  version: a.boardVersion,
                                  lastFetch: a.lastFetch,
                                  lastModified: Date.now(),
                                }),
                                (t &&
                                  (null === (s = i) || void 0 === s
                                    ? void 0
                                    : s.conversationId) === e) ||
                                  (i = (function (e) {
                                    return {
                                      conversationId: e,
                                      topics: [],
                                      version: 0,
                                      lastFetch: 0,
                                      lastModified: 0,
                                    };
                                  })(e));
                              let n = i;
                              if (!al(n).needFetch && this.isInPending(e)) {
                                const t = (e) => {
                                  e && (n = e);
                                };
                                this.pendingWhenLoadQueue[e].dequeue(i, t);
                              }
                              return this.closePendingQueue(e), n;
                            }
                            fetchTopics(e, t = 0) {
                              this.openPendingQueue(e);
                              return new Promise((s, i) => {
                                const a = this.getRequestID();
                                this.Logger.infoFetch(a, `call cId:${e}`, t),
                                  this.Fetcher.fetchTopics(e, t)
                                    .then((t) => {
                                      this.Logger.infoFetch(
                                        a,
                                        `cId:${e} success`
                                      ),
                                        this.closePendingQueue(e);
                                      const { response: i } = t,
                                        n = i.data.topics;
                                      for (let e = 0; e < n.length; e++)
                                        n[e] = dl(n[e]);
                                      this.loadExtraDataForTopics(n).then(
                                        (t) => {
                                          const a = {
                                            conversationId: e,
                                            topics: t,
                                            version: i.data.version,
                                            lastFetch: Date.now(),
                                            lastModified: Date.now(),
                                          };
                                          this.setToCache(e, a),
                                            this.setTopicsToDB(a),
                                            s(a);
                                        }
                                      );
                                    })
                                    .catch((t) => {
                                      this.Logger.errorFetch(
                                        a,
                                        `cId:${e} fail`,
                                        Il(t, Object(tl.b)())
                                      ),
                                        this.closePendingQueue(e);
                                    });
                              });
                            }
                            doCheckAndFetchData(e) {
                              return new Promise((t, s) => {
                                const i = al(e);
                                if (
                                  (this.Logger.infoFetch(
                                    `cId:${e.conversationId} needFetch:${i.needFetch} reason:${i.reason}`
                                  ),
                                  !i.needFetch)
                                )
                                  return t(e);
                                this.fetchTopics(e.conversationId)
                                  .then((s) => {
                                    t(s || e);
                                  })
                                  .catch(s);
                              });
                            }
                            getDataInPendingQueueAfterMutation(e, t) {
                              if (e.conversationId !== t.conversationId)
                                return t;
                              if (e.oldVersion != t.version) return t;
                              return {
                                topics: cl(e.type, t.topics, {
                                  index: e.index,
                                  topics: e.topics,
                                }),
                                version: e.version,
                                conversationId: e.conversationId,
                                lastModified: Date.now(),
                                lastFetch: t.lastFetch,
                              };
                            }
                            setToCache(e, t) {
                              return (
                                null == t.lastModified &&
                                  (t.lastModified = Date.now()),
                                this.cache.set(e, t),
                                t
                              );
                            }
                            addToCache(e, t, s = 0) {
                              const i = this.getCache(e),
                                { topic: a, version: n } = t;
                              let r = Date.now(),
                                o = [];
                              i
                                ? ((o = cl(Yc.a.ADD, i.topics, {
                                    topics: [a],
                                    index: s,
                                  })),
                                  (r = i.lastFetch))
                                : o.push(a),
                                t.lastFetch && (r = t.lastFetch);
                              const c = {
                                conversationId: e,
                                topics: o,
                                version: n,
                                lastModified: Date.now(),
                                lastFetch: r,
                              };
                              return this.setToCache(e, c);
                            }
                            removeInCache(e, t, s = 0) {
                              if (!this.cache.has(e)) return null;
                              const i = this.getCache(e),
                                { topics: a } = i;
                              if (t.topic)
                                for (let r = 0; r < a.length; r++) {
                                  const e = a[r];
                                  if (
                                    e.id === t.topic.id &&
                                    e.type === t.topic.type
                                  ) {
                                    a.splice(r, 1);
                                    break;
                                  }
                                }
                              else a.splice(s, 1);
                              const n = {
                                conversationId: e,
                                topics: a,
                                version: t.version,
                                lastModified: Date.now(),
                                lastFetch: i.lastFetch,
                              };
                              return this.setToCache(e, n);
                            }
                            enqueueEvent(e, t) {
                              if (!this.eventQueue[e]) {
                                const t = () => {
                                  delete this.eventQueue[e];
                                };
                                this.eventQueue[e] = bl(t);
                              }
                              this.eventQueue[e].enqueue(t);
                            }
                            addTopic(e, t, s) {
                              return new Promise((i, a) => {
                                if (this.isInPending(e)) {
                                  const s = {
                                    data: {
                                      type: Yc.a.ADD,
                                      conversationId: e,
                                      oldTopic: t.oldTopic,
                                      topics: [t.topic],
                                      version: t.version,
                                      oldVersion: t.oldVersion,
                                      index: t.index,
                                    },
                                    callback:
                                      this.getDataInPendingQueueAfterMutation,
                                  };
                                  return this.enqueuePending(e, s), i();
                                }
                                const n = (a) => {
                                  const { oldVersion: n, version: r } = t,
                                    o = il(n, r, a.version);
                                  if (
                                    (this.Logger.infoCreate(
                                      `add call cId:${e} actCode:${o}`,
                                      n,
                                      r,
                                      a.version
                                    ),
                                    1 === o)
                                  ) {
                                    const {
                                      oldTopic: a,
                                      index: n,
                                      topic: o,
                                    } = t;
                                    a &&
                                      a.topicId &&
                                      this.removeInCache(e, {
                                        topic: {
                                          id: a.topicId,
                                          type: a.topicType,
                                        },
                                        version: r,
                                      }),
                                      dl(o),
                                      this.loadExtraDataForTopics([o])
                                        .then((a) => {
                                          const r = {
                                              topic: a[0],
                                              version: t.version,
                                            },
                                            o = this.addToCache(e, r, n);
                                          this.setTopicsToDB(o),
                                            i(),
                                            s && s(this.getCache(e));
                                        })
                                        .catch(() => {
                                          i();
                                        });
                                  } else
                                    0 === o
                                      ? this.fetchTopics(e)
                                          .then((e) => {
                                            s && s(e), i();
                                          })
                                          .catch(() => {
                                            s && s(this.getCache(e)), i();
                                          })
                                      : i();
                                };
                                this.loadDataFromCacheOrDB(e).then((e) => {
                                  n(e);
                                });
                              });
                            }
                            removeTopics(e, t, s) {
                              return new Promise((i) => {
                                if (this.isInPending(e)) {
                                  const s = {
                                    data: {
                                      type: Yc.a.REMOVE,
                                      conversationId: e,
                                      topics: t.topics,
                                      version: t.version,
                                      oldVersion: t.oldVersion,
                                    },
                                    callback:
                                      this.getDataInPendingQueueAfterMutation,
                                  };
                                  return this.enqueuePending(e, s), i();
                                }
                                const a = (a) => {
                                  const { oldVersion: n, version: r } = t,
                                    o = il(n, r, a.version);
                                  if (
                                    (this.Logger.infoUnpin(
                                      `remove call cId:${e} actCode:${o}`,
                                      n,
                                      r,
                                      a.version
                                    ),
                                    1 === o)
                                  ) {
                                    const { topics: n } = t;
                                    let o = a;
                                    for (let t = 0; t < n.length; t++)
                                      o = this.removeInCache(e, {
                                        topic: n[t],
                                        version: r,
                                      });
                                    return (
                                      this.setTopicsToDB(o),
                                      s && s(this.getCache(e)),
                                      i()
                                    );
                                  }
                                  0 === o
                                    ? this.fetchTopics(e)
                                        .then((e) => {
                                          s && s(e), i();
                                        })
                                        .catch(() => {
                                          s && s(this.getCache(e)), i();
                                        })
                                    : i();
                                };
                                this.loadDataFromCacheOrDB(e).then((e) => {
                                  a(e);
                                });
                              });
                            }
                            setTopics(e, t, s) {
                              return new Promise((i) => {
                                if (this.isInPending(e)) {
                                  const s = {
                                    data: {
                                      type: Yc.a.REORDER,
                                      conversationId: e,
                                      topics: t.topics,
                                      version: t.version,
                                      oldVersion: t.oldVersion,
                                    },
                                    callback:
                                      this.getDataInPendingQueueAfterMutation,
                                  };
                                  return this.enqueuePending(e, s), i();
                                }
                                const a = (a) => {
                                  const { oldVersion: n, version: r } = t,
                                    o = il(n, r, a.version);
                                  if (
                                    (this.Logger.infoReorder(
                                      `set call cId:${e} actCode:${o}`,
                                      n,
                                      r,
                                      a.version
                                    ),
                                    1 === o)
                                  ) {
                                    const n = a.topics,
                                      r = [];
                                    for (let e = 0; e < t.topics.length; e++) {
                                      const s = t.topics[e],
                                        i = n.find(
                                          (e) =>
                                            e.id === s.id && e.type === s.type
                                        );
                                      i && r.push(i);
                                    }
                                    const o = {
                                      conversationId: e,
                                      topics: r,
                                      version: t.version,
                                      lastModified: Date.now(),
                                      lastFetch:
                                        (null == a ? void 0 : a.lastFetch) || 0,
                                    };
                                    return (
                                      this.setToCache(e, o),
                                      this.setTopicsToDB(o),
                                      s && s(this.getCache(e)),
                                      i()
                                    );
                                  }
                                  0 === o
                                    ? this.fetchTopics(e)
                                        .then((e) => {
                                          s && s(e), i();
                                        })
                                        .catch(() => {
                                          s && s(this.getCache(e)), i();
                                        })
                                    : i();
                                };
                                this.loadDataFromCacheOrDB(e).then((e) => {
                                  a(e);
                                });
                              });
                            }
                            loadDataFromCacheOrDB(e) {
                              return new Promise((t) => {
                                const s = this.getCache(e);
                                s
                                  ? t(s)
                                  : this.loadTopicsFromDB(e).then((s) => {
                                      const i = s.response.data;
                                      this.setToCache(e, i), t(i);
                                    });
                              });
                            }
                            setTopicsToDB(e) {
                              return new Promise((t, s) => {
                                const i = {
                                  conversationId: e.conversationId,
                                  boardVersion: e.version,
                                  topics: e.topics,
                                  lastFetch: e.lastFetch,
                                };
                                this.Storage.setTopics(i).then(t).catch(s);
                              });
                            }
                            processEventControl(e, t, s, i, a) {
                              const { conversationId: n } = t;
                              let r = {
                                oldVersion: t.oldVersion,
                                version: t.version,
                              };
                              const o = ll(t);
                              switch (e) {
                                case Yc.c.CREATE:
                                  (r = Object(p.a)(
                                    Object(p.a)({}, r),
                                    {},
                                    {
                                      oldTopic: o.oldTopic,
                                      topic: o.topic,
                                      index: 0,
                                    }
                                  )),
                                    this.enqueueEvent(
                                      n,
                                      this.addTopic.bind(this, n, r, (e) =>
                                        i(e)
                                      )
                                    );
                                  break;
                                case Yc.c.UNPIN: {
                                  const e = o.topic,
                                    t = [];
                                  e &&
                                    null != e.topicId &&
                                    null != e.topicType &&
                                    t.push({
                                      id: e.topicId,
                                      type: e.topicType,
                                    }),
                                    (r = Object(p.a)(
                                      Object(p.a)({}, r),
                                      {},
                                      { topics: t }
                                    )),
                                    this.enqueueEvent(
                                      n,
                                      this.removeTopics.bind(this, n, r, (e) =>
                                        i(e)
                                      )
                                    );
                                  break;
                                }
                                case Yc.c.REORDER: {
                                  var c;
                                  const e = [],
                                    t =
                                      (null === (c = o.topics) || void 0 === c
                                        ? void 0
                                        : c.length) || 0;
                                  for (let i = 0; i < t; i++) {
                                    var l;
                                    const t =
                                      null === (l = o.topics) || void 0 === l
                                        ? void 0
                                        : l[i];
                                    if (
                                      t &&
                                      null != t.topicId &&
                                      null != t.topicType
                                    ) {
                                      const i = s.topics.find(
                                        (e) =>
                                          e.id === t.topicId &&
                                          e.type === t.topicType
                                      );
                                      i && e.push(i);
                                    }
                                  }
                                  (r = Object(p.a)(
                                    Object(p.a)({}, r),
                                    {},
                                    { topics: e }
                                  )),
                                    this.enqueueEvent(
                                      n,
                                      this.setTopics.bind(this, n, r, (e) =>
                                        i(e)
                                      )
                                    );
                                  break;
                                }
                              }
                            }
                            loadStickerThumb(e) {
                              const t = (e) => `${e.id}_${e.type}`;
                              return new Promise((s) => {
                                const i = {};
                                for (let o = 0; o < e.length; o++) {
                                  var a, n;
                                  const s = e[o];
                                  if (
                                    (null === (a = s.params) || void 0 === a
                                      ? void 0
                                      : a.msg_type) === w.MSG_STICKER ||
                                    (null === (n = s.params) || void 0 === n
                                      ? void 0
                                      : n.msg_type) === w.CLI_MSG_TYPE_STICKER
                                  ) {
                                    var r;
                                    const e =
                                      null === (r = s.params) || void 0 === r
                                        ? void 0
                                        : r.extra;
                                    e &&
                                      null != e.catId &&
                                      null != e.id &&
                                      (i[t(s)] =
                                        this.StickerManager.getStickerIfNotExist(
                                          e.catId,
                                          e.id
                                        ));
                                  }
                                }
                                Object.keys(i).length > 0
                                  ? Cl(i).then((i) => {
                                      for (let s = 0; s < e.length; s++) {
                                        const a = e[s],
                                          n = i[t(a)];
                                        n &&
                                          n.id ===
                                            parseInt(a.params.extra.id) &&
                                          n.cateId ===
                                            parseInt(a.params.extra.catId) &&
                                          ((a.params.thumb =
                                            n.stickerUrl || ""),
                                          (e[s] = a));
                                      }
                                      s(e);
                                    })
                                  : s(e);
                              });
                            }
                            loadExtraDataForTopics(e) {
                              return new Promise((t) => {
                                this.loadStickerThumb(e).then((e) => {
                                  t(e);
                                });
                              });
                            }
                            getCache(e) {
                              return this.cache.get(e);
                            }
                            get Fetcher() {
                              return this.fetcher;
                            }
                            get Logger() {
                              return this.logger;
                            }
                            get StickerManager() {
                              return vl.g;
                            }
                            get Storage() {
                              return this.storage;
                            }
                          })
                        ) || Tl)
                    ) || Tl)
                ) || Tl)
            ) || Tl)
        ) || Tl;
      a.ModuleContainer.register(pl, Ll);
      var Ml = class {
        createOneOnOneTopic(e = "", t, s = 0, i = "vi") {
          let a = { conversationId: e, topic: t, version: s, lang: i };
          b.default.logCoreInfo("[PinTopic] - createOneOnOneTopic params: ", a);
          const n =
            v.b.getFriendBoardDomain() +
            "/api/friendboard/create?" +
            this.getCommonParams() +
            "&params=" +
            this.getEncodedParams(a);
          return this.getRequest(n, null, 12067);
        }
        getListOneOnOnePinTopics(e = "", t = 0) {
          let s = { conversationId: e, version: t };
          b.default.logCoreInfo(
            "[PinTopic] - getListOneOnOnePinTopics params: ",
            s
          );
          const i =
            v.b.getFriendBoardDomain() +
            "/api/friendboard/list?" +
            an.default._getCommonParams() +
            "&params=" +
            this.getEncodedParams(s);
          return this.getRequest(i, null, 12065);
        }
        reorderOneOnOnePinTopics(e = "", t, s = 0, i = "vi") {
          let a = { conversationId: e, topics: t, version: s, lang: i };
          b.default.logCoreInfo(
            "[PinTopic] - reorderOneOnOnePinTopics params: ",
            a
          );
          const n =
            v.b.getFriendBoardDomain() +
            "/api/friendboard/reorder?" +
            this.getCommonParams() +
            "&params=" +
            this.getEncodedParams(a);
          return this.getRequest(n, null, 12068);
        }
        unpinOneOnOneTopics(e = "", t, s = 0, i = "vi") {
          let a = { conversationId: e, topics: t, version: s, lang: i };
          b.default.logCoreInfo("[PinTopic] - unpinOneOnOneTopics params: ", a);
          const n =
            v.b.getFriendBoardDomain() +
            "/api/friendboard/multi_unpin?" +
            this.getCommonParams() +
            "&params=" +
            this.getEncodedParams(a);
          return this.getRequest(n, null, 12069);
        }
        getCommonParams() {
          return an.default._getCommonParams();
        }
        getEncodedParams(e) {
          return an.default.getEncodedParams(e);
        }
        getRequest(e, t, s, i, a, n, r, o, c) {
          return an.default._get(e, t, s, i, a, n, r, o, c);
        }
      };
      var Fl,
        wl = function () {
          let e;
          function t() {
            return e || (e = new Ml()), e;
          }
          const s = (e) =>
            new Promise((t, s) => {
              e.then(tn.a).then(t).catch(s);
            });
          return {
            createOneOnOneTopic: (e, i, a = 0) => {
              const n = Object(p.a)({}, i),
                { params: r } = n;
              r &&
                r.extra &&
                r.extra.constructor === Object &&
                (r.extra = JSON.stringify(r.extra)),
                r && (n.params = JSON.stringify(r)),
                null == n.src && (n.src = -1),
                null == n.pinAct && (n.pinAct = 1);
              const o = jt.default.getCurrentLanguageName();
              return s(t().createOneOnOneTopic(e, n, a, o));
            },
            getListOneOnOnePinTopics: (e, i = 0) =>
              s(t().getListOneOnOnePinTopics(e, i)),
            reorderOneOnOnePinTopics: (e, i, a = 0) => {
              const n = jt.default.getCurrentLanguageName();
              return s(t().reorderOneOnOnePinTopics(e, i, a, n));
            },
            unpinOneOnOneTopics: (e, i, a = 0) => {
              const n = jt.default.getCurrentLanguageName();
              return s(t().unpinOneOnOneTopics(e, i, a, n));
            },
          };
        };
      !(function (e) {
        (e.CREATE = "create"),
          (e.FETCH = "fetch"),
          (e.REORDER = "reorder"),
          (e.UNPIN = "unpin");
      })(Fl || (Fl = {}));
      var Dl = class extends El {
        constructor() {
          super(Yc.f.Network, [Fl.CREATE, Fl.FETCH, Fl.REORDER, Fl.UNPIN]);
        }
        infoCreate(...e) {
          this.logInfo(Fl.CREATE, ...e);
        }
        infoFetch(...e) {
          this.logInfo(Fl.FETCH, ...e);
        }
        infoReorder(...e) {
          this.logInfo(Fl.REORDER, ...e);
        }
        infoUnpin(...e) {
          this.logInfo(Fl.UNPIN, ...e);
        }
        errorCreate(...e) {
          this.logError(Fl.CREATE, ...e);
        }
        errorFetch(...e) {
          this.logError(Fl.FETCH, ...e);
        }
        errorReorder(...e) {
          this.logError(Fl.REORDER, ...e);
        }
        errorUnpin(...e) {
          this.logError(Fl.UNPIN, ...e);
        }
        logInfo(e, ...t) {
          this.isEnableLog() && super.info(e, ...t);
        }
        logError(e, ...t) {
          this.isEnableLog() && super.error(e, ...t);
        }
        isEnableLog() {
          return Object(tl.i)();
        }
      };
      var jl,
        Al = class {
          constructor() {
            Object(i.a)(this, "apiClient", void 0),
              Object(i.a)(this, "logger", void 0),
              Object(i.a)(this, "requestID", void 0),
              (this.apiClient = wl()),
              (this.logger = new Dl()),
              (this.requestID = new ml.a());
          }
          async fetchTopics(e, t = 0) {
            const s = this.getRequestId();
            this.Logger.infoFetch(s, `call cId:${e}`, t);
            try {
              const i = await this.apiClient.getListOneOnOnePinTopics(e, t);
              return (
                this.Logger.infoFetch(s, `cId:${e} success`, i.version),
                {
                  status: Yc.h.SUCCESS,
                  response: { data: { topics: i.data, version: i.version } },
                }
              );
            } catch (i) {
              return (
                this.Logger.errorFetch(
                  s,
                  `cId:${e} fail`,
                  Il(i, Object(tl.d)())
                ),
                Promise.reject({
                  status: Yc.h.ERROR,
                  error: {
                    code: i.code || i.error_code,
                    message: i.error_message,
                  },
                })
              );
            }
          }
          async createTopic(e, t, s = 0) {
            const i = this.getRequestId();
            this.Logger.infoCreate(i, `call cId:${e}`, s);
            try {
              const a = await this.apiClient.createOneOnOneTopic(e, t, s);
              return (
                this.Logger.infoCreate(i, `cId:${e} success`, a.version),
                {
                  status: Yc.h.SUCCESS,
                  response: { data: { topic: a.data, version: a.version } },
                }
              );
            } catch (a) {
              return (
                this.Logger.errorCreate(
                  i,
                  `cId:${e} fail`,
                  Il(a, Object(tl.d)())
                ),
                Promise.reject({
                  status: Yc.h.ERROR,
                  error: {
                    code: a.code || a.error_code,
                    message: a.error_message,
                  },
                })
              );
            }
          }
          async unpinTopics(e, t, s = 0) {
            const i = this.getRequestId();
            this.Logger.infoUnpin(i, `call cId:${e}`, s);
            try {
              const a = await this.apiClient.unpinOneOnOneTopics(e, t, s);
              return (
                this.Logger.infoUnpin(i, `cId:${e} success`, a.version),
                { status: Yc.h.SUCCESS, response: { data: a } }
              );
            } catch (a) {
              return (
                this.Logger.errorUnpin(
                  i,
                  `cId:${e} fail`,
                  Il(a, Object(tl.d)())
                ),
                Promise.reject({
                  status: Yc.h.ERROR,
                  error: {
                    code: a.code || a.error_code,
                    message: a.error_message,
                  },
                })
              );
            }
          }
          async reorderTopics(e, t, s = 0) {
            const i = this.getRequestId();
            this.Logger.infoReorder(i, `call cId:${e}`, s);
            try {
              const a = await this.apiClient.reorderOneOnOnePinTopics(e, t, s);
              return (
                this.Logger.infoReorder(i, `cId:${e} success`, a.version),
                { status: Yc.h.SUCCESS, response: { data: a } }
              );
            } catch (a) {
              return (
                this.Logger.errorUnpin(
                  i,
                  `cId:${e} fail`,
                  Il(a, Object(tl.d)())
                ),
                Promise.reject({
                  status: Yc.h.ERROR,
                  error: {
                    code: a.code || a.error_code,
                    message: a.error_message,
                  },
                })
              );
            }
          }
          getRequestId() {
            return this.requestID.next();
          }
          get Logger() {
            return this.logger;
          }
        };
      a.ModuleContainer.register(yl, Al);
      var Nl =
        Object(a.singleton)(Zc)(
          (jl = class {
            constructor() {
              Object(i.a)(this, "_storage", void 0);
            }
            async clearTopics(e, t = !1) {
              try {
                let s;
                if (t) s = this.storage.removeConversationTopics(e);
                else {
                  const t = { conversationId: e, topics: [] },
                    i = ["topics"];
                  s = this.storage.updateGroupTopic(t, i);
                }
                return await s, e;
              } catch (s) {
                return Promise.reject(s);
              }
            }
            async loadTopics(e) {
              try {
                return (await this.loadTopicsFromDB(e)).response.data;
              } catch (t) {
                return Promise.reject(t);
              }
            }
            async setTopics(e) {
              try {
                return await this.setTopicsToDB(e);
              } catch (t) {
                return Promise.reject(t);
              }
            }
            getEntryPointPromotionalTooltipShowedStatus() {
              const e = r.a
                .getInstance()
                .getItemForCurrentUser(
                  Yc.e.ONE_ON_ONE_ENTRY_POINT_PROMOTIONAL_TOOLTIP_SHOWED
                );
              if (null === e) return null;
              try {
                return JSON.parse(e);
              } catch (t) {
                return !1;
              }
            }
            async getMessagesByIds(e) {
              try {
                const t = await this.storage.getMessagesByIds(e);
                let s;
                e && e.length > 0 && (s = e[0]);
                let i = null;
                return s && (i = t[s]), i || Promise.reject("Not found");
              } catch (t) {
                return Promise.reject(t);
              }
            }
            async getMessageByCliMsgId(e, t = {}) {
              try {
                const { myUID: s, userId: i } = t;
                if (i) {
                  let t = i;
                  s == i && (t = "0");
                  const a = await this.storage.getMessageByCliMsgIdOwnerId(
                    e,
                    t
                  );
                  return a || Promise.reject("Not found");
                }
                const a = await this.storage.getMessageByCliMsgId(e);
                if (!a || !a.length) return Promise.reject("Not found");
                a.length;
                const n = a && a[0];
                return n || Promise.reject("Not found");
              } catch (s) {
                return Promise.reject(s);
              }
            }
            setEntryPointPromotionalTooltipShowedStatus(e) {
              r.a
                .getInstance()
                .setItemForCurrentUser(
                  Yc.e.ONE_ON_ONE_ENTRY_POINT_PROMOTIONAL_TOOLTIP_SHOWED,
                  JSON.stringify(e)
                );
            }
            setForcedFetchMilestone(e) {
              r.a
                .getInstance()
                .setItemForCurrentUser(
                  Yc.e.FORCE_FETCH_MILESTONE,
                  e.toString()
                );
            }
            async loadTopicsFromDB(e) {
              try {
                const t = await this.storage.getGroupTopic(e);
                return { status: Yc.h.SUCCESS, response: { data: t } };
              } catch (t) {
                return Promise.reject({
                  status: Yc.h.ERROR,
                  error: {
                    code: null == t ? void 0 : t.code,
                    message:
                      (null == t ? void 0 : t.message) ||
                      (null == t ? void 0 : t.error_message),
                    data: t,
                  },
                });
              }
            }
            async setTopicsToDB(e) {
              return await this.storage.setGroupTopic(e);
            }
            get storage() {
              return (
                this._storage || (this._storage = s("XS0u").default),
                this._storage
              );
            }
          })
        ) || jl;
      a.ModuleContainer.register(Qc, Nl);
      var Pl = s("+3r3");
      var kl,
        Ul = Object(a.define)("pin-topic-one-on-one-controller");
      !(function (e) {
        (e.CONTROL = "control"),
          (e.CREATE = "create"),
          (e.LOAD = "load"),
          (e.REORDER = "reorder"),
          (e.UNPIN = "unpin");
      })(kl || (kl = {}));
      var Bl,
        Gl = class extends El {
          constructor() {
            super(Yc.f.OneOnOneController, [
              kl.CONTROL,
              kl.CREATE,
              kl.LOAD,
              kl.REORDER,
              kl.UNPIN,
            ]);
          }
          infoControl(...e) {
            this.logInfo(kl.CONTROL, ...e);
          }
          infoCreate(...e) {
            this.logInfo(kl.CREATE, ...e);
          }
          infoLoad(...e) {
            this.logInfo(kl.LOAD, ...e);
          }
          infoReorder(...e) {
            this.logInfo(kl.REORDER, ...e);
          }
          infoUnpin(...e) {
            this.logInfo(kl.UNPIN, ...e);
          }
          errorControl(...e) {
            this.logError(kl.CONTROL, ...e);
          }
          errorCreate(...e) {
            this.logError(kl.CREATE, ...e);
          }
          errorLoad(...e) {
            this.logError(kl.LOAD, ...e);
          }
          errorReorder(...e) {
            this.logError(kl.REORDER, ...e);
          }
          errorUnpin(...e) {
            this.logError(kl.UNPIN, ...e);
          }
          logInfo(e, ...t) {
            this.isEnableLog() && super.info(e, ...t);
          }
          logError(e, ...t) {
            this.isEnableLog() && super.error(e, ...t);
          }
          isEnableLog() {
            return Object(tl.g)();
          }
        };
      Object(a.injectable)()(
        (Bl =
          Object(a.singleton)(Ul)(
            (Bl =
              (function (e, t) {
                return Object(a.inject)(pl)(e, void 0, 0);
              })(
                (Bl =
                  (function (e, t) {
                    return Object(a.inject)(Wc)(e, void 0, 1);
                  })(
                    (Bl =
                      Reflect.metadata(
                        "design:type",
                        Function
                      )(
                        (Bl =
                          Reflect.metadata("design:paramtypes", [
                            Object,
                            Object,
                          ])(
                            (Bl = class {
                              constructor(e, t) {
                                (this.dataRepository = e),
                                  (this.messageLoader = t),
                                  Object(i.a)(this, "events", {}),
                                  Object(i.a)(this, "logger", void 0),
                                  Object(i.a)(this, "requestID", void 0),
                                  this.initialize(),
                                  (this.logger = new Gl()),
                                  (this.requestID = new ml.a());
                              }
                              getPinTopic(e, t, s) {
                                return new Promise((i, a) => {
                                  this.loadPinTopics(e)
                                    .then((e) => {
                                      const { topics: n } = e,
                                        r = n.find(
                                          (e) =>
                                            e.id ===
                                              (null == t
                                                ? void 0
                                                : t.toString()) && e.type === s
                                        );
                                      r ? i(r) : a(null);
                                    })
                                    .catch(a);
                                });
                              }
                              getMessageFromTopic(e) {
                                return this.MessageLoader.getMessageFromTopic(
                                  e
                                );
                              }
                              displayEntryPointPromotionalTooltip() {
                                this.DataRepository.setEntryPointPromotionalTooltipShowedStatus(
                                  !0
                                );
                              }
                              isDisplayedEntryPointPromotionalTooltip() {
                                if (!Object(tl.l)()) return !0;
                                const e =
                                  this.DataRepository.getEntryPointPromotionalTooltipShowedStatus();
                                return null !== e && Boolean(e);
                              }
                              async loadPinTopics(e, t = !1) {
                                if (!Object(tl.k)())
                                  return Promise.reject({
                                    code: sl.c.OFF_FEATURE,
                                    message: "",
                                  });
                                const s = this.getRequestID();
                                try {
                                  var i;
                                  let a;
                                  t && (a = sl.e.OPEN_DIALOG),
                                    this.Logger.infoLoad(s, `call cId:${e}`, t);
                                  const n =
                                    await this.DataRepository.loadPinTopics(
                                      e,
                                      a
                                    );
                                  return (
                                    this.Logger.infoLoad(
                                      s,
                                      `res cId:${e}`,
                                      !!n,
                                      n.conversationId,
                                      null === (i = n.topics) || void 0 === i
                                        ? void 0
                                        : i.length
                                    ),
                                    {
                                      conversationId: n.conversationId,
                                      topics: n.topics,
                                    }
                                  );
                                } catch (a) {
                                  return (
                                    this.Logger.errorLoad(
                                      s,
                                      `err cId:${e}`,
                                      Il(a, Object(tl.a)())
                                    ),
                                    Promise.reject(a)
                                  );
                                }
                              }
                              addEventListener(e, t) {
                                this.events[e] || (this.events[e] = []),
                                  this.events[e].push(t);
                              }
                              removeEventListener(e, t) {
                                const s = this.events[e],
                                  i = (this.events[e] || []).length;
                                for (let a = 0; a < i; a++)
                                  if (s[a] === t) {
                                    s.splice(a, 1);
                                    break;
                                  }
                                0 === s.length && delete this.events[e];
                              }
                              removeEventListeners(e) {
                                delete this.events[e];
                              }
                              handleEventControl(e) {
                                if (!Object(tl.k)()) return;
                                const t = this.getRequestID();
                                this.Logger.infoControl(
                                  t,
                                  "recv",
                                  e.act,
                                  Il(e.data, Object(tl.a)())
                                ),
                                  this.DataRepository.handleReceivingEvent(
                                    e.act,
                                    e.data
                                  )
                                    .then((s) => {
                                      if (
                                        (this.Logger.infoControl(
                                          t,
                                          "res",
                                          e.act,
                                          Il(s, Object(tl.a)())
                                        ),
                                        e.act === sl.d.UNPIN)
                                      ) {
                                        let t = [];
                                        if (
                                          (Array.isArray(e.data.topics) &&
                                            e.data.topics.forEach((e) => {
                                              s.topics.find(
                                                (t) =>
                                                  t.id === e.topicId &&
                                                  t.type === e.topicType
                                              ) ||
                                                t.push({
                                                  topicId: e.topicId,
                                                  topicType: e.topicType,
                                                });
                                            }),
                                          t.length > 0)
                                        ) {
                                          const s = {};
                                          t.forEach((t) => {
                                            s[`${t.topicId}_${t.topicType}`] =
                                              this.getPinTopic(
                                                e.data.conversationId,
                                                t.topicId,
                                                t.topicType
                                              );
                                          }),
                                            Cl(s).then((e) => {
                                              const t = Object.keys(e).map(
                                                (t) => e[t]
                                              );
                                              this.MessageLoader.removeMessages(
                                                t
                                              );
                                            });
                                        }
                                      }
                                      this.MessageLoader.loadMessages(s.topics),
                                        this.notifyChangeEvent(
                                          s.conversationId,
                                          s.topics
                                        );
                                    })
                                    .catch((s) => {
                                      this.Logger.errorControl(
                                        t,
                                        "err",
                                        e.act,
                                        Il(s, Object(tl.a)())
                                      );
                                    });
                              }
                              async createPinTopic(e, t, s = 2) {
                                if (!Object(tl.k)())
                                  return Promise.reject({
                                    code: sl.c.OFF_FEATURE,
                                    message: "",
                                  });
                                const i = this.getRequestID();
                                try {
                                  var a;
                                  if (
                                    (this.Logger.infoCreate(
                                      i,
                                      `call cId:${e}`,
                                      !!t,
                                      s
                                    ),
                                    !this.isValidNetwork())
                                  )
                                    return Promise.reject({
                                      code: sl.c.NO_NETWORK,
                                      message: "STR_CHECK_NET",
                                    });
                                  const n = await this.retryable(s, () =>
                                    this.processCreatePinTopic(e, t, s)
                                  );
                                  return (
                                    this.Logger.infoCreate(
                                      i,
                                      `res cId:${e}`,
                                      !!n,
                                      null == n ? void 0 : n.conversationId,
                                      null == n ||
                                        null === (a = n.topics) ||
                                        void 0 === a
                                        ? void 0
                                        : a.length
                                    ),
                                    n
                                  );
                                } catch (n) {
                                  return (
                                    this.Logger.errorCreate(
                                      i,
                                      `err cId:${e}`,
                                      Il(n, Object(tl.a)())
                                    ),
                                    Promise.reject(n)
                                  );
                                }
                              }
                              async reorderPinTopics(e, t, s = 2) {
                                if (!Object(tl.k)())
                                  return Promise.reject({
                                    code: sl.c.OFF_FEATURE,
                                    message: "",
                                  });
                                const i = this.getRequestID();
                                try {
                                  var a;
                                  if (
                                    (this.Logger.infoReorder(
                                      i,
                                      `call cId:${e}`,
                                      t.length,
                                      s
                                    ),
                                    !this.isValidNetwork())
                                  )
                                    return Promise.reject({
                                      code: sl.c.NO_NETWORK,
                                      message: "STR_CHECK_NET",
                                    });
                                  const n = await this.retryable(s, () =>
                                    this.processReorderPinTopics(e, t, s)
                                  );
                                  return (
                                    this.Logger.infoReorder(
                                      i,
                                      `res cId:${e}`,
                                      !!n,
                                      null == n ? void 0 : n.conversationId,
                                      null == n ||
                                        null === (a = n.topics) ||
                                        void 0 === a
                                        ? void 0
                                        : a.length
                                    ),
                                    n
                                  );
                                } catch (n) {
                                  return (
                                    this.Logger.errorReorder(
                                      i,
                                      `err cId:${e}`,
                                      Il(n, Object(tl.a)())
                                    ),
                                    Promise.reject(n)
                                  );
                                }
                              }
                              async unpinPinTopics(e, t, s = 2) {
                                if (!Object(tl.k)())
                                  return Promise.reject({
                                    code: sl.c.OFF_FEATURE,
                                    message: "",
                                  });
                                const i = this.getRequestID();
                                try {
                                  var a;
                                  if (
                                    (this.Logger.infoUnpin(
                                      i,
                                      `call cId:${e}`,
                                      t.length,
                                      s
                                    ),
                                    !this.isValidNetwork())
                                  )
                                    return Promise.reject({
                                      code: sl.c.NO_NETWORK,
                                      message: "STR_CHECK_NET",
                                    });
                                  const n = await this.retryable(s, () =>
                                    this.processUnpinPinTopics(e, t, s)
                                  );
                                  return (
                                    this.Logger.infoUnpin(
                                      i,
                                      `res cId:${e}`,
                                      !!n,
                                      null == n ? void 0 : n.conversationId,
                                      null == n ||
                                        null === (a = n.topics) ||
                                        void 0 === a
                                        ? void 0
                                        : a.length
                                    ),
                                    n
                                  );
                                } catch (n) {
                                  return (
                                    this.Logger.errorUnpin(
                                      i,
                                      `err cId:${e}`,
                                      Il(n, Object(tl.a)())
                                    ),
                                    Promise.reject(n)
                                  );
                                }
                              }
                              isMessagePinnable(e) {
                                return (function (e) {
                                  return el(e);
                                })(e);
                              }
                              initialize() {
                                this.FriendManager.subscribeEventFriend(
                                  w.EventFriend.REMOVE_FRIEND,
                                  (e) => {
                                    const { userId: t } = e;
                                    t && this.clearTopics(t);
                                  }
                                ),
                                  Object(Pl.b)(this.clear);
                              }
                              clear() {
                                this.DataRepository.clear(),
                                  this.MessageLoader.clear();
                              }
                              checkEnableToCreate(e, t, s) {
                                const i = (() => {
                                  if (t.type === sl.i.MESSAGE) {
                                    const i = s.topics,
                                      a = t.params.global_msg_id,
                                      n = t.params.client_msg_id,
                                      r = t.params.senderUid;
                                    for (let t = 0; t < i.length; t++) {
                                      const s = i[t];
                                      if (s.type === sl.i.MESSAGE) {
                                        const t =
                                          this.MessageLoader.getMessageFromTopic(
                                            s
                                          );
                                        if (
                                          null != t &&
                                          null != a &&
                                          t.msgId === a
                                        )
                                          return s;
                                        if (
                                          null != t &&
                                          null != n &&
                                          t.cliMsgId === n &&
                                          t.fromUid === r &&
                                          t.toUid === e
                                        )
                                          return s;
                                      }
                                    }
                                  }
                                  return null;
                                })();
                                return s.topics.length < Object(tl.c)() || i
                                  ? { enable: !0, oldTopic: i }
                                  : { enable: !1, oldTopic: null };
                              }
                              clearTopics(e) {
                                this.DataRepository.loadPinTopics(e, sl.e.NONE)
                                  .then((t) => {
                                    this.DataRepository.clearPinTopicsForConversation(
                                      e,
                                      !0
                                    ),
                                      this.MessageLoader.removeMessages(
                                        t.topics
                                      ),
                                      this.notifyChangeEvent(e, []);
                                  })
                                  .catch();
                              }
                              getRequestID() {
                                return this.requestID.next();
                              }
                              async fetchTopicsForHandleTopLevelErrors(e, t) {
                                return await this.DataRepository.loadPinTopics(
                                  e,
                                  t
                                );
                              }
                              async handleTopLevelErrorInvalidBoardVersion(
                                e,
                                t,
                                s
                              ) {
                                const { conversationId: i } = t;
                                try {
                                  const e =
                                    await this.fetchTopicsForHandleTopLevelErrors(
                                      i,
                                      sl.e.OUT_OF_DATE
                                    );
                                  return s ? await s() : e;
                                } catch (a) {
                                  return Promise.reject(e);
                                }
                              }
                              async handleTopLevelErrorRolledData(e, t) {
                                const { conversationId: s } = t;
                                try {
                                  const t =
                                    await this.fetchTopicsForHandleTopLevelErrors(
                                      s,
                                      sl.e.ROLLED_DATA
                                    );
                                  return (
                                    this.notifyChangeEvent(
                                      t.conversationId,
                                      t.topics
                                    ),
                                    Promise.reject({
                                      code: sl.c.TOPIC_NOT_IN_PIN_LIST,
                                      message:
                                        e.message || "STR_PIN_GENERAL_ERROR",
                                    })
                                  );
                                } catch (i) {
                                  return Promise.reject(e);
                                }
                              }
                              async handleTopLevelErrorUserBlockFriend(e) {
                                return Promise.reject({
                                  code: sl.c.USER_BLOCK_FRIEND,
                                  message: e.message || "STR_TOAST_BLOCK",
                                });
                              }
                              async handleTopLevelErrorUserNonFriend(e) {
                                return Promise.reject({
                                  code: sl.c.USER_NON_FRIEND,
                                  message:
                                    e.message || "STR_PIN_NOT_ZALO_FRIEND",
                                });
                              }
                              async handleTopLevelErrors(e, t, s) {
                                return e.code === sl.c.INVALID_BOARD_VERSION
                                  ? await this.handleTopLevelErrorInvalidBoardVersion(
                                      e,
                                      t,
                                      s
                                    )
                                  : e.code === sl.c.TOPIC_NOT_IN_PIN_LIST
                                  ? await this.handleTopLevelErrorRolledData(
                                      e,
                                      t
                                    )
                                  : e.code === sl.c.USER_BLOCK_FRIEND
                                  ? await this.handleTopLevelErrorUserBlockFriend(
                                      e
                                    )
                                  : e.code === sl.c.USER_NON_FRIEND
                                  ? await this.handleTopLevelErrorUserNonFriend(
                                      e
                                    )
                                  : Promise.reject(e);
                              }
                              isValidNetwork() {
                                return (
                                  nn.b.getStateNetwork() === nn.a.CONNECTED
                                );
                              }
                              notifyEvent(e, ...t) {
                                const s = this.events[e],
                                  i = (this.events[e] || []).length;
                                for (let a = 0; a < i; a++)
                                  "function" == typeof s[a] && s[a](...t);
                              }
                              notifyChangeEvent(e, t) {
                                this.notifyEvent("onchange", e, t);
                              }
                              notifyExceedEvent(e, t, s) {
                                this.notifyEvent("onexceed", e, t, s);
                              }
                              async processCreatePinTopic(e, t, s = 2) {
                                if (!this.FriendManager.isFriend(e))
                                  return Promise.reject({
                                    code: sl.c.USER_NON_FRIEND,
                                    message: "STR_PIN_NOT_ZALO_FRIEND",
                                  });
                                if (this.FriendManager.isBlocked(e))
                                  return Promise.reject({
                                    code: sl.c.USER_BLOCK_FRIEND,
                                    message: "STR_TOAST_BLOCK",
                                  });
                                try {
                                  const s =
                                    await this.DataRepository.createPinTopic(
                                      e,
                                      t,
                                      {
                                        checkEnableToCreate:
                                          this.checkEnableToCreate.bind(this),
                                      }
                                    );
                                  return (
                                    this.MessageLoader.loadMessages(s.topics),
                                    this.notifyChangeEvent(
                                      s.conversationId,
                                      s.topics
                                    ),
                                    {
                                      conversationId: s.conversationId,
                                      topics: s.topics,
                                    }
                                  );
                                } catch (a) {
                                  try {
                                    const i = await this.handleTopLevelErrors(
                                      a,
                                      { conversationId: e },
                                      this.createPinTopic.bind(
                                        this,
                                        e,
                                        t,
                                        s - 1
                                      )
                                    );
                                    return {
                                      conversationId: i.conversationId,
                                      topics: i.topics,
                                    };
                                  } catch (n) {
                                    if (n.code === sl.c.PINBOARD_OVER_MAXIMUM) {
                                      var i;
                                      const s =
                                        null == n ||
                                        null === (i = n.data) ||
                                        void 0 === i
                                          ? void 0
                                          : i.cache;
                                      this.notifyExceedEvent(
                                        e,
                                        (null == s ? void 0 : s.topics) || [],
                                        t
                                      );
                                    }
                                    return Promise.reject(n);
                                  }
                                }
                              }
                              async processReorderPinTopics(e, t, s = 2) {
                                try {
                                  const s =
                                    await this.DataRepository.reorderPinTopics(
                                      e,
                                      t
                                    );
                                  return (
                                    this.notifyChangeEvent(
                                      s.conversationId,
                                      s.topics
                                    ),
                                    {
                                      conversationId: s.conversationId,
                                      topics: s.topics,
                                    }
                                  );
                                } catch (i) {
                                  try {
                                    const a = await this.handleTopLevelErrors(
                                      i,
                                      { conversationId: e },
                                      this.reorderPinTopics.bind(
                                        this,
                                        e,
                                        t,
                                        s - 1
                                      )
                                    );
                                    return {
                                      conversationId: a.conversationId,
                                      topics: a.topics,
                                    };
                                  } catch (a) {
                                    return Promise.reject(a);
                                  }
                                }
                              }
                              async processUnpinPinTopics(e, t, s = 2) {
                                try {
                                  const s =
                                    await this.DataRepository.unpinTopics(e, t);
                                  return (
                                    this.MessageLoader.removeMessages(t),
                                    this.notifyChangeEvent(
                                      s.conversationId,
                                      s.topics
                                    ),
                                    {
                                      conversationId: s.conversationId,
                                      topics: s.topics,
                                    }
                                  );
                                } catch (i) {
                                  try {
                                    const a = await this.handleTopLevelErrors(
                                      i,
                                      { conversationId: e },
                                      this.unpinPinTopics.bind(
                                        this,
                                        e,
                                        t,
                                        s - 1
                                      )
                                    );
                                    return {
                                      conversationId: a.conversationId,
                                      topics: a.topics,
                                    };
                                  } catch (a) {
                                    return Promise.reject(a);
                                  }
                                }
                              }
                              async retryable(e, t) {
                                return null != e && e < 0
                                  ? Promise.reject({
                                      code: sl.c.STOP_RETRY_CLIENT,
                                      message: "STR_PIN_GENERAL_ERROR",
                                    })
                                  : await t();
                              }
                              get DataRepository() {
                                return this.dataRepository;
                              }
                              get FriendManager() {
                                return D.default;
                              }
                              get Logger() {
                                return this.logger;
                              }
                              get MessageLoader() {
                                return this.messageLoader;
                              }
                            })
                          ) || Bl)
                      ) || Bl)
                  ) || Bl)
              ) || Bl)
          ) || Bl)
      );
      var zl,
        xl = s("74m0");
      Object(a.injectable)()(
        (zl =
          Object(a.singleton)(xl.a)(
            (zl =
              (function (e, t) {
                return Object(a.inject)(Ul)(e, void 0, 0);
              })(
                (zl =
                  Reflect.metadata(
                    "design:type",
                    Function
                  )(
                    (zl =
                      Reflect.metadata("design:paramtypes", [Object])(
                        (zl = class {
                          constructor(e) {
                            this.oneOnOneController = e;
                          }
                          addEventListener(e, t) {
                            this.OneOnOneController.addEventListener(e, t);
                          }
                          createPinTopic(e, t) {
                            return Object(Xc.d)(e)
                              ? Promise.resolve()
                              : this.OneOnOneController.createPinTopic(e, t);
                          }
                          displayOneOnOneEntryPointPromotionalTooltip() {
                            return this.OneOnOneController.displayEntryPointPromotionalTooltip();
                          }
                          getPinTopic(e, t, s) {
                            return Object(Xc.d)(e)
                              ? Promise.resolve()
                              : this.OneOnOneController.getPinTopic(e, t, s);
                          }
                          getMessageFromTopic(e, t) {
                            if (!Object(Xc.d)(e))
                              return this.OneOnOneController.getMessageFromTopic(
                                t
                              );
                          }
                          handleEventControl(e) {}
                          handleOneOnOneEventsControl(e) {
                            this.OneOnOneController.handleEventControl(e);
                          }
                          isDisplayedOneOnOneEntryPointPromotionalTooltip() {
                            return this.OneOnOneController.isDisplayedEntryPointPromotionalTooltip();
                          }
                          isEnablePinTopicOneOnOneFeature() {
                            return tl.k();
                          }
                          isEnablePinTopicOneOnOneEntryPoint() {
                            return tl.j();
                          }
                          isMessagePinnable(e, t) {
                            return (
                              !!this.isMessagePinnableForAllConversations(e) &&
                              (t !== w.CONVERSATION_TYPE.FRIEND ||
                                this.OneOnOneController.isMessagePinnable(e))
                            );
                          }
                          loadPinTopics(e, t) {
                            return Object(Xc.d)(e)
                              ? Promise.resolve()
                              : this.OneOnOneController.loadPinTopics(e, t);
                          }
                          removeEventListener(e, t) {
                            this.OneOnOneController.removeEventListener(e, t);
                          }
                          removeEventListeners(e) {
                            this.OneOnOneController.removeEventListeners(e);
                          }
                          reorderPinTopics(e, t) {
                            return Object(Xc.d)(e)
                              ? Promise.resolve()
                              : this.OneOnOneController.reorderPinTopics(e, t);
                          }
                          unpinPinTopics(e, t) {
                            return Object(Xc.d)(e)
                              ? Promise.resolve()
                              : this.OneOnOneController.unpinPinTopics(e, t);
                          }
                          isMessagePinnableForAllConversations(e) {
                            return el(e);
                          }
                          get OneOnOneController() {
                            return this.oneOnOneController;
                          }
                        })
                      ) || zl)
                  ) || zl)
              ) || zl)
          ) || zl)
      );
      let Vl;
      !(function (e) {
        e.lockSendMsg = "lockSendMsg";
      })(Vl || (Vl = {}));
      var ql,
        Hl = s("MnxE"),
        Kl = s("NDwn");
      Object(B.b)(ta.b)(
        (ql =
          Reflect.metadata(
            "design:type",
            Function
          )(
            (ql =
              Reflect.metadata(
                "design:paramtypes",
                []
              )(
                (ql = class {
                  get Logger() {
                    return (
                      this._Logger ||
                        (this._Logger = a.ModuleContainer.resolve(
                          O.ZLoggerFactory
                        ).createZLogger(Ut.b.onlyAdminChatSettings, [
                          this.name,
                        ])),
                      this._Logger
                    );
                  }
                  constructor() {
                    Object(i.a)(this, "type", void 0),
                      Object(i.a)(this, "name", void 0),
                      Object(i.a)(this, "key", void 0),
                      Object(i.a)(this, "settings", new Map()),
                      Object(i.a)(this, "me", ""),
                      Object(i.a)(this, "_Logger", void 0),
                      (this.name = ta.a),
                      (this.key = ta.a),
                      1 ===
                        I.default.only_admin_chat_setting
                          .enable_only_admin_chat_setting &&
                        this._addPublicGroupSettingEventListener(),
                      this._addPublicFriendEventListener(),
                      Kl.a ||
                        Hl.a.signalCallback(this.onSettingsUpdate.bind(this));
                  }
                  _filterSettingKeys(e, t, s) {
                    let i = { lockSendMsg: !1 };
                    for (let a in e)
                      Object.keys(Vl).includes(a) &&
                        a === Vl.lockSendMsg &&
                        (i[Vl.lockSendMsg] =
                          !t && !s && Boolean(e[Vl.lockSendMsg]));
                    return i;
                  }
                  _onUpdateSettings(e, t, s, i) {
                    this.me || (this.me = D.default.getUidMe());
                    const a = this.me === t,
                      n = this._filterSettingKeys(i, a, s);
                    return (
                      this.settings.set(e, n), Object(yt.g)(this.name, e), n
                    );
                  }
                  showNoti(e) {
                    if ("TOAST" === e.type)
                      Pc.ZToastManagerHolder.getZToastManagerByWindowId(
                        e.windowId || Ze.c
                      ).show(Object(p.a)({}, e.config));
                  }
                  verifySetting(e) {
                    const { convId: t, field: s, showNoti: i } = e,
                      a = this.settings.get(t);
                    return a
                      ? (i && i.triggerValue === a[s] && this.showNoti(i),
                        a && a[s])
                      : null;
                  }
                  onSettingsUpdate(e, t) {
                    let s = this.settings.get(e) || { lockSendMsg: !1 };
                    for (let i in t)
                      Object.keys(Vl).includes(i) && (s[i] = t[i]);
                    this.settings.set(e, s), Object(yt.g)(this.name, e);
                  }
                  _addPublicGroupSettingEventListener() {
                    ne.default.subscribeEventGroup(
                      w.EventGroup.CHANGE_OWNER,
                      (e) => {
                        const { groupId: t } = e;
                        t && this.onLoadGroupSetting(t);
                      }
                    ),
                      ne.default.subscribeEventGroup(
                        w.EventGroup.ADD_ADMIN,
                        (e) => {
                          const { groupId: t } = e;
                          t && this.onLoadGroupSetting(t);
                        }
                      ),
                      ne.default.subscribeEventGroup(
                        w.EventGroup.REMOVE_ADMIN,
                        (e) => {
                          const { groupId: t } = e;
                          t && this.onLoadGroupSetting(t);
                        }
                      ),
                      ne.default.subscribeEventGroup(
                        w.EventGroup.GROUP_INFO_CHANGED,
                        (e) => {
                          if (null != e && e.length)
                            for (let t = 0; t < e.length; t++)
                              this.onLoadGroupSetting(e[t]);
                        }
                      ),
                      fs.default.subscribe(Ze.a.CHILD_WINDOW_ALIVE, (e) => {
                        null != e &&
                          e.windowId &&
                          this.onLoadSetting(e.windowId);
                      }),
                      _.default.subscribe((e, t) => {
                        switch (e) {
                          case y.FetchActions.UPDATE_GROUP_SETTING: {
                            var s, i;
                            const e =
                              null != t &&
                              null !== (s = t.data) &&
                              void 0 !== s &&
                              null !== (i = s.groupId) &&
                              void 0 !== i &&
                              i.startsWith("g")
                                ? t.data.groupId
                                : "g" + t.data.groupId;
                            e && this.onLoadGroupSetting(e);
                            break;
                          }
                        }
                      });
                  }
                  updateFriendBLockSetting(e, t) {
                    const s = t || D.default.isBlocked(e),
                      i =
                        1 ===
                        I.default.block_msg_call_setting
                          .enable_block_msg_call_setting;
                    this.onSettingsUpdate(e, {
                      [Vl.lockSendMsg]: Boolean(s) && i,
                    });
                  }
                  _addPublicFriendEventListener() {
                    D.default.subscribeEventFriend(
                      w.EventFriend.BLOCK_FRIEND,
                      (e) => {
                        this.updateFriendBLockSetting(e.userId, !0);
                      }
                    ),
                      D.default.subscribeEventFriend(
                        w.EventFriend.UNBLOCK_FRIEND,
                        (e) => {
                          this.updateFriendBLockSetting(e.userId, !1);
                        }
                      ),
                      _.default.subscribe((e, t) => {
                        if (e === y.FriendsAction.FRIENDS_CHANGE_INFO)
                          t &&
                            Array.isArray(t) &&
                            t.forEach(({ userId: e }) => {
                              this.updateFriendBLockSetting(e);
                            });
                      });
                  }
                  _checkGroupAdmin(e) {
                    var t;
                    return (
                      this.me || (this.me = D.default.getUidMe()),
                      (null == e || null === (t = e.topMember) || void 0 === t
                        ? void 0
                        : t.filter((e) => e.id === this.me && e.isAdmin)
                            .length) > 0
                    );
                  }
                  onLoadGroupSetting(e) {
                    return new Promise((t, s) => {
                      ne.default
                        .getFullInfoGroupById(e)
                        .then((s) => {
                          if (!s)
                            return (
                              this.Logger.zsymb(
                                18,
                                11662,
                                3e4,
                                "[GroupSetting]: Load GroupInfo from manager faily " +
                                  s +
                                  ", GroupId: " +
                                  e
                              ),
                              t(null)
                            );
                          const i = s.setting,
                            a = s.creatorId,
                            n = this._checkGroupAdmin(s),
                            r = this._onUpdateSettings(e, a, n, i);
                          i &&
                            !i.hasOwnProperty("lockSendMsg") &&
                            this.Logger.zsymb(
                              18,
                              11662,
                              30001,
                              "[GroupSetting]: Dont have field lockSendMsg in setting data"
                            ),
                            t(r);
                        })
                        .catch((s) => {
                          this.Logger.zsymb(
                            18,
                            11662,
                            30002,
                            "[GroupSetting]: Have error in loadiing GroupInfo from manager: " +
                              JSON.stringify(s) +
                              ", GroupId: " +
                              e
                          ),
                            t(null);
                        });
                    });
                  }
                  async onLoadSetting(e) {
                    return e.startsWith("g")
                      ? 1 !==
                        I.default.only_admin_chat_setting
                          .enable_only_admin_chat_setting
                        ? null
                        : await this.onLoadGroupSetting(e)
                      : (this.updateFriendBLockSetting(e),
                        Kl.a ? null : void Hl.a.signalIfUnlock(e));
                  }
                  init(e) {
                    throw new Error("Method not  .");
                  }
                  getCurrentItem(e) {
                    return this.settings.get(e);
                  }
                  getItem(e, t) {
                    return this.settings.get(e.key);
                  }
                  getList(e, t) {
                    throw new Error("Method not implemented.");
                  }
                  onGetItemFailure(e, t) {
                    throw new Error("Method not implemented.");
                  }
                  onGetListFailure(e, t) {
                    throw new Error("Method not implemented.");
                  }
                  getDefaultItem() {
                    throw new Error("Method not implemented.");
                  }
                  getDefaultList() {
                    throw new Error("Method not implemented.");
                  }
                })
              ) || ql)
          ) || ql)
      );
      var $l,
        Wl = s("OMsT"),
        Zl = s("mw/K"),
        Ql = s.n(Zl),
        Yl = s("7FSS");
      let Jl =
        Object(a.injectable)()(
          ($l =
            Reflect.metadata(
              "design:type",
              Function
            )(
              ($l =
                Reflect.metadata(
                  "design:paramtypes",
                  []
                )(
                  ($l = class {
                    constructor() {
                      Object(i.a)(this, "appdataFolder", void 0),
                        (this.appdataFolder = z.a.join(
                          window.electronAPI.getPath("userData"),
                          "logs"
                        ));
                    }
                    clientDeviceInfo() {
                      const e = s("jle/"),
                        t = e.platform(),
                        i = e.release(),
                        a = e.hostname(),
                        n = e.type();
                      return JSON.stringify({
                        name: a,
                        model: n,
                        os: t,
                        osVersion: i,
                      });
                    }
                    prepareLogBlob(e) {
                      return new Promise((t, i) => {
                        if (!Ql.a.existsSync(this.appdataFolder))
                          return void i();
                        let a = e.viewerKey;
                        if (!a) {
                          a = $e.default.getLastViewKey() || "";
                          try {
                            var n;
                            a =
                              null === (n = a) || void 0 === n
                                ? void 0
                                : n.split(".")[0];
                          } catch {
                            a = a;
                          }
                        }
                        const r = new (s("fDnD"))(),
                          o = [],
                          c = [];
                        let l = [];
                        try {
                          l = Ql.a.readdirSync(this.appdataFolder);
                        } catch (h) {}
                        const d =
                          /^(main|login|photo|render|shared-worker).(zlog|log|module|meta|dmeta)$/;
                        (l = l
                          .filter((e) => {
                            const t = d.test(e),
                              s =
                                e.endsWith(".zlog") ||
                                e.endsWith(".module") ||
                                e.endsWith(".meta");
                            return (
                              d.test(e) ||
                                c.push(
                                  this.deleteFile(
                                    z.a.join(this.appdataFolder, e)
                                  )
                                ),
                              t && s
                            );
                          })
                          .map((e) => z.a.join(this.appdataFolder, e))),
                          l.push(...e.extraFiles),
                          l.forEach((e) => {
                            o.push(this.readFile(e));
                          }),
                          Promise.all(o)
                            .then((s) => {
                              s.forEach((e) => {
                                e &&
                                  e.data.byteLength > 0 &&
                                  r.file(e.name, e.data.buffer);
                              });
                              {
                                const e = "device.zinfo",
                                  t = new TextEncoder();
                                r.file(
                                  e,
                                  t.encode(this.clientDeviceInfo()).buffer
                                );
                              }
                              const n = `zlog_${a}_${Date.now()}.zip`;
                              r.generateAsync({
                                type: "arraybuffer",
                                compression: "DEFLATE",
                              })
                                .then((s) => {
                                  if (e.bareContent)
                                    t({ name: n, data: new Uint8Array(s) });
                                  else {
                                    const e = new Blob([new Uint8Array(s)]);
                                    (e.name = n), t(e);
                                  }
                                })
                                .catch((e) => {
                                  i(e);
                                });
                            })
                            .catch((e) => {
                              i();
                            }),
                          Promise.all(c)
                            .then(() => {})
                            .catch((e) => {
                              Yl.a.log("[ZLL]: delete invalid files error", e);
                            });
                      });
                    }
                    deleteFile(e) {
                      return new Promise((t) => {
                        Ql.a.unlink(e, (s) => {
                          s && Yl.a.log("[ZLL]: delete file error", e, s), t();
                        });
                      });
                    }
                    readFile(e) {
                      return new Promise((t) => {
                        Ql.a.readFile(e, (s, i) => {
                          t(
                            s
                              ? { data: Buffer.alloc(0), name: e }
                              : { data: i, name: z.a.basename(e) }
                          );
                        });
                      });
                    }
                  })
                ) || $l)
            ) || $l)
        ) || $l;
      a.ModuleContainer.registerSingleton(Wl.a, Jl);
      var Xl = s("t5n0"),
        ed = s("aQZC");
      var td,
        sd = new (class {
          constructor() {
            Object(i.a)(this, "focusManager", void 0),
              Object(i.a)(this, "focusStatus", void 0),
              Object(i.a)(this, "focusService", void 0);
          }
          get FSV() {
            return (
              this.focusService ||
                (this.focusService = a.ModuleContainer.resolve(
                  O.ZLoggerFactory
                ).createZLogger(Ut.b.appStatus, [Ut.b.focusDetectorManager])),
              this.focusService
            );
          }
          get FM() {
            return (
              this.focusManager ||
                (this.focusManager = a.ModuleContainer.resolve(
                  O.ZLoggerFactory
                ).createZLogger(Ut.b.appStatus, [Ut.b.focusDetectorManager])),
              this.focusManager
            );
          }
          get FSTT() {
            return (
              this.focusStatus ||
                (this.focusStatus = a.ModuleContainer.resolve(
                  O.ZLoggerFactory
                ).createZLogger(Ut.b.appStatus, [Ut.b.focusStatus])),
              this.focusStatus
            );
          }
        })();
      let id =
        Object(a.injectable)()(
          (td =
            Object(j.e)()(
              (td =
                (function (e, t) {
                  return Object(a.inject)(li.a)(e, void 0, 0);
                })(
                  (td =
                    Reflect.metadata(
                      "design:type",
                      Function
                    )(
                      (td =
                        Reflect.metadata("design:paramtypes", [
                          void 0 === li.a ? Object : li.a,
                        ])(
                          (td = class extends re.b {
                            constructor(e) {
                              super(),
                                (this.config = e),
                                Object(i.a)(this, "detectors", void 0),
                                Object(i.a)(this, "lostFocusHandler", void 0),
                                Object(i.a)(this, "reFocusHandler", void 0),
                                Object(i.a)(this, "lastFirer", void 0),
                                Object(i.a)(this, "enableLog", void 0),
                                Object(i.a)(this, "listenDetector", (e, t) => {
                                  t &&
                                    (this.detectors.set(e, t),
                                    this.lostFocusHandler.set(e, () => {
                                      this.onLostFocus(e);
                                    }),
                                    this.reFocusHandler.set(e, () => {
                                      this.onRefocus(e);
                                    }),
                                    t.idle(this.lostFocusHandler.get(e)),
                                    t.wakeup(this.reFocusHandler.get(e)));
                                }),
                                Object(i.a)(this, "disposeDetector", (e) => {
                                  const t = this.detectors.get(e);
                                  this.enableLog &&
                                    sd.FM.zsymb(
                                      0,
                                      9605,
                                      30003,
                                      "disposeDetector",
                                      e,
                                      !!t
                                    ),
                                    t &&
                                      (t.removeIdle(
                                        this.lostFocusHandler.get(e)
                                      ),
                                      t.removeWakeup(
                                        this.reFocusHandler.get(e)
                                      ),
                                      (t.ifvisible = null),
                                      (t._window = null),
                                      t.removeAllIpc(),
                                      this.lostFocusHandler.delete(e),
                                      this.reFocusHandler.delete(e),
                                      this.detectors.delete(e));
                                }),
                                Object(i.a)(this, "onLostFocus", (e) => {
                                  this.lastFirer &&
                                    (clearTimeout(this.lastFirer),
                                    (this.lastFirer = null)),
                                    (this.lastFirer = setTimeout(() => {
                                      this.enableLog &&
                                        sd.FM.zsymb(
                                          0,
                                          9605,
                                          30004,
                                          "onlostFocus",
                                          e
                                        );
                                      let t = !0,
                                        s = Number.MAX_SAFE_INTEGER,
                                        i = "unknown";
                                      this.detectors.forEach((e) => {
                                        if (e.isActive()) t = !1;
                                        else {
                                          const t = e.getIdleInfo();
                                          t.idleFor < s &&
                                            ((s = t.idleFor),
                                            (i = t.idleByTimeout
                                              ? "no-action-timeout"
                                              : "unknown"));
                                        }
                                      }),
                                        t &&
                                          this.dispatchEvent(
                                            new Xl.a(Xl.b.LostFocus, {
                                              scope: "app",
                                              reason: i,
                                            })
                                          ),
                                        (this.lastFirer = null);
                                    }, 200));
                                }),
                                Object(i.a)(this, "onRefocus", (e) => {
                                  this.lastFirer &&
                                    (clearTimeout(this.lastFirer),
                                    (this.lastFirer = null)),
                                    (this.lastFirer = setTimeout(() => {
                                      this.enableLog &&
                                        sd.FM.zsymb(
                                          0,
                                          9605,
                                          30005,
                                          "onRefocus",
                                          e
                                        ),
                                        this.dispatchEvent(
                                          new Xl.a(Xl.b.Focus, e)
                                        ),
                                        (this.lastFirer = null);
                                    }, 200));
                                }),
                                (this.detectors = new Map()),
                                (this.lostFocusHandler = new Map()),
                                (this.reFocusHandler = new Map()),
                                (this.enableLog = !0);
                            }
                            onAuthenticated(e) {
                              const { userId: t } = e.getSession();
                              this.enableLog &&
                                sd.FM.zsymb(0, 9605, 3e4, "onAuthenticated", t),
                                this.init();
                            }
                            acquire(e, t, s, i) {
                              if (!e || e == Ze.c) return ed.b;
                              if (this.detectors.has(e))
                                return (
                                  sd.FM.zsymb(
                                    0,
                                    9605,
                                    30001,
                                    "acquire exists",
                                    e
                                  ),
                                  this.detectors.get(e)
                                );
                              this.enableLog &&
                                sd.FM.zsymb(0, 9605, 30002, "acquire new", e);
                              const a = new ed.a(t, e, s, i);
                              return this.listenDetector(e, a), a;
                            }
                            release(e) {
                              this.disposeDetector(e);
                            }
                            getAppIdleTime() {
                              let e = Number.MAX_SAFE_INTEGER;
                              return (
                                this.detectors.forEach((t) => {
                                  const s = t.getIdleInfo();
                                  s.idleFor < e && (e = s.idleFor);
                                }),
                                e
                              );
                            }
                            updateIdleTimeout(e) {
                              this.detectors.forEach((t) => {
                                t.setIdleTimeout(e);
                              });
                            }
                            isAppFocus() {
                              let e = !1;
                              return (
                                this.detectors.forEach((t) => {
                                  t.isActive() && (e = !0);
                                }),
                                e
                              );
                            }
                            init() {
                              this.listenDetector(Ze.c, ed.b);
                            }
                          })
                        ) || td)
                    ) || td)
                ) || td)
            ) || td)
        ) || td;
      const ad = Object(a.define)("lost-focus-service"),
        nd = Object(a.define)("active-service");
      var rd,
        od,
        cd = s("cHDa");
      !(function (e) {
        (e[(e.Focus = 0)] = "Focus"), (e[(e.LostFocus = 1)] = "LostFocus");
      })(od || (od = {}));
      let ld =
        Object(a.injectable)()(
          (rd =
            Object(j.e)()(
              (rd =
                (function (e, t) {
                  return Object(a.inject)(li.a)(e, void 0, 0);
                })(
                  (rd =
                    (function (e, t) {
                      return Object(a.inject)(ad)(e, void 0, 1);
                    })(
                      (rd =
                        Reflect.metadata(
                          "design:type",
                          Function
                        )(
                          (rd =
                            Reflect.metadata("design:paramtypes", [
                              void 0 === li.a ? Object : li.a,
                              void 0 === ad ? Object : ad,
                            ])(
                              (rd = class {
                                constructor(e, t) {
                                  (this.config = e),
                                    (this.service = t),
                                    Object(i.a)(this, "enableLog", void 0),
                                    Object(i.a)(this, "currentState", void 0),
                                    (this.enableLog = !0),
                                    (this.currentState = od.LostFocus);
                                }
                                onAuthenticated(e) {
                                  const { userId: t } = e.getSession();
                                  this.enableLog &&
                                    sd.FSTT.zsymb(
                                      0,
                                      9606,
                                      3e4,
                                      "onAuthenticated",
                                      t
                                    ),
                                    this.init();
                                }
                                init() {
                                  const e = a.ModuleContainer.resolve(Xl.c);
                                  e.addEventListener(Xl.b.LostFocus, (e) => {
                                    const { scope: t, reason: s } = e.payload;
                                    this.currentState == od.Focus &&
                                      "app" === t &&
                                      (this.service.notiLostFocus(),
                                      this.config.get(
                                        "online_configs.enable_focus_manager"
                                      ) && cd.b.setAppStatus(cd.a.BACKGROUND),
                                      (this.currentState = od.LostFocus));
                                  }),
                                    e.addEventListener(Xl.b.Focus, (e) => {
                                      this.currentState == od.LostFocus &&
                                        this.config.get(
                                          "online_configs.enable_focus_manager"
                                        ) &&
                                        cd.b.setAppStatus(cd.a.FOREGROUND),
                                        (this.currentState = od.Focus);
                                    });
                                }
                              })
                            ) || rd)
                        ) || rd)
                    ) || rd)
                ) || rd)
            ) || rd)
        ) || rd;
      var dd;
      let hd =
        Object(a.injectable)()(
          (dd =
            (function (e, t) {
              return Object(a.inject)(li.a)(e, void 0, 0);
            })(
              (dd =
                Reflect.metadata(
                  "design:type",
                  Function
                )(
                  (dd =
                    Reflect.metadata("design:paramtypes", [
                      void 0 === li.a ? Object : li.a,
                    ])(
                      (dd = class {
                        constructor(e) {
                          this.config = e;
                        }
                        notiLostFocus() {
                          this.config.get("online_configs.enable_lost_focus")
                            ? an.default
                                .lostFocus()
                                .then(tn.a)
                                .then(() => {
                                  sd.FSV.zsymb(
                                    0,
                                    9594,
                                    30001,
                                    "send noti lost success"
                                  );
                                })
                                .catch((e) => {
                                  sd.FSV.zsymb(
                                    0,
                                    9594,
                                    30002,
                                    "send noti lost fail",
                                    JSON.stringify(e)
                                  );
                                })
                            : sd.FSV.zsymb(
                                0,
                                9594,
                                3e4,
                                "call send noti lost but feat disable"
                              );
                        }
                      })
                    ) || dd)
                ) || dd)
            ) || dd)
        ) || dd;
      var ud,
        gd = s("a8HX");
      let pd =
        Object(a.injectable)()(
          (ud =
            (function (e, t) {
              return Object(a.inject)(O.ZLoggerFactory)(e, void 0, 0);
            })(
              (ud =
                (function (e, t) {
                  return Object(a.inject)(nd)(e, void 0, 1);
                })(
                  (ud =
                    Reflect.metadata(
                      "design:type",
                      Function
                    )(
                      (ud =
                        Reflect.metadata("design:paramtypes", [
                          void 0 === O.ZLoggerFactory
                            ? Object
                            : O.ZLoggerFactory,
                          void 0 === nd ? Object : nd,
                        ])(
                          (ud = class extends cr {
                            constructor(e, t) {
                              super(),
                                (this.loggerFactory = e),
                                (this.service = t);
                            }
                            createMachine() {
                              return (
                                (e = this.loggerFactory.createZLogger(
                                  Ut.b.activeDeactive,
                                  [Ut.b.stateMachine]
                                )),
                                (t = this.service),
                                Object(or.createMachine)({
                                  strict: !0,
                                  id: "active-deactive",
                                  context: {},
                                  initial: "unset",
                                  states: {
                                    unset: {
                                      entry: () =>
                                        e.zsymb(3, 10095, 3e4, "unset"),
                                      on: {
                                        FOCUS: {
                                          actions: () => {
                                            e.zsymb(
                                              3,
                                              10095,
                                              30001,
                                              "start life cycle normal case!"
                                            );
                                          },
                                          target: "foreground_active",
                                        },
                                        APP_UNLOCK: {
                                          actions: () => {
                                            e.zsymb(
                                              3,
                                              10095,
                                              30002,
                                              "start life cycle app auto lock case!"
                                            );
                                          },
                                          target: "foreground_active",
                                        },
                                        LOST_FOCUS: {
                                          actions: () => {
                                            e.zsymb(
                                              3,
                                              10095,
                                              30003,
                                              "start life cycle lost focus case!"
                                            );
                                          },
                                          target: "background_active",
                                        },
                                      },
                                    },
                                    foreground_active: {
                                      entry: (s) => {
                                        e.zsymb(
                                          3,
                                          10095,
                                          30004,
                                          "state: foreground_active"
                                        ),
                                          t.startForegroundMode();
                                      },
                                      on: {
                                        IDLE: {
                                          actions: () => {},
                                          target: "background_deactive",
                                        },
                                        LOST_FOCUS: {
                                          actions: () => {},
                                          target: "background_active",
                                        },
                                        INAPP_INTERACT: {
                                          actions: () => {
                                            t.keepForegroundMode();
                                          },
                                        },
                                        OUTAPP_INTERACT: {
                                          actions: (e, s) => {
                                            t.activeInBackground(s.isOsEvt);
                                          },
                                        },
                                        APP_LOCK: {
                                          target: "background_deactive",
                                        },
                                        APP_UNLOCK: {
                                          actions: () => {
                                            t.startForegroundMode();
                                          },
                                        },
                                        LOG_OFF: {
                                          target: "background_deactive",
                                        },
                                        OUTAPP_IDLE: {
                                          target: "background_deactive",
                                        },
                                      },
                                    },
                                    background_active: {
                                      entry: (s) => {
                                        e.zsymb(
                                          3,
                                          10095,
                                          30005,
                                          "state: background_active"
                                        ),
                                          t.startBackgroundMode();
                                      },
                                      on: {
                                        FOCUS: { target: "foreground_active" },
                                        OUTAPP_INTERACT: {
                                          actions: (e, s) => {
                                            t.activeInBackground(s.isOsEvt);
                                          },
                                        },
                                        OUTAPP_IDLE: {
                                          target: "background_deactive",
                                        },
                                        APP_LOCK: {
                                          target: "background_deactive",
                                        },
                                        LOG_OFF: {
                                          target: "background_deactive",
                                        },
                                      },
                                    },
                                    background_deactive: {
                                      entry: (s, i) => {
                                        e.zsymb(
                                          3,
                                          10095,
                                          30006,
                                          "state: background_deactive",
                                          i.status
                                        ),
                                          t.startDeactive(i.status);
                                      },
                                      on: {
                                        FOCUS: {
                                          actions: () => {},
                                          target: "foreground_active",
                                        },
                                        OUTAPP_INTERACT: {
                                          actions: (e, s) => {
                                            t.activeInBackground(s.isOsEvt);
                                          },
                                          target: "background_active",
                                        },
                                        APP_UNLOCK: {
                                          target: "foreground_active",
                                        },
                                      },
                                    },
                                  },
                                  on: {
                                    RESET: {
                                      target: "unset",
                                      actions: () => {},
                                    },
                                  },
                                })
                              );
                              var e, t;
                            }
                            isUnset() {
                              var e;
                              return (
                                "unset" ===
                                (null === (e = this.interpreter) || void 0 === e
                                  ? void 0
                                  : e.state.value)
                              );
                            }
                            onceDeactive(e) {
                              var t;
                              if (
                                "background_deactive" ===
                                (null === (t = this.interpreter) || void 0 === t
                                  ? void 0
                                  : t.state.value)
                              )
                                e();
                              else {
                                let t = () => {
                                  var s, i;
                                  "background_deactive" ===
                                    (null === (s = this.interpreter) ||
                                    void 0 === s
                                      ? void 0
                                      : s.state.value) &&
                                    (null === (i = this.interpreter) ||
                                      void 0 === i ||
                                      i.off(t),
                                    e());
                                };
                                this.onChange(t);
                              }
                            }
                          })
                        ) || ud)
                    ) || ud)
                ) || ud)
            ) || ud)
        ) || ud;
      var md,
        vd = s("4zJP");
      const fd = new Map([
        ["0", "LOCK_SCREEN"],
        ["1", "UNLOCK_SCREEN"],
        ["2", "LOG_ON"],
        ["3", "LOG_OFF"],
        ["4", "SLEEP"],
        ["5", "RESUME"],
      ]);
      let bd =
        Object(a.injectable)()(
          (md =
            Object(j.h)()(
              (md =
                Object(j.g)()(
                  (md =
                    Object(a.singleton)(gd.a)(
                      (md =
                        (function (e, t) {
                          return Object(a.inject)(li.a)(e, void 0, 0);
                        })(
                          (md =
                            (function (e, t) {
                              return Object(a.inject)(O.ZLoggerFactory)(
                                e,
                                void 0,
                                1
                              );
                            })(
                              (md =
                                (function (e, t) {
                                  return Object(a.inject)(nd)(e, void 0, 2);
                                })(
                                  (md =
                                    Reflect.metadata(
                                      "design:type",
                                      Function
                                    )(
                                      (md =
                                        Reflect.metadata("design:paramtypes", [
                                          void 0 === li.a ? Object : li.a,
                                          void 0 === O.ZLoggerFactory
                                            ? Object
                                            : O.ZLoggerFactory,
                                          void 0 === nd ? Object : nd,
                                        ])(
                                          (md = class {
                                            constructor(e, t, s) {
                                              (this.config = e),
                                                (this.service = s),
                                                Object(i.a)(
                                                  this,
                                                  "logger",
                                                  void 0
                                                ),
                                                Object(i.a)(
                                                  this,
                                                  "machine",
                                                  void 0
                                                ),
                                                Object(i.a)(
                                                  this,
                                                  "_ipc",
                                                  void 0
                                                ),
                                                Object(i.a)(
                                                  this,
                                                  "authenticated",
                                                  void 0
                                                ),
                                                Object(i.a)(
                                                  this,
                                                  "appLocked",
                                                  void 0
                                                ),
                                                Object(i.a)(
                                                  this,
                                                  "isRunning",
                                                  void 0
                                                ),
                                                Object(i.a)(
                                                  this,
                                                  "lastConfig",
                                                  void 0
                                                ),
                                                Object(i.a)(
                                                  this,
                                                  "onAppLock",
                                                  () => {
                                                    this.logger.zsymb(
                                                      0,
                                                      10088,
                                                      30003,
                                                      "app locked",
                                                      this.authenticated
                                                    ),
                                                      (this.appLocked = !0),
                                                      this.authenticated &&
                                                        this.machine.send({
                                                          type: "APP_LOCK",
                                                          status: 2,
                                                        });
                                                  }
                                                ),
                                                Object(i.a)(
                                                  this,
                                                  "onAppUnLock",
                                                  () => {
                                                    this.logger.zsymb(
                                                      0,
                                                      10088,
                                                      30004,
                                                      "app unlocked",
                                                      this.authenticated
                                                    ),
                                                      (this.appLocked = !1),
                                                      this.authenticated &&
                                                        this.machine.send({
                                                          type: "APP_UNLOCK",
                                                          status: 0,
                                                        });
                                                  }
                                                ),
                                                Object(i.a)(
                                                  this,
                                                  "onConfigChanged",
                                                  (e) => {
                                                    I.default.stagingAccount &&
                                                      (window._activeController =
                                                        this),
                                                      e &&
                                                        this.config.set(
                                                          "online_configs",
                                                          e
                                                        );
                                                    const t =
                                                      this.isConfigsReallyChanged();
                                                    if (
                                                      (this.logger.zsymb(
                                                        0,
                                                        10088,
                                                        30005,
                                                        "onConfigChanged",
                                                        t
                                                      ),
                                                      !t)
                                                    )
                                                      return;
                                                    this.lastConfig =
                                                      this.config.get(
                                                        "online_configs"
                                                      );
                                                    const s = this.config.get(
                                                      "online_configs.idle_time"
                                                    );
                                                    a.ModuleContainer.resolve(
                                                      Xl.c
                                                    ).updateIdleTimeout(
                                                      s / 1e3
                                                    ),
                                                      this.service.onConfigUpdated(),
                                                      this.isEnable()
                                                        ? this.setup()
                                                        : this.onDispose();
                                                  }
                                                ),
                                                Object(i.a)(
                                                  this,
                                                  "onLostFocus",
                                                  async (e) => {
                                                    const {
                                                      scope: t,
                                                      reason: s,
                                                    } = e.payload;
                                                    "app" === t &&
                                                      (this.logger.zsymb(
                                                        0,
                                                        10088,
                                                        30006,
                                                        "lost focus",
                                                        s
                                                      ),
                                                      "no-action-timeout" !=
                                                        s ||
                                                      (await this.service.isUserHasAction(
                                                        this.idleTime
                                                      ))
                                                        ? this.machine.send({
                                                            type: "LOST_FOCUS",
                                                          })
                                                        : this.machine.send({
                                                            type: "IDLE",
                                                            status: 0,
                                                          }));
                                                  }
                                                ),
                                                Object(i.a)(
                                                  this,
                                                  "onFocus",
                                                  (e) => {
                                                    this.isUsingApp() &&
                                                      (this.logger.zsymb(
                                                        0,
                                                        10088,
                                                        30007,
                                                        "active-deactive focus"
                                                      ),
                                                      this.machine.send({
                                                        type: "FOCUS",
                                                      }));
                                                  }
                                                ),
                                                Object(i.a)(
                                                  this,
                                                  "onActiveFromBackground",
                                                  (e, t) => {
                                                    this.isUsingApp() &&
                                                      this.machine.send({
                                                        type: "OUTAPP_INTERACT",
                                                        isOsEvt: t,
                                                      });
                                                  }
                                                ),
                                                Object(i.a)(
                                                  this,
                                                  "onDeactiveFromBackground",
                                                  (e, t) => {
                                                    this.logger.zsymb(
                                                      0,
                                                      10088,
                                                      30008,
                                                      "onDeactiveFromBackground",
                                                      t
                                                    ),
                                                      this.isUsingApp() &&
                                                        this.machine.send({
                                                          type: "OUTAPP_IDLE",
                                                          status: t,
                                                        });
                                                  }
                                                ),
                                                (this.machine =
                                                  a.ModuleContainer.resolveToken(
                                                    pd
                                                  )),
                                                (this.logger = t.createZLogger(
                                                  Ut.b.activeDeactive,
                                                  [Ut.b.controller]
                                                )),
                                                (this.config = e),
                                                (this.service = s),
                                                (this.authenticated = !1),
                                                (this.appLocked = !1),
                                                (this.isRunning = !1),
                                                (this.lastConfig = {}),
                                                ze.p.listenEvent(
                                                  ze.l,
                                                  this.onConfigChanged
                                                );
                                              try {
                                                this.machine.create();
                                              } catch (n) {
                                                return void this.logger.zsymb(
                                                  18,
                                                  10088,
                                                  3e4,
                                                  () => [
                                                    "create error",
                                                    { error: n },
                                                  ]
                                                );
                                              }
                                            }
                                            get ipc() {
                                              if (!this._ipc) {
                                                const { ipcRenderer: e } =
                                                  s("NLsH");
                                                this._ipc = e;
                                              }
                                              return this._ipc;
                                            }
                                            createMachine() {}
                                            onStart() {
                                              this.isEnable() ||
                                                this.logger.zsymb(
                                                  0,
                                                  10088,
                                                  30001,
                                                  "feature is not enable"
                                                );
                                            }
                                            setup() {
                                              if (
                                                (this.logger.zsymb(
                                                  0,
                                                  10088,
                                                  30002,
                                                  "setup",
                                                  this.isRunning
                                                ),
                                                this.clearBackgroundTracking(),
                                                this.isEnableBackgroundTrack() &&
                                                  this.setupBackgroundTracking(),
                                                this.isRunning)
                                              )
                                                return;
                                              (this.isRunning = !0),
                                                this.machine.start();
                                              const e =
                                                a.ModuleContainer.resolve(Xl.c);
                                              this.machine.isUnset() &&
                                                (e.isAppFocus()
                                                  ? this.machine.send({
                                                      type: "FOCUS",
                                                    })
                                                  : this.machine.send({
                                                      type: "LOST_FOCUS",
                                                    })),
                                                e.addEventListener(
                                                  Xl.b.LostFocus,
                                                  this.onLostFocus
                                                ),
                                                e.addEventListener(
                                                  Xl.b.Focus,
                                                  this.onFocus
                                                ),
                                                (this.appLocked =
                                                  ze.p.getAppLock()),
                                                vd.b.on(
                                                  vd.a.APP_LOCKED,
                                                  this.onAppLock
                                                ),
                                                vd.b.on(
                                                  vd.a.APP_UNLOCKED,
                                                  this.onAppUnLock
                                                );
                                            }
                                            onAuthenticated() {
                                              (this.authenticated = !0),
                                                this.isEnable() &&
                                                  this.service.onLogin();
                                            }
                                            onDispose() {
                                              if (!this.isRunning) return;
                                              (this.isRunning = !1),
                                                this.machine.stop();
                                              const e =
                                                a.ModuleContainer.resolve(Xl.c);
                                              e.removeEventListener(
                                                Xl.b.LostFocus,
                                                this.onLostFocus
                                              ),
                                                e.removeEventListener(
                                                  Xl.b.Focus,
                                                  this.onFocus
                                                ),
                                                vd.b.off(
                                                  vd.a.APP_LOCKED,
                                                  this.onAppLock
                                                ),
                                                vd.b.off(
                                                  vd.a.APP_UNLOCKED,
                                                  this.onAppUnLock
                                                ),
                                                this.clearBackgroundTracking();
                                            }
                                            isConfigsReallyChanged() {
                                              for (const e in this.config.get(
                                                "online_configs"
                                              ))
                                                if (
                                                  e &&
                                                  this.lastConfig[e] !==
                                                    this.config.get(
                                                      `online_configs.${e}`
                                                    )
                                                )
                                                  return !0;
                                              return !1;
                                            }
                                            setupBackgroundTracking() {
                                              this.ipc.send(
                                                "active-deactive:setup",
                                                {
                                                  delta:
                                                    I.default.online_configs
                                                      .idle_interval_check,
                                                  inactiveTime:
                                                    I.default.online_configs
                                                      .idle_time,
                                                  trackActive:
                                                    I.default.online_configs
                                                      .track_inactive_alive_back,
                                                  currStatus:
                                                    this.service.getStatus(),
                                                  backgroundTracking:
                                                    I.default.online_configs
                                                      .enable_background_tracking,
                                                  fullBgTracking:
                                                    this.isEnableFullBackgroundTrack(),
                                                }
                                              ),
                                                this.ipc.on(
                                                  "active-deactive:active",
                                                  this.onActiveFromBackground
                                                ),
                                                this.ipc.on(
                                                  "active-deactive:deactive",
                                                  this.onDeactiveFromBackground
                                                );
                                            }
                                            clearBackgroundTracking() {
                                              this.ipc.send(
                                                "active-deactive:clear-timer",
                                                this.isEnableBackgroundTrack()
                                              ),
                                                this.ipc.removeListener(
                                                  "active-deactive:active",
                                                  this.onActiveFromBackground
                                                ),
                                                this.ipc.removeListener(
                                                  "active-deactive:deactive",
                                                  this.onDeactiveFromBackground
                                                );
                                            }
                                            onUserSendMessage() {
                                              this.isEnable() &&
                                                this.machine.send(
                                                  "INAPP_INTERACT"
                                                );
                                            }
                                            onUserLogOff() {
                                              return new Promise((e) => {
                                                if (
                                                  !this.isEnable() ||
                                                  !this.isUsingApp()
                                                )
                                                  return e(!1);
                                                this.machine.onceDeactive(
                                                  () => {
                                                    e(!0);
                                                  }
                                                ),
                                                  this.machine.send({
                                                    type: "LOG_OFF",
                                                    status: 3,
                                                  }),
                                                  this.onDispose(),
                                                  setTimeout(() => {
                                                    e(!0);
                                                  }, 1e3);
                                              });
                                            }
                                            onOSEvent(e) {
                                              if (!this.isEnable()) return;
                                              const t = fd.get(e);
                                              _.default.send(
                                                y.GeneralActions
                                                  .USER_ACTIVE_CHANGED,
                                                t
                                              ),
                                                this.logger.zsymb(
                                                  3,
                                                  10088,
                                                  30009,
                                                  "handle event os ",
                                                  t
                                                );
                                            }
                                            isUsingApp() {
                                              const e =
                                                this.appLocked ||
                                                ze.p.getWaitRestart();
                                              return this.authenticated && !e;
                                            }
                                            isEnable() {
                                              return this.config.get(
                                                "online_configs.enable_active_deactive_v2"
                                              );
                                            }
                                            isEnableBackgroundTrack() {
                                              return this.config.get(
                                                "online_configs.enable_background_tracking"
                                              );
                                            }
                                            isEnableFullBackgroundTrack() {
                                              return this.config.get(
                                                "online_configs.enable_full_bg_tracking"
                                              );
                                            }
                                            get pingInterval() {
                                              return this.config.get(
                                                "online_configs.update_action_interval"
                                              );
                                            }
                                            get idleTime() {
                                              return this.config.get(
                                                "online_configs.idle_time"
                                              );
                                            }
                                          })
                                        ) || md)
                                    ) || md)
                                ) || md)
                            ) || md)
                        ) || md)
                    ) || md)
                ) || md)
            ) || md)
        ) || md;
      var _d,
        Sd,
        yd,
        Cd,
        Id = s("yK2b");
      !(function (e) {
        (e[(e.ActiveBackground = 0)] = "ActiveBackground"),
          (e[(e.KeepActiveForeground = 1)] = "KeepActiveForeground"),
          (e[(e.FirstActiveForeground = 2)] = "FirstActiveForeground"),
          (e[(e.ToBackground = 3)] = "ToBackground"),
          (e[(e.KeepActiveBackground = 4)] = "KeepActiveBackground");
      })(Sd || (Sd = {})),
        (function (e) {
          (e[(e.Idle = 0)] = "Idle"),
            (e[(e.ComputerLock = 1)] = "ComputerLock"),
            (e[(e.AppLock = 2)] = "AppLock"),
            (e[(e.LogOff = 3)] = "LogOff");
        })(yd || (yd = {})),
        (function (e) {
          (e[(e.Foreground = 0)] = "Foreground"),
            (e[(e.BackgroundActive = 1)] = "BackgroundActive"),
            (e[(e.BackgroundDeactive = 2)] = "BackgroundDeactive");
        })(Cd || (Cd = {}));
      const Od = {
        [Cd.Foreground]: Sd.KeepActiveForeground,
        [Cd.BackgroundActive]: Sd.KeepActiveBackground,
      };
      let Ed =
        Object(a.injectable)()(
          (_d =
            (function (e, t) {
              return Object(a.inject)(li.a)(e, void 0, 0);
            })(
              (_d =
                (function (e, t) {
                  return Object(a.inject)(O.ZLoggerFactory)(e, void 0, 1);
                })(
                  (_d =
                    (function (e, t) {
                      return Object(a.inject)(Xl.c)(e, void 0, 2);
                    })(
                      (_d =
                        Reflect.metadata(
                          "design:type",
                          Function
                        )(
                          (_d =
                            Reflect.metadata("design:paramtypes", [
                              void 0 === li.a ? Object : li.a,
                              void 0 === O.ZLoggerFactory
                                ? Object
                                : O.ZLoggerFactory,
                              void 0 === Xl.c ? Object : Xl.c,
                            ])(
                              (_d = class {
                                constructor(e, t, s) {
                                  (this.config = e),
                                    (this.focusManager = s),
                                    Object(i.a)(this, "logger", void 0),
                                    Object(i.a)(this, "_ipc", void 0),
                                    Object(i.a)(this, "pingTimer", void 0),
                                    Object(i.a)(this, "deactiveTimer", void 0),
                                    Object(i.a)(this, "status", void 0),
                                    Object(i.a)(this, "configChanged", void 0),
                                    (this.logger = t.createZLogger(
                                      Ut.b.activeDeactive,
                                      [Ut.b.service]
                                    )),
                                    (this.status = Cd.Foreground),
                                    (this.configChanged = !1);
                                }
                                get ipc() {
                                  if (!this._ipc) {
                                    const { ipcRenderer: e } = s("NLsH");
                                    this._ipc = e;
                                  }
                                  return this._ipc;
                                }
                                get pingInterval() {
                                  return this.config.get(
                                    "online_configs.update_action_interval"
                                  );
                                }
                                get deactiveTimeout() {
                                  return this.config.get(
                                    "online_configs.idleTime"
                                  );
                                }
                                get enableSendDeactiveOnBgIdle() {
                                  return this.config.get(
                                    "online_configs.enable_deact_on_bg_idle"
                                  );
                                }
                                get enableSendDeactiveOnFgIdle() {
                                  return this.config.get(
                                    "online_configs.enable_deact_on_fg_idle"
                                  );
                                }
                                get enSendActiveToKeepAlive() {
                                  return this.config.get(
                                    "online_configs.send_active_to_keep_live"
                                  );
                                }
                                get enActiveUsingSocket() {
                                  return this.config.get(
                                    "online_configs.send_active_using_socket"
                                  );
                                }
                                get enableBackgroundTracking() {
                                  return this.config.get(
                                    "online_configs.enable_background_tracking"
                                  );
                                }
                                get enableFeature() {
                                  return this.config.get(
                                    "online_configs.enable_active_deactive_v2"
                                  );
                                }
                                get enableFullBackgroundTrack() {
                                  return this.config.get(
                                    "online_configs.enable_full_bg_tracking"
                                  );
                                }
                                onLogin() {
                                  this.sendActiveToServer(Sd.ActiveBackground);
                                }
                                startTrackIdle(e = !0) {
                                  this.enableBackgroundTracking
                                    ? (this.logger.zsymb(
                                        0,
                                        9596,
                                        30001,
                                        "startTrackIdle"
                                      ),
                                      this.ipc.send(
                                        "active-deactive:create-timer",
                                        e
                                      ))
                                    : this.logger.zsymb(
                                        0,
                                        9596,
                                        3e4,
                                        "in startTrackIdle but flag off"
                                      );
                                }
                                stopTrackIdle() {
                                  this.logger.zsymb(
                                    0,
                                    9596,
                                    30002,
                                    "stopTrackIdle"
                                  ),
                                    this.ipc.send(
                                      "active-deactive:clear-timer",
                                      this.enableBackgroundTracking
                                    );
                                }
                                startForegroundMode() {
                                  (this.status = Cd.Foreground),
                                    this.sendActiveToServer(
                                      Sd.FirstActiveForeground
                                    ),
                                    this.clearPingTimer(),
                                    this.createPingTimer(),
                                    this.enableFullBackgroundTrack ||
                                      this.stopTrackIdle();
                                }
                                keepForegroundMode() {
                                  this.sendActiveToServer(
                                    Sd.KeepActiveForeground,
                                    { additionText: "[Send Msg] " }
                                  );
                                }
                                startBackgroundMode() {
                                  (this.status = Cd.BackgroundActive),
                                    this.enableBackgroundTracking ||
                                      this.clearPingTimer(),
                                    this.enableBackgroundTracking &&
                                      this.createPingTimer(),
                                    this.startTrackIdle();
                                }
                                activeInBackground(e) {
                                  const t = e
                                    ? Sd.ActiveBackground
                                    : Sd.KeepActiveBackground;
                                  this.pingTimer
                                    ? this.logger.zsymb(
                                        0,
                                        9596,
                                        30003,
                                        "user action bg but dont need ping because in ping interval"
                                      )
                                    : this.sendActiveToServer(t);
                                }
                                startDeactive(e) {
                                  let t = -1;
                                  switch (e) {
                                    case 0:
                                      t = yd.Idle;
                                      break;
                                    case 1:
                                      t = yd.ComputerLock;
                                      break;
                                    case 2:
                                      t = yd.AppLock;
                                      break;
                                    case 3:
                                      t = yd.LogOff;
                                  }
                                  this.clearPingTimer(),
                                    -1 !== t &&
                                      this.canSendDeactive(t) &&
                                      this.sendDeactiveToServer(t),
                                    this.status === Cd.Foreground &&
                                      t == yd.Idle &&
                                      this.startTrackIdle(!1),
                                    (t != yd.ComputerLock && t != yd.AppLock) ||
                                      this.stopTrackIdle(),
                                    (this.status = Cd.BackgroundDeactive);
                                }
                                onConfigUpdated() {
                                  (this.configChanged = !0),
                                    this.enableFeature || this.clearPingTimer();
                                }
                                getStatus() {
                                  return this.status;
                                }
                                createPingTimer() {
                                  !this.pingTimer &&
                                    this.enableFeature &&
                                    (this.logger.zsymb(
                                      0,
                                      9596,
                                      30004,
                                      "createPingTimer"
                                    ),
                                    (this.configChanged = !1),
                                    (this.pingTimer = setInterval(() => {
                                      const e = Od[this.status];
                                      e
                                        ? this.sendPingActive(e)
                                        : this.logger.zsymb(
                                            0,
                                            9596,
                                            30005,
                                            "call ping invalid state!"
                                          ),
                                        this.configChanged &&
                                          (this.clearPingTimer(),
                                          this.createPingTimer());
                                    }, this.pingInterval)));
                                }
                                clearPingTimer() {
                                  this.logger.zsymb(
                                    0,
                                    9596,
                                    30006,
                                    "clearPingTimer"
                                  ),
                                    clearInterval(this.pingTimer),
                                    (this.pingTimer = null);
                                }
                                async isUserHasAction(e) {
                                  let t = this.focusManager.getAppIdleTime();
                                  {
                                    const e = await this.ipc.invoke(
                                      "active-deactive:get-idle-time"
                                    );
                                    t = Math.min(t, e);
                                  }
                                  return t < e;
                                }
                                canSendDeactive(e) {
                                  return (
                                    e !== yd.Idle ||
                                    (this.status === Cd.Foreground &&
                                      this.enableSendDeactiveOnFgIdle) ||
                                    (this.status === Cd.BackgroundActive &&
                                      this.enableSendDeactiveOnBgIdle)
                                  );
                                }
                                async sendPingActive(e) {
                                  (await this.isUserHasAction(
                                    this.pingInterval
                                  ))
                                    ? this.sendActiveToServer(e)
                                    : this.logger.zsymb(
                                        3,
                                        9596,
                                        30007,
                                        "call ping but discard, because the user don't have action!"
                                      );
                                }
                                sendActiveToServer(
                                  e,
                                  t = { additionText: "" }
                                ) {
                                  const { additionText: s } = t;
                                  if (
                                    !this.enActiveUsingSocket ||
                                    Id.default.getMsgSrcType() !==
                                      w.MsgSources.SOCKET
                                  )
                                    return this.sendActiveViaHttp(e, s);
                                  let i = null;
                                  return (
                                    (i = this.enSendActiveToKeepAlive
                                      ? Es.default.pingActiveViaKeepAlive(e)
                                      : Es.default.pingActive(e)),
                                    i
                                      .then(
                                        () => (
                                          this.logger.zsymb(
                                            3,
                                            9596,
                                            30008,
                                            "{}Call active app SUCCESS: socket - {}",
                                            s,
                                            e
                                          ),
                                          !0
                                        )
                                      )
                                      .catch(
                                        (t) => (
                                          this.logger.zsymb(
                                            21,
                                            9596,
                                            30009,
                                            "{}Call active fail: socket - {} - {}",
                                            s,
                                            e,
                                            JSON.stringify(t)
                                          ),
                                          this.sendActiveViaHttp(e)
                                        )
                                      )
                                  );
                                }
                                sendActiveViaHttp(e, t = "") {
                                  return new Promise((s) => {
                                    an.default
                                      .active(e)
                                      .then(tn.a)
                                      .then(() => {
                                        this.logger.zsymb(
                                          3,
                                          9596,
                                          30010,
                                          "{}Call active app SUCCESS: http - {}",
                                          t,
                                          e
                                        ),
                                          s(!0);
                                      })
                                      .catch((i) => {
                                        this.logger.zsymb(
                                          21,
                                          9596,
                                          30011,
                                          "{}Call active fail: http - {} - {}",
                                          t,
                                          e,
                                          JSON.stringify(i)
                                        ),
                                          s(!1);
                                      });
                                  });
                                }
                                sendDeactiveToServer(e) {
                                  return an.default
                                    .deactiveV2()
                                    .then(tn.a)
                                    .then(
                                      () => (
                                        this.logger.zsymb(
                                          3,
                                          9596,
                                          30012,
                                          "Call deactive app SUCCESS {}",
                                          e
                                        ),
                                        !0
                                      )
                                    )
                                    .catch(
                                      (e) => (
                                        this.logger.zsymb(
                                          21,
                                          9596,
                                          30013,
                                          "Call deactive fail: ",
                                          JSON.stringify(e)
                                        ),
                                        !1
                                      )
                                    );
                                }
                              })
                            ) || _d)
                        ) || _d)
                    ) || _d)
                ) || _d)
            ) || _d)
        ) || _d;
      a.ModuleContainer.registerSingleton(ad, hd),
        a.ModuleContainer.registerSingleton(Xl.c, id),
        a.ModuleContainer.registerSingleton(nd, Ed),
        a.ModuleContainer.resolve(Xl.c),
        a.ModuleContainer.resolveToken(ld),
        a.ModuleContainer.resolveToken(bd);
      s("rBRb");
      var Td,
        Rd = s("jbAT"),
        Ld = s("zLd2"),
        Md = s("5txd");
      Object(a.injectable)()(
        (Td =
          Object(a.singleton)(Ld.c)(
            (Td =
              (function (e, t) {
                return Object(a.inject)(Rd.b)(e, void 0, 0);
              })(
                (Td =
                  (function (e, t) {
                    return Object(a.inject)(O.ZLoggerFactory)(e, void 0, 1);
                  })(
                    (Td =
                      Reflect.metadata(
                        "design:type",
                        Function
                      )(
                        (Td =
                          Reflect.metadata("design:paramtypes", [
                            void 0 === Rd.a ? Object : Rd.a,
                            void 0 === O.ZLoggerFactory
                              ? Object
                              : O.ZLoggerFactory,
                          ])(
                            (Td = class {
                              constructor(e, t) {
                                Object(i.a)(
                                  this,
                                  "_utilsMediaAppService",
                                  void 0
                                ),
                                  Object(i.a)(this, "_logger", void 0),
                                  Object(i.a)(this, "_log", void 0),
                                  (this._utilsMediaAppService = e),
                                  N.a.ConvInfoDataManager.addEventListener(
                                    Et.b.DeleteConv,
                                    this._onDeleteConversation.bind(this)
                                  ),
                                  N.a.ConvInfoDataManager.addEventListener(
                                    Et.b.EmptyConv,
                                    this._onEmptyConversation.bind(this)
                                  ),
                                  (this._logger = t.createZLogger(Ld.b, [
                                    "manage-utils-media-in-ui",
                                  ])),
                                  (this._log = Object(Md.a)(this._logger));
                              }
                              create(e) {
                                return this._utilsMediaAppService.create(e);
                              }
                              createOrUpdate(e) {
                                return this._utilsMediaAppService.createOrUpdate(
                                  e
                                );
                              }
                              async createOrUpdateFromMedias(e) {
                                return this._utilsMediaAppService.createOrUpdateFromMedias(
                                  e
                                );
                              }
                              _onDeleteConversation(e) {
                                const { convId: t } = e;
                                this._utilsMediaAppService.deleteUtilsMediasByConvId(
                                  t
                                );
                              }
                              _onEmptyConversation(e) {
                                const { convId: t } = e;
                                this._utilsMediaAppService.deleteUtilsMediasByConvId(
                                  t
                                );
                              }
                            })
                          ) || Td)
                      ) || Td)
                  ) || Td)
              ) || Td)
          ) || Td)
      );
      s("37f1");
      var Fd,
        wd = s("lT2C"),
        Dd = s("C8zZ"),
        jd = s("wmCV");
      let Ad =
        Object(B.b)(Dd.GroupPollManager)(
          (Fd =
            (function (e, t) {
              return a.ModuleContainer.inject(me.b)(e, void 0, 0);
            })(
              (Fd =
                Reflect.metadata(
                  "design:type",
                  Function
                )(
                  (Fd =
                    Reflect.metadata("design:paramtypes", [
                      void 0 === me.b ? Object : me.b,
                    ])(
                      (Fd = class {
                        constructor(e) {
                          (this.convDataManager = e),
                            Object(i.a)(this, "_Logger", void 0),
                            Object(i.a)(this, "pollCache", void 0),
                            (this.pollCache = new u.default({ maxSize: 1e4 })),
                            this.setUpEvent();
                        }
                        get Logger() {
                          return (
                            this._Logger ||
                              (this._Logger = a.ModuleContainer.resolve(
                                O.ZLoggerFactory
                              ).createZLogger(Ut.b.pollV3, [
                                Ut.b.groupPollManager,
                              ])),
                            this._Logger
                          );
                        }
                        updatePollCache(e, t) {
                          this.pollCache.set(e, t);
                        }
                        removePollCacheBelongsToConv(e) {
                          Array.from(this.pollCache.entriesAscending()).forEach(
                            ([t, s]) => {
                              s.group_id ===
                                b.default.getGroupIdFromConversationId(e) &&
                                this.pollCache.delete(t);
                            }
                          );
                        }
                        setUpEvent() {
                          this.convDataManager.addEventListener(
                            Et.b.DeleteConv,
                            (e) => {
                              this.removePollCacheBelongsToConv(e.convId);
                            }
                          ),
                            this.convDataManager.addEventListener(
                              Et.b.EmptyConv,
                              (e) => {
                                this.removePollCacheBelongsToConv(e.convId);
                              }
                            ),
                            this.convDataManager.addEventListener(
                              Et.b.LeaveGroup,
                              (e) => {
                                this.removePollCacheBelongsToConv(e.convId);
                              }
                            );
                        }
                        isAdmin(e, t) {
                          var s;
                          const i = ne.default.getGroupByIdSync(e);
                          if (!i) return !1;
                          if (t === i.creatorId) return !0;
                          let a = !1;
                          return (
                            null === (s = i.topMember) ||
                              void 0 === s ||
                              s.forEach((e) => {
                                e.id === t && e.isAdmin && (a = !0);
                              }),
                            a
                          );
                        }
                        isAllowSetTopic(e) {
                          var t;
                          const s = ne.default.getGroupByIdSync(e);
                          return (
                            !!s &&
                            !(
                              !I.default.group_topics.enable ||
                              (null !== (t = s.setting) &&
                                void 0 !== t &&
                                t.setTopicOnly)
                            )
                          );
                        }
                        isEnablePin(e) {
                          return (
                            this.isAdmin(e, D.default.getUidMe()) ||
                            this.isAllowSetTopic(e)
                          );
                        }
                        isEnableClose(e, t) {
                          const s = D.default.getUidMe();
                          return this.isAdmin(e, s) || s === t;
                        }
                        createPollRequestData(e) {
                          const { pollData: t, groupId: s, src: i } = e,
                            a = {
                              question: t.question,
                              options: t.options,
                              expired_time: t.expiredTime,
                              pinAct: t.pinAct,
                              allow_multi_choices: t.allowMultiChoices,
                              allow_add_new_option: t.allowAddNewOption,
                              is_hide_vote_preview: t.isHideVotePreview,
                              is_anonymous: t.isAnonymous,
                              poll_type: t.pollType,
                            };
                          return {
                            groupId: b.default.getGroupIdFromConversationId(s),
                            pollData: a,
                            src: i,
                          };
                        }
                        async createPoll(e) {
                          const t = e.pollData.pinAct,
                            {
                              groupId: s,
                              pollData: i,
                              src: a,
                            } = this.createPollRequestData(e);
                          try {
                            const n = await is.default.createPoll(s, i, a);
                            t && this.pinPoll(n.poll_id, e.groupId, n.question);
                          } catch (n) {
                            throw (this.Logger.zsymb(18, 11473, 3e4, n), n);
                          }
                        }
                        getPollDetailSync(e) {
                          return this.pollCache.get(e);
                        }
                        async getPollDetail(e, t) {
                          let s = this.getPollDetailSync(e);
                          if (s) return s;
                          if (((s = await $e.default.getPollInfo(e)), !s)) {
                            if (t) return this.getPollDetailFromServer(e);
                            throw Error("Poll isn't existed in DB");
                          }
                          return this.pollCache.set(e, s), s;
                        }
                        async getPollDetailFromServer(e, t) {
                          const s = await is.default.getPollDetail(t, e, !1);
                          if (!s) throw Error("Poll isn't existed in Server");
                          return this.pollCache.set(e, s), s;
                        }
                        async pinPoll(e, t, s) {
                          let i = s;
                          if (!i) {
                            let t = this.getPollDetailSync(e);
                            if ((t || (t = await this.getPollDetail(e)), !t))
                              throw Error("Poll isn't existed");
                            i = t.question;
                          }
                          jd.a.pinFromBoard(
                            { userId: t },
                            { poll_id: e, isPoll: !0, question: i },
                            null,
                            null,
                            Yr.a.getWinIdByConvId(t)
                          );
                        }
                        unpinPoll(e, t) {
                          jd.a.unpinFromBoard(t, { poll_id: e, isPoll: !0 });
                        }
                        async lockPoll(e) {
                          const t = this.getPollDetailSync(e);
                          if (!t || !t.closed)
                            try {
                              is.default.lockPoll(e);
                            } catch (s) {
                              this.Logger.zsymb(
                                18,
                                11473,
                                30001,
                                "[lockPoll] ",
                                e,
                                s
                              );
                            }
                        }
                        async sharePollInGroup(e) {
                          try {
                            is.default.sharePoll(e);
                          } catch (t) {
                            this.Logger.zsymb(
                              18,
                              11473,
                              30002,
                              "[sharePollInGroup] ",
                              e,
                              t
                            );
                          }
                        }
                        async votePoll(e) {
                          const {
                              newOptions: t,
                              pollId: s,
                              votedOptionIds: i,
                            } = e,
                            a = b.default.getGroupIdFromConversationId(
                              e.groupId
                            );
                          try {
                            t.length > 0
                              ? await is.default.addNewOptionPoll(
                                  a,
                                  s,
                                  JSON.stringify(t),
                                  i
                                )
                              : await is.default.vote(a, s, i);
                          } catch (n) {
                            throw (
                              (this.Logger.zsymb(
                                18,
                                11473,
                                30003,
                                "[votePoll] ",
                                n,
                                s
                              ),
                              n)
                            );
                          }
                        }
                      })
                    ) || Fd)
                ) || Fd)
            ) || Fd)
        ) || Fd;
      var Nd,
        Pd = s("ILDi");
      let kd =
        Object(B.b)(Dd.GroupPollInfoManager)(
          (Nd =
            Reflect.metadata(
              "design:type",
              Function
            )(
              (Nd =
                Reflect.metadata(
                  "design:paramtypes",
                  []
                )(
                  (Nd = class {
                    constructor() {
                      Object(i.a)(this, "updateEmitter", void 0),
                        Object(i.a)(this, "viewedMoreFromMsgIds", void 0),
                        (this.updateEmitter = new no.a()),
                        (this.viewedMoreFromMsgIds = new Set());
                    }
                    getPollParams(e) {
                      let t = null;
                      try {
                        var s;
                        t = JSON.parse(
                          null == e || null === (s = e.message) || void 0 === s
                            ? void 0
                            : s.params
                        );
                      } catch (i) {
                        t = {};
                      }
                      return t;
                    }
                    getLastMessagePoll(e, t, s) {
                      let i = t;
                      return (
                        s.forEach((s) => {
                          s.msgType !== t.msgType ||
                            this.getPollParams(s).pollId !== e ||
                            (i = s);
                        }),
                        i
                      );
                    }
                    getContinuosPollInfoSection(e, t) {
                      const s = [];
                      let i = 0;
                      return (
                        t.forEach((t) => {
                          var a;
                          t.msgType === w.MSG_POLL &&
                          this.getPollParams(t).pollId === e
                            ? (s[i] || (s[i] = []), s[i].push(t))
                            : null !== (a = s[i]) &&
                              void 0 !== a &&
                              a[0] &&
                              (i += 1);
                        }),
                        s.filter(
                          (e) =>
                            e.length > I.default.groupPoll.max_info_msg_display
                        )
                      );
                    }
                    isShowPollCard(e, t, s) {
                      const i = this.getLastMessagePoll(e, t, s);
                      return pa.b.isSameMsg(t, i);
                    }
                    getPollInfoShowStatus(e, t, s) {
                      const i = this.getContinuosPollInfoSection(e, s);
                      for (const a of i)
                        for (let e = a.length - 1; e >= 0; e--)
                          if (pa.b.isSameMsg(t, a[e]))
                            return e !== a.length - 1
                              ? "HIDE"
                              : a[e - 1] &&
                                this.viewedMoreFromMsgIds.has(a[e - 1].msgId)
                              ? "SHOW"
                              : "SHOW_VIEW_MORE";
                      return "SHOW";
                    }
                    viewMore(e, t, s) {
                      let i = [];
                      const a = this.getContinuosPollInfoSection(e, s);
                      for (const n of a)
                        if (n[n.length - 1].msgId === t) {
                          i = n.map((e) => e.msgId);
                          break;
                        }
                      this.updateEmitter.emit("EXPAND_MSG_INFO", { msgIds: i }),
                        this.viewedMoreFromMsgIds.add(t);
                    }
                    clearViewedMoreHistory(e) {
                      this.viewedMoreFromMsgIds.delete(e);
                    }
                  })
                ) || Nd)
            ) || Nd)
        ) || Nd;
      a.ModuleContainer.registerSingleton(wd.a, Ad),
        a.ModuleContainer.registerSingleton(Pd.a, kd);
      var Ud,
        Bd = s("qLo6");
      Object(j.e)()(
        (Ud = class {
          onAuthenticated(e) {
            I.default.e2ee.enable_wasm &&
              Bd.AesGcmWasmFactory.instance
                .installAndTestWasm()
                .then(() => {})
                .catch((e) => {});
          }
        })
      );
      s("ycwz");
      var Gd = s("imbw"),
        zd = s("1EWQ");
      const xd = 1,
        Vd = 2,
        qd = 3;
      let Hd, Kd, $d, Wd, Zd, Qd, Yd;
      var Jd;
      !(function (e) {
        (e[(e.TEXT = 0)] = "TEXT"),
          (e[(e.STICKER = 1)] = "STICKER"),
          (e[(e.PHOTO = 2)] = "PHOTO"),
          (e[(e.LINK = 3)] = "LINK"),
          (e[(e.FILE = 4)] = "FILE"),
          (e[(e.GIF = 5)] = "GIF"),
          (e[(e.CONTACT = 6)] = "CONTACT");
      })(Hd || (Hd = {})),
        (function (e) {
          (e[(e.CHAT_11 = 1)] = "CHAT_11"),
            (e[(e.CHAT_GROUP = 2)] = "CHAT_GROUP"),
            (e[(e.MY_CLOUD = 3)] = "MY_CLOUD");
        })(Kd || (Kd = {})),
        (function (e) {
          (e[(e.SINGLE = 0)] = "SINGLE"), (e[(e.GROUP = 1)] = "GROUP");
        })($d || ($d = {})),
        (function (e) {
          (e[(e.CONTEXT_MENU = 0)] = "CONTEXT_MENU"),
            (e[(e.BUBBLE = 1)] = "BUBBLE");
        })(Wd || (Wd = {})),
        (function (e) {
          (e[(e.RESEND = 1)] = "RESEND"), (e[(e.DELETE = 2)] = "DELETE");
        })(Zd || (Zd = {})),
        (function (e) {
          (e[(e.NO_RESEND = 1)] = "NO_RESEND"),
            (e[(e.RESEND_SINGLE = 2)] = "RESEND_SINGLE"),
            (e[(e.RESEND_ALL = 3)] = "RESEND_ALL");
        })(Qd || (Qd = {})),
        (function (e) {
          (e[(e.NO_DELETE = 1)] = "NO_DELETE"),
            (e[(e.DELETE_SINGLE = 2)] = "DELETE_SINGLE"),
            (e[(e.DELETE_ALL = 3)] = "DELETE_ALL");
        })(Yd || (Yd = {}));
      let Xd =
        Object(B.b)(Gd.a)(
          (Jd =
            Reflect.metadata(
              "design:type",
              Function
            )(
              (Jd =
                Reflect.metadata(
                  "design:paramtypes",
                  []
                )(
                  (Jd = class {
                    constructor() {
                      Object(i.a)(this, "lastNetworkBannerAppearTime", void 0),
                        Object(i.a)(this, "logger", void 0),
                        (this.lastNetworkBannerAppearTime = null);
                    }
                    get Logger() {
                      return (
                        this.logger ||
                          (this.logger = a.ModuleContainer.resolve(
                            O.ZLoggerFactory
                          ).createZLogger("auto-retry", ["action-log"])),
                        this.logger
                      );
                    }
                    logAction999(e) {
                      const { type: t, payload: s } = e;
                      let i;
                      switch (t) {
                        case "ShowManualRetry":
                          i = xd;
                          break;
                        case "InteractManualRetry":
                          i = Vd;
                          break;
                        case "ShowBannerNetwork":
                          i = qd;
                      }
                      Z.e.logActionInfoV2(Z.b.AutoRetry, i, s);
                    }
                    getChatTypeFromConvId(e) {
                      return b.default.isGroup(e)
                        ? Kd.CHAT_GROUP
                        : zd.a.isSendToMe(e)
                        ? Kd.MY_CLOUD
                        : Kd.CHAT_11;
                    }
                    getRetryMsgType(e) {
                      switch (e) {
                        case w.MSG_TEXT:
                          return Hd.TEXT;
                        case w.MSG_GIF:
                          return Hd.GIF;
                        case w.MSG_FILE:
                        case w.MSG_VIDEO:
                          return Hd.FILE;
                        case w.MSG_PHOTO:
                        case w.MSG_PHOTO_GROUP:
                          return Hd.PHOTO;
                        case w.MSG_CONTACT:
                          return Hd.CONTACT;
                        case w.MSG_STICKER:
                        case w.MSG_STICKER_GROUP:
                        case w.MSG_STICKER_2:
                          return Hd.STICKER;
                        case w.MSG_LINK_CLIENT:
                          return Hd.LINK;
                        default:
                          return;
                      }
                    }
                    getMsgCombineType(e) {
                      return [w.MSG_PHOTO_GROUP, w.MSG_STICKER_GROUP].includes(
                        e
                      )
                        ? $d.GROUP
                        : $d.SINGLE;
                    }
                    showManualRetryReport(e) {
                      const t = this.getRetryMsgType(e.msgType);
                      void 0 !== t &&
                        this.logAction999({
                          type: "ShowManualRetry",
                          payload: {
                            msg_type: t,
                            chat_type: this.getChatTypeFromConvId(
                              e.conversationId
                            ),
                            error_id: e.errorCode,
                            is_groupping: this.getMsgCombineType(e.msgType),
                          },
                        });
                    }
                    networkBannerAppearCapture() {
                      this.lastNetworkBannerAppearTime = Y.a.getTimeNow();
                    }
                    networkBannerDisappearReport() {
                      const e = Y.a.getTimeNow();
                      if (null === this.lastNetworkBannerAppearTime) return;
                      const t = e - this.lastNetworkBannerAppearTime;
                      t <= 0 ||
                        (this.logAction999({
                          type: "ShowBannerNetwork",
                          payload: {
                            showed_time: this.lastNetworkBannerAppearTime,
                            off_time: e,
                            duration: t,
                          },
                        }),
                        (this.lastNetworkBannerAppearTime = null));
                    }
                    resendErrorMessageReport(e) {
                      const t = this.getRetryMsgType(e.msgType);
                      void 0 !== t &&
                        this.logAction999({
                          type: "InteractManualRetry",
                          payload: {
                            msg_type: t,
                            chat_type: this.getChatTypeFromConvId(
                              e.conversationId
                            ),
                            is_groupping: this.getMsgCombineType(e.msgType),
                            is_entrypoint: Wd[e.source],
                            is_resend:
                              this.getMsgCombineType(e.msgType) === $d.GROUP
                                ? Qd.RESEND_ALL
                                : Qd.RESEND_SINGLE,
                            is_deleted: Yd.NO_DELETE,
                            action_type: Zd.RESEND,
                          },
                        });
                    }
                    deleteErrorMessageReport(e) {
                      const t = this.getRetryMsgType(e.msgType);
                      void 0 !== t &&
                        this.logAction999({
                          type: "InteractManualRetry",
                          payload: {
                            msg_type: t,
                            chat_type: this.getChatTypeFromConvId(
                              e.conversationId
                            ),
                            is_groupping: this.getMsgCombineType(e.msgType),
                            is_entrypoint: Wd[e.source],
                            is_resend: Qd.NO_RESEND,
                            is_deleted:
                              this.getMsgCombineType(e.msgType) === $d.GROUP
                                ? Yd.DELETE_ALL
                                : Yd.DELETE_SINGLE,
                            action_type: Zd.DELETE,
                          },
                        });
                    }
                  })
                ) || Jd)
            ) || Jd)
        ) || Jd;
      a.ModuleContainer.registerSingleton(Gd.a, Xd);
      var eh,
        th = s("Z1oQ"),
        sh = s("QbTC"),
        ih = s("xtzN"),
        ah = s("n32m"),
        nh = s("hKna");
      let rh =
        Object(B.b)(ah.RetryErrorController)(
          (eh =
            Reflect.metadata(
              "design:type",
              Function
            )(
              (eh =
                Reflect.metadata(
                  "design:paramtypes",
                  []
                )(
                  (eh = class {
                    constructor() {
                      Object(i.a)(this, "logger", void 0),
                        Object(i.a)(this, "errNetworkCounterMap", void 0),
                        (this.errNetworkCounterMap = new Map());
                    }
                    get Logger() {
                      return (
                        this.logger ||
                          (this.logger = a.ModuleContainer.resolve(
                            O.ZLoggerFactory
                          ).createZLogger(Ut.b.autoRetry, [
                            "retry-error-controller",
                          ])),
                        this.logger
                      );
                    }
                    getErrNetworkRetryCount(e) {
                      if (!e) return 0;
                      const t = this.errNetworkCounterMap.get(e);
                      if (void 0 !== t)
                        return 0 === t
                          ? (this.errNetworkCounterMap.delete(e), 0)
                          : t;
                      const s =
                        I.default.retryConfig.max_err_network_retry_count;
                      return this.errNetworkCounterMap.set(e, s), s;
                    }
                    decreaseErrNetworkRetryCount(e) {
                      if (!e) return;
                      const t = this.getErrNetworkRetryCount(e);
                      t > 0
                        ? this.errNetworkCounterMap.set(e, t - 1)
                        : this.errNetworkCounterMap.delete(e);
                    }
                    deleteErrNetworkRetryCountItem(e) {
                      e && this.errNetworkCounterMap.delete(e);
                    }
                    logRetryError(e, t) {
                      this.Logger.zsymb(18, 11536, 3e4, e, t);
                    }
                    shouldRetry(e, t, s) {
                      if (!e || nh.a.includes(e.code)) return !1;
                      if (!nh.c.includes(e.code)) return !1;
                      const i = nh.d.NO_NETWORK_ERROR_CODE.includes(e.code);
                      if (
                        i &&
                        (!I.default.retry_err_no_network ||
                          (nn.b.getStateNetwork() !== nn.a.CHECKING &&
                            nn.b.getStateNetwork() !== nn.a.DISCONNECT))
                      )
                        return !1;
                      const a = this.getRetryErrorCodeGroupName(e.code);
                      if (a && this.getRetryErrorCodeMapping()[a].off)
                        return !1;
                      const n = i && this.getErrNetworkRetryCount(s) > 0;
                      if (0 === t.count && !n) return !1;
                      const r = this.getRetryTimeout(t);
                      return (
                        !!(r && Y.a.getTimeNow() - t.timestamp < r) &&
                        (t.count && !i && t.count--,
                        i && this.decreaseErrNetworkRetryCount(s),
                        !0)
                      );
                    }
                    getRetryTimeout(e) {
                      let t = 0;
                      return (
                        I.default.retryConfig &&
                          I.default.retryConfig.setting_feature &&
                          e.timestamp &&
                          e.timeout &&
                          (e.timeout === w.RETRY_MSG_TIMEOUT_DEFAULT
                            ? (t = I.default.retryConfig.time_retry_default)
                            : e.timeout === w.RETRY_MSG_TIMEOUT_LONG &&
                              (t = I.default.retryConfig.time_retry_long)),
                        t
                      );
                    }
                    getRetryErrorCodeGroupName(e) {
                      return Object.keys(nh.d).find((t) => nh.d[t].includes(e));
                    }
                    getNoRetryErrorCodeGroupName(e) {
                      return Object.keys(nh.b).find((t) => nh.b[t].includes(e));
                    }
                    getRetryErrorCodeMapping() {
                      return I.default.retryConfig.retry_strategy &&
                        "object" == typeof I.default.retryConfig.retry_strategy
                        ? Object.keys(
                            I.default.retryConfig.retry_strategy
                          ).reduce(
                            (e, t) => (
                              (e[t.toUpperCase()] =
                                I.default.retryConfig.retry_strategy[t]),
                              e
                            ),
                            {}
                          )
                        : nh.e;
                    }
                  })
                ) || eh)
            ) || eh)
        ) || eh;
      var oh,
        ch = s("yoj5");
      let lh =
        Object(B.b)(sh.a)(
          (oh =
            Reflect.metadata(
              "design:type",
              Function
            )(
              (oh =
                Reflect.metadata(
                  "design:paramtypes",
                  []
                )(
                  (oh = class {
                    constructor() {
                      Object(i.a)(this, "logger", void 0),
                        Object(i.a)(this, "waitingSocketOpenQueue", void 0),
                        Object(i.a)(this, "retryCountMapping", void 0),
                        Object(i.a)(this, "isDoneOffline", void 0),
                        Object(i.a)(
                          this,
                          "handleWaitingConnectionRetry",
                          () => {
                            const e = [...this.waitingSocketOpenQueue];
                            this.waitingSocketOpenQueue = [];
                            for (const t of e) {
                              const e = ch.getGapTime();
                              window.requestIdleCallback(
                                () => {
                                  t();
                                },
                                { timeout: e }
                              );
                            }
                          }
                        ),
                        Object(i.a)(this, "unlockProcessOffline", () => {
                          (this.isDoneOffline = !0),
                            Es.default.getSocketState() === nh.g.OPEN &&
                              this.handleWaitingConnectionRetry();
                        }),
                        (this.waitingSocketOpenQueue = []),
                        (this.retryCountMapping = new Map()),
                        (this.isDoneOffline = !1),
                        _.default.subscribe((e, t) => {
                          if (
                            e === y.WebsocketActions.CONNECTION_STATE_CHANGE
                          ) {
                            const { state: e, prevState: s } = t;
                            void 0 !== s &&
                              e === nh.g.OPEN &&
                              this.isDoneOffline &&
                              this.handleWaitingConnectionRetry();
                          }
                        }),
                        Es.default.subcribe(
                          Es.CallbackID.ON_DONE_OFFLINE,
                          this.unlockProcessOffline
                        );
                    }
                    get Logger() {
                      return (
                        this.logger ||
                          (this.logger = a.ModuleContainer.resolve(
                            O.ZLoggerFactory
                          ).createZLogger("auto-retry-socket", [
                            "retry-error-controller",
                          ])),
                        this.logger
                      );
                    }
                    getRetryTimeout(e) {
                      let t = 0;
                      return (
                        I.default.retryConfig &&
                          I.default.retryConfig.setting_feature &&
                          e.timestamp &&
                          e.timeout &&
                          (e.timeout === w.RETRY_MSG_TIMEOUT_DEFAULT
                            ? (t = I.default.retryConfig.time_retry_default)
                            : e.timeout === w.RETRY_MSG_TIMEOUT_LONG &&
                              (t = I.default.retryConfig.time_retry_long)),
                        t
                      );
                    }
                    getErrorCode(e) {
                      let t = e.code;
                      return (
                        e.code === nh.f.ERR_CONNECTION_TIMED_OUT &&
                          nn.b.getStateNetwork() !== nn.a.CONNECTED &&
                          (t = nh.f.ERR_NO_NETWORK),
                        t
                      );
                    }
                    shouldRetry(e, t, s) {
                      if (!e || !t || !s || s.count <= 0) return !1;
                      let i = this.getErrorCode(e);
                      if (
                        i === nh.f.ERR_CONNECTION_TIMED_OUT ||
                        i === nh.f.ERR_SOCKET_CLOSED ||
                        i === nh.f.ERR_NO_NETWORK
                      ) {
                        var a;
                        const e =
                          null != (a = this.retryCountMapping.get(t)) ? a : 0;
                        let n = I.default.retryConfig.max_retry_count;
                        if (
                          (i === nh.f.ERR_SOCKET_CLOSED &&
                            (n =
                              I.default.retryConfig
                                .max_err_network_retry_count),
                          void 0 !== e && e < n)
                        ) {
                          const e = this.getRetryTimeout(s);
                          return (
                            !!(e && Y.a.getTimeNow() - s.timestamp < e) &&
                            (s.count && s.count--, !0)
                          );
                        }
                        return !1;
                      }
                      return !1;
                    }
                    pushToRetryQueue(e, t, s) {
                      const i = a.ModuleContainer.resolve(
                        th.a
                      ).getRetryErrorCodeMapping();
                      this.logRetryError(e.code, s);
                      const n = this.getErrorCode(e);
                      if (n !== nh.f.ERR_CONNECTION_TIMED_OUT) {
                        var r;
                        if (
                          n === nh.f.ERR_SOCKET_CLOSED ||
                          n === nh.f.ERR_NO_NETWORK
                        )
                          return (
                            this.retryCountMapping.set(
                              s,
                              null != (r = this.retryCountMapping.get(s))
                                ? r
                                : 1
                            ),
                            void this.waitingSocketOpenQueue.push(t)
                          );
                      } else {
                        var o, c;
                        const e =
                            (null != (o = this.retryCountMapping.get(s))
                              ? o
                              : 0) + 1,
                          a =
                            (null !=
                            (c = i.CONNECTION_TIMED_OUT_ERROR_CODE.delay)
                              ? c
                              : 3e4) *
                              e +
                            ch.getGapTime();
                        setTimeout(() => {
                          this.retryCountMapping.set(s, e), t();
                        }, a);
                      }
                    }
                    logRetryError(e, t) {
                      this.Logger.zsymb(18, 11537, 3e4, e, t);
                    }
                    cleanUpItemQueue(e) {
                      this.retryCountMapping.delete(e);
                    }
                  })
                ) || oh)
            ) || oh)
        ) || oh;
      var dh;
      a.ModuleContainer.registerSingleton(th.a, rh),
        a.ModuleContainer.registerSingleton(sh.a, lh),
        a.ModuleContainer.registerSingleton(
          ih.a,
          class {
            constructor() {
              Object(i.a)(this, "waitingNetworkQueue", void 0),
                Object(i.a)(this, "waitingCheckStatusQueue", void 0),
                Object(i.a)(this, "waitingTimeout", void 0),
                Object(i.a)(this, "onConnectionBack", () => {
                  const e = [...this.waitingNetworkQueue];
                  this.waitingNetworkQueue = [];
                  for (const t of e) {
                    const e = ch.getGapTime();
                    window.requestIdleCallback(
                      () => {
                        t();
                      },
                      { timeout: e }
                    );
                  }
                }),
                Object(i.a)(this, "clearWaitingStatusTimeout", () => {
                  null !== this.waitingTimeout &&
                    (window.clearTimeout(this.waitingTimeout),
                    (this.waitingTimeout = null));
                }),
                Object(i.a)(
                  this,
                  "moveWaitingCheckStatusToWaitingConnection",
                  () => {
                    this.clearWaitingStatusTimeout(),
                      this.waitingNetworkQueue.push(
                        ...this.waitingCheckStatusQueue
                      ),
                      (this.waitingCheckStatusQueue = []);
                  }
                ),
                Object(i.a)(this, "processWaitingCheckStatus", () => {
                  this.clearWaitingStatusTimeout();
                  const e = [...this.waitingCheckStatusQueue];
                  this.waitingCheckStatusQueue = [];
                  for (const t of e) {
                    const e = ch.getGapTime();
                    window.requestIdleCallback(
                      () => {
                        t();
                      },
                      { timeout: e }
                    );
                  }
                }),
                (this.waitingNetworkQueue = []),
                (this.waitingCheckStatusQueue = []),
                (this.waitingTimeout = null),
                ze.p.listenEvent(ze.j, (e) => {
                  e === nn.a.CONNECTED
                    ? (this.processWaitingCheckStatus(),
                      this.onConnectionBack())
                    : e === nn.a.DISCONNECT &&
                      this.moveWaitingCheckStatusToWaitingConnection();
                });
            }
            pushToRetryQueue(e) {
              nn.b.getStateNetwork() === nn.a.CONNECTED
                ? (this.waitingCheckStatusQueue.push(e),
                  null === this.waitingTimeout &&
                    (this.waitingTimeout = window.setTimeout(() => {
                      (this.waitingTimeout = null),
                        this.processWaitingCheckStatus();
                    }, I.default.retryConfig.max_waiting_check_status_time)))
                : this.waitingNetworkQueue.push(e);
            }
          }
        );
      const hh = Object(a.define)("entries-transfer-metrics");
      let uh =
        Object(a.injectable)()(
          (dh = class {
            receiveChangeDeviceOnE2eeConvsSignal() {
              this.actionLog(2090211);
            }
            actionLog(e) {
              Z.e.logAction(e);
            }
          })
        ) || dh;
      a.ModuleContainer.registerSingleton(hh, uh);
      class gh {
        static getMinNumberOfE2eeConvs() {
          var e;
          return null ===
            (e = I.default.notify_missing_e2ee_message.conditions) ||
            void 0 === e
            ? void 0
            : e.min_number_of_e2ee_convs;
        }
        static isEnableEntryTransferFromE2ee() {
          return !0 === I.default.notify_missing_e2ee_message.enable;
        }
      }
      var ph;
      Object(a.injectable)()(
        (ph =
          Object(B.b)(wr.a)(
            (ph =
              (function (e, t) {
                return Object(a.inject)(hh)(e, void 0, 0);
              })(
                (ph =
                  Reflect.metadata(
                    "design:type",
                    Function
                  )(
                    (ph =
                      Reflect.metadata("design:paramtypes", [
                        void 0 === hh ? Object : hh,
                      ])(
                        (ph = class extends re.b {
                          get Logger() {
                            return (
                              this._Logger ||
                                (this._Logger = a.ModuleContainer.resolve(
                                  O.ZLoggerFactory
                                ).createZLogger(Ut.b.entriesTransferManager, [
                                  Ut.b.e2eeNotifyMissingMsg,
                                ])),
                              this._Logger
                            );
                          }
                          constructor(e) {
                            super(),
                              Object(i.a)(this, "syncSourceQueue", void 0),
                              Object(i.a)(this, "_Logger", void 0),
                              Object(i.a)(this, "metricts", void 0),
                              (this.syncSourceQueue = []),
                              this.addPublicListeners(),
                              (this.metricts = e);
                          }
                          enSyncSourceQueue(e) {
                            this.syncSourceQueue.push(e),
                              this.Logger.zsymb(
                                0,
                                11471,
                                3e4,
                                "[enSyncSourceQueue] Push entry transfer in queue: " +
                                  JSON.stringify(e)
                              );
                          }
                          isEmptySyncSourceQueue() {
                            return 0 === this.syncSourceQueue.length;
                          }
                          deSyncSourceQueue() {
                            return this.syncSourceQueue.shift();
                          }
                          detectEntryTransferFromE2ee() {
                            if (gh.isEnableEntryTransferFromE2ee())
                              try {
                                var e;
                                const t =
                                  null === Es.default ||
                                  void 0 === Es.default ||
                                  null ===
                                    (e = Es.default.signalProtocolManager) ||
                                  void 0 === e
                                    ? void 0
                                    : e.getListUserE2ee();
                                t &&
                                  t.length >= gh.getMinNumberOfE2eeConvs() &&
                                  (this.enSyncSourceQueue(
                                    Wn.i.E2EE_MISSING_MESSAGE
                                  ),
                                  this.dispatchEvent(
                                    new Dr.b(Dr.a.NotifyE2eeConvChangeDevice)
                                  ),
                                  this.metricts.receiveChangeDeviceOnE2eeConvsSignal());
                              } catch (t) {}
                          }
                          getSyncSource() {
                            const e = this.deSyncSourceQueue();
                            return (
                              e &&
                                this.Logger.zsymb(
                                  0,
                                  11471,
                                  30001,
                                  "[getSyncSource] Get sync source in queue: " +
                                    JSON.stringify(e)
                                ),
                              e
                            );
                          }
                          handlePublicEvents(e) {
                            if (e.type === Dr.a.ChangeDevice)
                              this.Logger.zsymb(
                                0,
                                11471,
                                30002,
                                "[handlePublicEvents] Event change device"
                              ),
                                this.detectEntryTransferFromE2ee();
                          }
                          addPublicListeners() {
                            this.addEventListener(
                              Dr.a.ChangeDevice,
                              this.handlePublicEvents.bind(this)
                            );
                          }
                        })
                      ) || ph)
                  ) || ph)
              ) || ph)
          ) || ph)
      );
      var mh = s("dhS6"),
        vh = s("WzIS"),
        fh = s("sLvT");
      let bh;
      !(function (e) {
        (e[(e.ONE = 0)] = "ONE"), (e[(e.MULTI = 1)] = "MULTI");
      })(bh || (bh = {}));
      const _h = (e) =>
        new Promise((t, s) => {
          setTimeout(() => {
            t(e || 3e3);
          }, e || 3e3);
        });
      var Sh;
      let yh =
        Object(B.b)(mh.a)(
          (Sh =
            Reflect.metadata(
              "design:type",
              Function
            )(
              (Sh =
                Reflect.metadata(
                  "design:paramtypes",
                  []
                )(
                  (Sh = class {
                    get Logger() {
                      return (
                        this._Logger ||
                          (this._Logger = a.ModuleContainer.resolve(
                            O.ZLoggerFactory
                          ).createZLogger(Ut.b.uiBannerController, [
                            Ut.b.uiBannerQueue,
                          ])),
                        this._Logger
                      );
                    }
                    constructor() {
                      Object(i.a)(this, "type", void 0),
                        Object(i.a)(this, "name", void 0),
                        Object(i.a)(this, "key", void 0),
                        Object(i.a)(this, "queue", void 0),
                        Object(i.a)(this, "uiState", new Map()),
                        Object(i.a)(
                          this,
                          "isFirtTriggerShowOnQueueCycle",
                          void 0
                        ),
                        Object(i.a)(this, "_Logger", void 0),
                        (this.name = mh.b),
                        (this.key = "convId"),
                        (this.queue = []),
                        (this.isFirtTriggerShowOnQueueCycle = !0);
                    }
                    enBannerQueue(e, t) {
                      const s = this.queryBannerQueueItem(e.key);
                      switch ((s && this.removeBannerQueueItem(s.key), t)) {
                        case vh.a.NORMAL:
                          this.queue.push(e);
                          break;
                        case vh.a.HIGH:
                          this.queue.unshift(e);
                      }
                    }
                    isEmptySyncSourceQueue() {
                      return 0 === this.queue.length;
                    }
                    deBannerQueue() {
                      return this.queue.shift();
                    }
                    removeBannerQueueItem(e) {
                      this.queue = [...this.queue].filter((t) => t.key !== e);
                    }
                    queryBannerQueueItem(e) {
                      return this.queue.find((t) => t.key === e);
                    }
                    handleShowUIBanner(e, t) {
                      fh.a.isEnableSingleUIBanner()
                        ? this.showSingleUI(e, t)
                        : this.showMultiUI(e, t);
                    }
                    isExistingShow() {
                      try {
                        const e = Object.fromEntries(this.uiState);
                        for (const t in e) if (e[t]) return t;
                        return null;
                      } catch (e) {
                        return null;
                      }
                    }
                    async showSingleUI(e, t) {
                      let s;
                      this.enBannerQueue({ key: e, priority: t }, t);
                      const i = this.isExistingShow();
                      if (
                        (i && (s = this.queryBannerQueueItem(i)),
                        fh.a.isEnableForceCloseNormalBanner() &&
                          i &&
                          t === vh.a.HIGH &&
                          s)
                      )
                        return (
                          this.removeBannerQueueItem(s.key),
                          this.uiState.set(s.key, !1),
                          Object(yt.g)(this.name, s.key),
                          this.uiState.set(e, !0),
                          void Object(yt.g)(this.name, e)
                        );
                      !i &&
                        this.isFirtTriggerShowOnQueueCycle &&
                        (this.uiState.set(e, !0),
                        Object(yt.g)(this.name, e),
                        this.Logger.zsymb(
                          0,
                          11400,
                          3e4,
                          "[showSingleUI] Dont have displaying banner so show: " +
                            e +
                            ", current queue = " +
                            JSON.stringify(this.queue)
                        ));
                    }
                    showMultiUI(e, t) {
                      this.enBannerQueue({ key: e, priority: t }, t),
                        this.uiState.set(e, !0),
                        Object(yt.g)(this.name, e);
                    }
                    handleHideUIBanner(e) {
                      fh.a.isEnableSingleUIBanner()
                        ? this.hideSingleUI(e)
                        : this.hideMultiUI(e);
                    }
                    hideSingleUI(e) {
                      if (
                        (this.removeBannerQueueItem(e), this.uiState.get(e))
                      ) {
                        this.uiState.set(e, !1), Object(yt.g)(this.name, e);
                        Boolean(this.queue[0])
                          ? setTimeout(() => {
                              const e = this.queue[0];
                              e && !this.isExistingShow()
                                ? (this.uiState.set(e.key, !0),
                                  Object(yt.g)(this.name, e.key),
                                  this.Logger.zsymb(
                                    0,
                                    11400,
                                    30001,
                                    "[hideSingleUI] Pop next banner to show: " +
                                      e.key +
                                      ", current queue = " +
                                      JSON.stringify(this.queue)
                                  ))
                                : (this.isFirtTriggerShowOnQueueCycle = !0);
                            }, fh.a.getTimeDelayOnNextBanner())
                          : (this.isFirtTriggerShowOnQueueCycle = !0);
                      }
                    }
                    hideMultiUI(e) {
                      this.removeBannerQueueItem(e),
                        this.uiState.set(e, !1),
                        Object(yt.g)(this.name, e);
                    }
                    async onShowBanner(e, t, s) {
                      s && (await _h(s));
                      const i = fh.a.getTimeDelayOnStartApp();
                      this.isFirtTriggerShowOnQueueCycle && i
                        ? (await _h(i), this.handleShowUIBanner(e, t))
                        : this.handleShowUIBanner(e, t),
                        (this.isFirtTriggerShowOnQueueCycle = !1);
                    }
                    async onHideBanner(e, t) {
                      t && (await _h(t)), this.handleHideUIBanner(e);
                    }
                    init(e) {
                      throw new Error("Method not implemented.");
                    }
                    getItem(e, t) {
                      return this.uiState.get(e.key);
                    }
                    getList(e, t) {
                      throw new Error("Method not implemented.");
                    }
                    onGetItemFailure(e, t) {
                      throw new Error("Method not implemented.");
                    }
                    onGetListFailure(e, t) {
                      throw new Error("Method not implemented.");
                    }
                    getDefaultItem() {
                      throw new Error("Method not implemented.");
                    }
                    getDefaultList() {
                      throw new Error("Method not implemented.");
                    }
                  })
                ) || Sh)
            ) || Sh)
        ) || Sh;
      a.ModuleContainer.registerSingleton(mh.a, yh);
      s("Q/Ir"), s("Ljqs");
    },
  },
]);
//# sourceMappingURL=../sourcemaps/lazy/main-startup.d5834cf7e332add784f2.js.map
